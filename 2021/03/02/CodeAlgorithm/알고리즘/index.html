<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>기본 핵심 알고리즘 (정렬, 탐색) | My 1st Hexo Blog</title>
  <meta name="keywords" content=" Algorithm Basic ">
  <meta name="description" content="기본 핵심 알고리즘 (정렬, 탐색) | My 1st Hexo Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="알고리즘Ctrl + F 를 사용해서 검색! 이 글의 Dave Lee 선생님의 강의를 듣고 작성된 내용이며, 가장 일반적이고 핵심이 되는 알고리즘에 대해 다루고 있습니다. 아래 목차에 나와있는 알고리즘을 복습을 할 때 사용하고자 글을 작성하였습니다. 랜선 동기 또는 학우님들께 도움이 됐으면 합니다. 모든 내용의 출처는 Dave Lee 선생님의 사이트에 있음을">
<meta property="og:type" content="article">
<meta property="og:title" content="기본 핵심 알고리즘 (정렬, 탐색)">
<meta property="og:url" content="https://chaejin-jen.github.io/2021/03/02/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.html">
<meta property="og:site_name" content="My 1st Hexo Blog">
<meta property="og:description" content="알고리즘Ctrl + F 를 사용해서 검색! 이 글의 Dave Lee 선생님의 강의를 듣고 작성된 내용이며, 가장 일반적이고 핵심이 되는 알고리즘에 대해 다루고 있습니다. 아래 목차에 나와있는 알고리즘을 복습을 할 때 사용하고자 글을 작성하였습니다. 랜선 동기 또는 학우님들께 도움이 됐으면 합니다. 모든 내용의 출처는 Dave Lee 선생님의 사이트에 있음을">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACvisualgo.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/pytutor.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/pytutor2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACvisualgo.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/bubblealgo.png">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/recursivecall.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/palindrome.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/algopractice.jpg">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/Fibonacci.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dp.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC3.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC%EA%B2%B0%EA%B3%BC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/quicksortworks.jpg">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/mergesortcomplexity.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/binarysearch.png">
<meta property="og:image" content="https://www.mathwarehouse.com/programming/images/binary-vs-linear-search/binary-and-linear-search-animations.gif">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/graph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/simplepath.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/undirectedgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/directedgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/weightedgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/disconnectedgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/acyclicgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/completegraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/BFSDFS.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/bfsgraph.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/BFSQueue.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/BFSQueue2.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/bfsqueue.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/graph_dict.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/bfsgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/BFSDFS.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dfsgraph.png">
<meta property="og:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/DFSQueStack.png">
<meta property="og:image" content="https://chaejin-jen.github.io/2021/03/02/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/00_Images/dfsgraph.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/knapsack.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/greedy.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_initial.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_1st.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_2nd.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_3rd.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_3-2th.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_4th.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra_5th.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/dijkstra.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/spanningtree.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/mst.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/kruscal_internal1.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/kruscal_internal2.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/initial_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/union_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/find_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/worst_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/unionbyrank_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/unionbyranksame_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/pathcompression_findunion.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/kruscal_time.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/prim1.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/prim2.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/prim3.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/statespacetree.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/queen_move.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/backtracking.png">
<meta property="og:image" content="https://www.fun-coding.org/00_Images/nqueen.png">
<meta property="article:published_time" content="2021-03-02T02:50:47.758Z">
<meta property="article:modified_time" content="2021-03-02T02:56:16.980Z">
<meta property="article:author" content="Chaejin Kim">
<meta property="article:tag" content="Algorithm Basic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaejin-jen.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACvisualgo.png">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="hide-list">
        <div class="semicircle" data-title=" close">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>Chaejin Kim</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <i class="iconfont icon-rss"></i>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/chaejin-jen"
               target="_blank">
                
                    <i class="iconfont icon-github"></i>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(2)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="Algorithm">
                        <i class="fold iconfont icon-right"></i>
                        
                        Algorithm
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Algorithm<--->Basic">
                                        
                                        Basic
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
</ul>
<div class="right-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="2">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="outline-panel" style="display: none">
            <div class="right-title">Outline</div>
            <i class="iconfont icon-list" data-title="카테고리"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="이전"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="대소 문자 구분"></i>
            <i class="iconfont icon-tag" data-title="태그검색"></i>
        </div>
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="검색 "></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="개요보기 "></i>
        </div>        
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm Basic</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All Algorithm Basic "
           href="/2021/03/02/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
           data-tag="Algorithm Basic"
           data-author="" >
            <span class="post-title" title="기본 핵심 알고리즘 (정렬, 탐색)">기본 핵심 알고리즘 (정렬, 탐색)</span>
            <span class="post-date" title="2021-03-02 11:50:47">2021/03/02</span>
        </a>
        
        <a  class="All "
           href="/2021/02/07/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2021-02-07 00:13:59">2021/02/07</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-CodeAlgorithm/알고리즘" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">기본 핵심 알고리즘 (정렬, 탐색)</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Algorithm">Algorithm</a> > 
            
            <a  data-rel="Algorithm&lt;---&gt;Basic">Basic</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">Algorithm Basic</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2021-03-02 11:56:16'>2021-03-02 11:50</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%AA%A9%EC%B0%A8"><span class="toc-text">목차</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%82%AC%EC%9D%B4%ED%8A%B8"><span class="toc-text">참고하면 좋은 사이트</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC-bubble-sort"><span class="toc-text">버블 정렬 (bubble sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%A0%95%EB%A0%AC-sorting-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 정렬 (sorting) 이란?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC-bubble-sort-%EB%9E%80"><span class="toc-text">2. 버블 정렬 (bubble sort) 란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-%EC%A0%95%EB%A0%AC-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8"><span class="toc-text">코드, 정렬 눈으로 확인:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B9%8C"><span class="toc-text">3. 어떻게 코드로 만들까?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%97%B0%EC%8A%B5"><span class="toc-text">프로그래밍 연습</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84"><span class="toc-text">4. 알고리즘 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D"><span class="toc-text">5. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC-selection-sort"><span class="toc-text">선택 정렬 (selection sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC-selection-sort-%EB%9E%80"><span class="toc-text">1. 선택 정렬 (selection sort) 란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A7%81%EC%A0%91-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8-https-visualgo-net-en-sorting"><span class="toc-text">직접 눈으로 확인 : https:&#x2F;&#x2F;visualgo.net&#x2F;en&#x2F;sorting</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B9%8C"><span class="toc-text">2. 어떻게 코드로 만들까?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84"><span class="toc-text">3. 알고리즘 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D"><span class="toc-text">4. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC-insertion-sort"><span class="toc-text">삽입 정렬 (insertion sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%82%BD%EC%9E%85-%EC%A0%95%EB%A0%AC-insertion-sort-%EB%9E%80"><span class="toc-text">1. 삽입 정렬 (insertion sort) 란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A7%81%EC%A0%91-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8-https-visualgo-net-en-sorting-1"><span class="toc-text">직접 눈으로 확인: https:&#x2F;&#x2F;visualgo.net&#x2F;en&#x2F;sorting</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B9%8C-%EA%B2%B0%EA%B5%AD-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9C%BC%EB%A1%9C-%EC%9D%BC%EB%B0%98%ED%99%94%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8F%84%EB%A1%9D-%EB%A7%8C%EB%93%9C%EB%8A%94-%EA%B2%83"><span class="toc-text">2. 어떻게 코드로 만들까? (결국 프로그래밍으로 일반화할 수 있도록 만드는 것)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84-1"><span class="toc-text">3. 알고리즘 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D-1"><span class="toc-text">4. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9E%AC%EA%B7%80-%EC%9A%A9%EB%B2%95-recursive-call-%EC%9E%AC%EA%B7%80-%ED%98%B8%EC%B6%9C"><span class="toc-text">재귀 용법 (recursive call, 재귀 호출)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%9E%AC%EA%B7%80-%EC%9A%A9%EB%B2%95-recursive-call-%EC%9E%AC%EA%B7%80-%ED%98%B8%EC%B6%9C"><span class="toc-text">1. 재귀 용법 (recursive call, 재귀 호출)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%9E%AC%EA%B7%80-%EC%9A%A9%EB%B2%95-%EC%9D%B4%ED%95%B4"><span class="toc-text">2. 재귀 용법 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%98%88%EC%A0%9C"><span class="toc-text">예제</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0"><span class="toc-text">분석하기</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-%EB%A0%88%EB%B2%A8%EB%A1%9C-%EC%A0%81%EC%96%B4%EB%B3%B4%EA%B8%B0"><span class="toc-text">코드 레벨로 적어보기</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">시간 복잡도와 공간 복잡도</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%9E%AC%EA%B7%80-%ED%98%B8%EC%B6%9C%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%98%95%ED%83%9C"><span class="toc-text">3. 재귀 호출의 일반적인 형태</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9E%AC%EA%B7%80-%ED%98%B8%EC%B6%9C%EC%9D%80-%EC%8A%A4%ED%83%9D%EC%9D%98-%EC%A0%84%ED%98%95%EC%A0%81%EC%9D%B8-%EC%98%88"><span class="toc-text">재귀 호출은 스택의 전형적인 예</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%9E%AC%EA%B7%80-%EC%9A%A9%EB%B2%95%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%97%B0%EC%8A%B5"><span class="toc-text">4. 재귀 용법을 활용한 프로그래밍 연습</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC"><span class="toc-text">팩토리얼</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%A6%AC%EC%8A%A4%ED%8A%B8%ED%95%A9"><span class="toc-text">리스트합</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%9A%8C%EB%AC%B8%ED%8C%90%EB%8B%A8%EB%AC%B8%EC%A0%9C"><span class="toc-text">회문판단문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9E%AC%EA%B7%80%EC%9A%A9%EB%B2%95-%EB%AC%B8%EC%A0%9C"><span class="toc-text">재귀용법 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D%EC%9D%84-%EC%97%B0%EC%8A%B5%EC%9E%A5%EC%97%90-%EC%9E%91%EC%84%B1%ED%95%B4-%EB%B3%B8-%EC%98%88"><span class="toc-text">문제 분석을 연습장에 작성해 본 예</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95%EA%B3%BC-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5"><span class="toc-text">동적 계획법과 분할 정복</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%A0%95%EC%9D%98"><span class="toc-text">1. 정의</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EA%B3%B5%ED%86%B5%EC%A0%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4%EC%A0%90"><span class="toc-text">2. 공통점과 차이점</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%ED%95%B4"><span class="toc-text">3. 동적 계획법 알고리즘 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#recursive-call-%ED%99%9C%EC%9A%A9"><span class="toc-text">recursive call 활용</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-%ED%99%9C%EC%9A%A9-Mamorization"><span class="toc-text">동적 계획법 활용 (Mamorization)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%A4%ED%96%89-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B3%B4%EB%A9%B0-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EA%B8%B0-%EC%BD%94%EB%93%9C%EB%B6%84%EC%84%9D"><span class="toc-text">실행 코드를 보며 이해해보기: 코드분석</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Brute-Force-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89"><span class="toc-text">Brute Force(완전탐색)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%80%B5-%EC%A0%95%EB%A0%AC-quick-sort"><span class="toc-text">퀵 정렬 (quick sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%ED%80%B5-%EC%A0%95%EB%A0%AC-quick-sort-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 퀵 정렬 (quick sort) 이란?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B9%8C-1"><span class="toc-text">2. 어떻게 코드로 만들까?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84-2"><span class="toc-text">3. 알고리즘 구현</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list-comprehension%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84"><span class="toc-text">list comprehension으로 구현</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D-2"><span class="toc-text">4. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC-merge-sort"><span class="toc-text">병합 정렬 (merge sort)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC-%EA%B0%9C%EC%9A%94"><span class="toc-text">1. 병합 정렬 개요</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A7%81%EC%A0%91-%EB%88%88%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%A9%B4-%EB%8D%94-%EC%9D%B4%ED%95%B4%EA%B0%80-%EC%89%BD%EB%8B%A4-https-visualgo-net-en-sorting"><span class="toc-text">직접 눈으로 보면 더 이해가 쉽다: https:&#x2F;&#x2F;visualgo.net&#x2F;en&#x2F;sorting</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%ED%95%B4"><span class="toc-text">2. 알고리즘 이해</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84-3"><span class="toc-text">3. 알고리즘 구현</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9E%91%EC%9D%80-%EB%B6%80%EB%B6%84%EB%B6%80%ED%84%B0-%EC%9E%91%EC%84%B1%ED%95%B4%EC%84%9C-%ED%95%98%EB%82%98%EC%94%A9-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0"><span class="toc-text">작은 부분부터 작성해서 하나씩 구현하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9E%AC%EA%B7%80%EC%9A%A9%EB%B2%95-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0"><span class="toc-text">재귀용법 활용하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#merge-%ED%95%A8%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="toc-text">merge 함수 만들기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B5%9C%EC%A2%85-%EC%BD%94%EB%93%9C"><span class="toc-text">최종 코드</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D-3"><span class="toc-text">4. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%88%9C%EC%B0%A8-%ED%83%90%EC%83%89-Sequential-Search"><span class="toc-text">순차 탐색 (Sequential Search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%88%9C%EC%B0%A8-%ED%83%90%EC%83%89-Sequential-Search-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 순차 탐색 (Sequential Search) 이란?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D"><span class="toc-text">2. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search"><span class="toc-text">이진 탐색 (Binary Search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-Binary-Search-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 이진 탐색 (Binary Search) 이란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8B%A4%EC%9D%8C-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EB%A8%BC%EC%A0%80-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90"><span class="toc-text">다음 문제를 먼저 생각해보자</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89%EC%9D%98-%EC%9D%B4%ED%95%B4-%EC%88%9C%EC%B0%A8-%ED%83%90%EC%83%89%EA%B3%BC-%EB%B9%84%EA%B5%90%ED%95%98%EB%A9%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0"><span class="toc-text">이진 탐색의 이해 (순차 탐색과 비교하며 이해하기)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89"><span class="toc-text">2. 분할 정복 알고리즘과 이진 탐색</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B9%8C-1"><span class="toc-text">3. 어떻게 코드로 만들까?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84-1"><span class="toc-text">4. 알고리즘 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D-1"><span class="toc-text">5. 알고리즘 분석</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B7%B8%EB%9E%98%ED%94%84-%EC%9D%B4%ED%95%B4"><span class="toc-text">그래프 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EA%B7%B8%EB%9E%98%ED%94%84-Graph-%EB%9E%80"><span class="toc-text">1. 그래프 (Graph) 란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%98%88%EC%A0%9C-%EC%A7%91%EC%97%90%EC%84%9C-%ED%9A%8C%EC%82%AC%EB%A1%9C-%EA%B0%80%EB%8A%94-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A1%9C-%ED%91%9C%ED%98%84%ED%95%9C-%EC%98%88"><span class="toc-text">예제 집에서 회사로 가는 경로를 그래프로 표현한 예</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EA%B7%B8%EB%9E%98%ED%94%84-Graph-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4"><span class="toc-text">2. 그래프 (Graph) 관련 용어</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EA%B7%B8%EB%9E%98%ED%94%84-Graph-%EC%A2%85%EB%A5%98"><span class="toc-text">3. 그래프 (Graph) 종류</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%AC%B4%EB%B0%A9%ED%96%A5-%EA%B7%B8%EB%9E%98%ED%94%84-Undirected-Graph"><span class="toc-text">무방향 그래프 (Undirected Graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B0%A9%ED%96%A5-%EA%B7%B8%EB%9E%98%ED%94%84-Directed-Graph"><span class="toc-text">방향 그래프 (Directed Graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B0%80%EC%A4%91%EC%B9%98-%EA%B7%B8%EB%9E%98%ED%94%84-Weighted-Graph-%EB%98%90%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-Network"><span class="toc-text">가중치 그래프 (Weighted Graph) 또는 네트워크 (Network)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%97%B0%EA%B2%B0-%EA%B7%B8%EB%9E%98%ED%94%84-Connected-Graph-%EC%99%80-%EB%B9%84%EC%97%B0%EA%B2%B0-%EA%B7%B8%EB%9E%98%ED%94%84-Disconnected-Graph"><span class="toc-text">연결 그래프 (Connected Graph) 와 비연결 그래프 (Disconnected Graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%82%AC%EC%9D%B4%ED%81%B4-Cycle-%EA%B3%BC-%EB%B9%84%EC%88%9C%ED%99%98-%EA%B7%B8%EB%9E%98%ED%94%84-Acyclic-Graph"><span class="toc-text">사이클 (Cycle) 과 비순환 그래프 (Acyclic Graph)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%99%84%EC%A0%84-%EA%B7%B8%EB%9E%98%ED%94%84-Complete-Graph"><span class="toc-text">완전 그래프 (Complete Graph)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EA%B7%B8%EB%9E%98%ED%94%84%EC%99%80-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%B0%A8%EC%9D%B4"><span class="toc-text">3. 그래프와 트리의 차이</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89-Breadth-First-Search"><span class="toc-text">너비 우선 탐색 (Breadth-First Search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BFS-%EC%99%80-DFS-%EB%9E%80"><span class="toc-text">1. BFS 와 DFS 란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS-DFS-%EB%B0%A9%EC%8B%9D-%EC%9D%B4%ED%95%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%98%88%EC%A0%9C"><span class="toc-text">BFS&#x2F;DFS 방식 이해를 위한 예제</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95"><span class="toc-text">2. 파이썬으로 그래프를 표현하는 방법</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%99%80-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%91%9C%ED%98%84"><span class="toc-text">그래프 예와 파이썬 표현</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BFS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84"><span class="toc-text">3. BFS 알고리즘 구현</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B7%B8%EB%9E%98%ED%94%84-%ED%81%90-%EC%82%AC%EC%9A%A9"><span class="toc-text">그래프 큐 사용</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">4. 시간 복잡도</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89-Depth-First-Search"><span class="toc-text">깊이 우선 탐색 (Depth-First Search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BFS-%EC%99%80-DFS-%EB%9E%80-1"><span class="toc-text">1. BFS 와 DFS 란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS-DFS-%EB%B0%A9%EC%8B%9D-%EC%9D%B4%ED%95%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%98%88%EC%A0%9C-1"><span class="toc-text">BFS&#x2F;DFS 방식 이해를 위한 예제</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-1"><span class="toc-text">2. 파이썬으로 그래프를 표현하는 방법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DFS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84"><span class="toc-text">3. DFS 알고리즘 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-1"><span class="toc-text">4. 시간 복잡도</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%9D%B4%ED%95%B4"><span class="toc-text">탐욕 알고리즘의 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 탐욕 알고리즘 이란?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%98%88"><span class="toc-text">2. 탐욕 알고리즘 예</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%AC%B8%EC%A0%9C1-%EB%8F%99%EC%A0%84-%EB%AC%B8%EC%A0%9C"><span class="toc-text">문제1: 동전 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%AC%B8%EC%A0%9C2-%EB%B6%80%EB%B6%84-%EB%B0%B0%EB%82%AD-%EB%AC%B8%EC%A0%9C-Fractional-Knapsack-Problem"><span class="toc-text">문제2: 부분 배낭 문제 (Fractional Knapsack Problem)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%9C%EA%B3%84"><span class="toc-text">3. 탐욕 알고리즘의 한계</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%98%88"><span class="toc-text">예</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shortest-Path-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">Shortest Path (최단 경로 알고리즘)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EB%AC%B8%EC%A0%9C%EB%9E%80"><span class="toc-text">1. 최단 경로 문제란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EB%AC%B8%EC%A0%9C-%EC%A2%85%EB%A5%98"><span class="toc-text">최단 경로 문제 종류</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">2. 최단 경로 알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra-algorithm-%EB%A1%9C%EC%A7%81"><span class="toc-text">Dijkstra algorithm 로직</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%98%88%EC%A0%9C%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%ED%99%9C%EC%9A%A9"><span class="toc-text">3. 예제로 이해하는 다익스트라 알고리즘 (우선순위 큐 활용)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EB%8B%A8%EA%B3%84-%EC%B4%88%EA%B8%B0%ED%99%94"><span class="toc-text">1단계: 초기화</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EB%8B%A8%EA%B3%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-%EC%B6%94%EC%B6%9C%ED%95%9C-A-0-%EB%85%B8%EB%93%9C-%EC%B2%AB-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EB%A5%BC-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0"><span class="toc-text">2단계: 우선순위 큐에서 추출한 (A, 0) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EB%8B%A8%EA%B3%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-C-1-%EB%85%B8%EB%93%9C-%EC%B2%AB-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EB%A5%BC-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0"><span class="toc-text">3단계: 우선순위 큐에서 (C, 1) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EB%8B%A8%EA%B3%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-D-2-%EB%85%B8%EB%93%9C-%EC%B2%AB-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EB%A5%BC-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0"><span class="toc-text">4단계: 우선순위 큐에서 (D, 2) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EB%8B%A8%EA%B3%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-E-5-%EB%85%B8%EB%93%9C-%EC%B2%AB-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EB%A5%BC-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0"><span class="toc-text">5단계: 우선순위 큐에서 (E, 5) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EB%8B%A8%EA%B3%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-B-6-F-6-%EB%A5%BC-%EC%88%9C%EC%B0%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B6%94%EC%B6%9C%ED%95%B4-%EA%B0%81-%EB%85%B8%EB%93%9C-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0"><span class="toc-text">6단계: 우선순위 큐에서 (B, 6), (F, 6) 를 순차적으로 추출해 각 노드  기반으로 인접한 노드와의 거리 계산</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EB%8B%A8%EA%B3%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90%EC%97%90%EC%84%9C-F-7-B-8-%EB%A5%BC-%EC%88%9C%EC%B0%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B6%94%EC%B6%9C%ED%95%B4-%EA%B0%81-%EB%85%B8%EB%93%9C-%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C-%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%85%B8%EB%93%9C%EC%99%80%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B3%84%EC%82%B0"><span class="toc-text">6단계: 우선순위 큐에서 (F, 7), (B, 8) 를 순차적으로 추출해 각 노드  기반으로 인접한 노드와의 거리 계산</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%EC%82%AC%EC%9A%A9-%EC%9E%A5%EC%A0%90"><span class="toc-text">우선순위 큐 사용 장점</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B5%AC%ED%98%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%ED%99%9C%EC%9A%A9%EA%B9%8C%EC%A7%80-%ED%8F%AC%ED%95%A8"><span class="toc-text">4. 다익스트라 알고리즘 파이썬 구현 (우선순위 큐 활용까지 포함)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-heapq-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%99%9C%EC%9A%A9%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0"><span class="toc-text">참고: heapq 라이브러리 활용을 통해 우선순위 큐 사용하기</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">다익스트라 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C-%EC%B6%9C%EB%A0%A5"><span class="toc-text">참고: 최단 경로 출력</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">5. 시간 복잡도</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B4%9D-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">총 시간 복잡도</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%ED%9E%99%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">참고: 힙의 시간 복잡도</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spanning-Tree-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC"><span class="toc-text">Spanning Tree (신장 트리)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-%EB%9E%80"><span class="toc-text">1. 신장 트리 란?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC"><span class="toc-text">2. 최소 신장 트리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">3. 최소 신장 트리 알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Kruskal%E2%80%99s-algorithm"><span class="toc-text">1. 크루스칼 알고리즘 (Kruskal’s algorithm)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Union-Find-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">2. Union-Find 알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Union-Find-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EA%B3%A0%EB%A0%A4%ED%95%A0-%EC%A0%90"><span class="toc-text">Union-Find 알고리즘의 고려할 점</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#union-by-rank-%EA%B8%B0%EB%B2%95"><span class="toc-text">union-by-rank 기법</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#path-compression"><span class="toc-text">path compression</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Kruskal%E2%80%99s-algorithm-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1"><span class="toc-text">4. 크루스칼 알고리즘 (Kruskal’s algorithm) 코드 작성</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">시간 복잡도</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prim%E2%80%99s-algorithm"><span class="toc-text">5. 프림 알고리즘 (Prim’s algorithm)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">1. 그림으로 이해하는 프림 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prim%E2%80%99s-algorithm-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%BD%94%EB%93%9C"><span class="toc-text">2. 프림 알고리즘 (Prim’s algorithm) 베이스 코드</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-%ED%8C%8C%EC%9D%B4%EC%8D%AC"><span class="toc-text">3. 프림 알고리즘 코드 작성 (파이썬)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EB%9C%AF%EC%96%B4%EB%B3%B4%EA%B8%B0"><span class="toc-text">뜯어보기</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-2"><span class="toc-text">4. 시간 복잡도</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EA%B0%9C%EC%84%A0%EB%90%9C-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">참고: 개선된 프림 알고리즘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B0%9C%EC%84%A0%EB%90%9C-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-O-ElogV"><span class="toc-text">개선된 프림 알고리즘의 시간 복잡도: $ O(ElogV) $</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B0%B1-%ED%8A%B8%EB%9E%98%ED%82%B9-%EA%B8%B0%EB%B2%95"><span class="toc-text">백 트래킹 기법</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EB%B0%B1-%ED%8A%B8%EB%9E%98%ED%82%B9-backtracking-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 백 트래킹 (backtracking) 이란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%83%81%ED%83%9C-%EA%B3%B5%EA%B0%84-%ED%8A%B8%EB%A6%AC-State-Space-Tree"><span class="toc-text">상태 공간 트리 (State Space Tree)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-N-Queen-%EB%AC%B8%EC%A0%9C-%EC%9D%B4%ED%95%B4"><span class="toc-text">2. N Queen 문제 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pruning-%EA%B0%80%EC%A7%80%EC%B9%98%EA%B8%B0-for-N-Queen-%EB%AC%B8%EC%A0%9C"><span class="toc-text">Pruning (가지치기) for N Queen 문제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promising-for-N-Queen-%EB%AC%B8%EC%A0%9C"><span class="toc-text">Promising for N Queen 문제</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-N-Queen-%EB%AC%B8%EC%A0%9C-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1"><span class="toc-text">3. N Queen 문제 파이썬 코드 작성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%B1%95%ED%84%B0-%EC%88%98%EA%B0%95-%ED%9B%84%EA%B8%B0"><span class="toc-text">알고리즘 챕터 수강 후기</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%95%9E%EC%9C%BC%EB%A1%9C%EC%9D%98-%EA%B3%84%ED%9A%8D"><span class="toc-text">앞으로의 계획</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%B4-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EB%A0%A4%EB%A9%B4"><span class="toc-text">강의에 대해 더 알아보려면</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h1><p><code>Ctrl + F</code> 를 사용해서 검색!</p>
<p>이 글의 Dave Lee 선생님의 강의를 듣고 작성된 내용이며, 가장 일반적이고 핵심이 되는 알고리즘에 대해 다루고 있습니다. 아래 목차에 나와있는 알고리즘을 복습을 할 때 사용하고자 글을 작성하였습니다. 랜선 동기 또는 학우님들께 도움이 됐으면 합니다.</p>
<p>모든 내용의 출처는 <a target="_blank" rel="noopener" href="https://www.fun-coding.org/">Dave Lee 선생님의 사이트</a>에 있음을 밝히며, 단기간에 끝내고자 하신다면 강의 들으시는 것을 추천 드립니다. (+ 강의 수강 시 아래 내용이, ipynb 파일로 제공됩니다.)</p>
<h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul>
<li>정렬<ul>
<li>버블 정렬 (bubble sort)</li>
<li>선택 정렬 (selection sort)</li>
<li>삽입 정렬 (insertion sort)</li>
<li>퀵 정렬 (quick sort)</li>
<li>병합 정렬 (merge sort)</li>
</ul>
</li>
<li>재귀 호출 (recursive call)</li>
<li>동적 계획법과 분할 정복<ul>
<li>동적 계획법 (Dynamic Programming)<ul>
<li>bottom-up</li>
<li>Memoization</li>
</ul>
</li>
<li>분할 정복 (Divide and Conquer)<ul>
<li>top-down</li>
<li>recursive</li>
</ul>
</li>
</ul>
</li>
<li>탐색<ul>
<li>순차 탐색 (Sequential Search)</li>
<li>이진 탐색 (Binary Search)</li>
</ul>
</li>
<li>탐욕 알고리즘 (Greedy algorithm)</li>
<li>그래프 (트리는 비순환 그래프)<ul>
<li>이진 트리 탐색 (Binary Tree Search) - 자료 구조에서 다룸</li>
<li>너비 우선 탐색 (Breadth-First Search)</li>
<li>깊이 우선 탐색 (Depth-First Search)</li>
<li>최단 경로 알고리즘 (Shortest Path)<ul>
<li>다익스트라 알고리즘 (Dijkstra algorithm)</li>
</ul>
</li>
<li>최소 신장 트리 (Spanning Tree)<ul>
<li>Kruskal’s algorithm (크루스칼 알고리즘)<ul>
<li>union-find 알고리즘</li>
<li>union-by-rank 와 path compression 기법</li>
</ul>
</li>
<li>Prim’s algorithm (프림 알고리즘)</li>
</ul>
</li>
</ul>
</li>
<li>백트래킹 (backtracking, 퇴각검색)</li>
</ul>
<!-- 
### 알고리즘 연습 방법
* 알고리즘을 잘 작성하기 위해서는 잘 작성된 알고리즘을 이해하고, 스스로 만들어봐야 함
  - 모사! 그림을 잘 그리기 위해서는 잘 그린 그림을 모방하는 것부터 시작


<div class="alert alert-block alert-info">
<center><strong><font size=4em>알고리즘 연습 방법</font></strong></center>

<font size=3em>1. 연습장과 펜을 준비하자!</font><br><br>
<font size=3em>2. 알고리즘 문제를 읽고 분석...</font><br><br>
<font size=3em>3. 간단하게 테스트용으로 매우 간단한 경우부터 복잡한 경우 순서대로 생각해보면서, 연습장과 펜을 이용하여 **알고리즘**을 생각해본다.</font><br><br>
<font size=3em>4. 가능한 알고리즘이 보인다면, 구현할 알고리즘을 **세부 항목**으로 나누고, 문장으로 세부 항목을 나누어서 적어본다.</font><br><br>
<font size=3em>5. 코드화하기 위해, **데이터 구조** 또는 **사용할 변수**를 정리하고,</font><br><br>
<font size=3em>6. 각 문장을 **코드 레벨**로 적는다.</font><br><br>
<font size=3em>7. *데이터 구조 또는 사용할 변수가 코드에 따라 어떻게 변하는지*를 손으로 적으면서, 임의 데이터로 코드가 정상 동작하는지를 연습장과 펜으로 **검증**한다.</font><br>
</div> -->


<h2 id="참고하면-좋은-사이트"><a href="#참고하면-좋은-사이트" class="headerlink" title="참고하면 좋은 사이트"></a>참고하면 좋은 사이트</h2><p>보는 알고리즘 <a target="_blank" rel="noopener" href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></p>
<blockquote>
<p><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACvisualgo.png" alt="visualgo"></p>
</blockquote>
<p>코드분석 <a target="_blank" rel="noopener" href="http://pythontutor.com/">http://pythontutor.com/</a></p>
<blockquote>
<p>   <img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/pytutor.png" alt="pythontutor1"><br>    메모리 볼 수 있음<br>   <img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/pytutor2.png" alt="pythontutor2"></p>
</blockquote>
<h2 id="버블-정렬-bubble-sort"><a href="#버블-정렬-bubble-sort" class="headerlink" title="버블 정렬 (bubble sort)"></a>버블 정렬 (bubble sort)</h2><hr>
<h3 id="1-정렬-sorting-이란"><a href="#1-정렬-sorting-이란" class="headerlink" title="1. 정렬 (sorting) 이란?"></a>1. 정렬 (sorting) 이란?</h3><ul>
<li>정렬 (sorting): 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 것</li>
<li>정렬은 프로그램 작성시 빈번하게 필요로 함</li>
<li>다양한 알고리즘이 고안되었으며, 알고리즘 학습의 필수</li>
</ul>
<blockquote>
<p>다양한 정렬 알고리즘 이해를 통해, 동일한 문제에 대해 다양한 알고리즘이 고안될 수 있음을 이해하고,<br>각 알고리즘간 성능 비교를 통해, 알고리즘 성능 분석에 대해서도 이해할 수 있음</p>
</blockquote>
<p>잘 정리해놓은 블로그(<a target="_blank" rel="noopener" href="https://medium.com/@lghaske/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-with-big-o-82391afd20a2">https://medium.com/@lghaske/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC-with-big-o-82391afd20a2</a>)</p>
<h3 id="2-버블-정렬-bubble-sort-란"><a href="#2-버블-정렬-bubble-sort-란" class="headerlink" title="2. 버블 정렬 (bubble sort) 란?"></a>2. 버블 정렬 (bubble sort) 란?</h3><ul>
<li>두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘</li>
</ul>
<h4 id="코드-정렬-눈으로-확인"><a href="#코드-정렬-눈으로-확인" class="headerlink" title="코드, 정렬 눈으로 확인:"></a>코드, 정렬 눈으로 확인:</h4><p><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACvisualgo.png" alt="버블정렬visualgo"><br><a target="_blank" rel="noopener" href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" width=600/>

<blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p>
</blockquote>
<h3 id="3-어떻게-코드로-만들까"><a href="#3-어떻게-코드로-만들까" class="headerlink" title="3. 어떻게 코드로 만들까?"></a>3. 어떻게 코드로 만들까?</h3><blockquote>
<p>알고리즘 연습 방법에 기반해서 단계별로 생각해봅니다.</p>
</blockquote>
<h5 id="프로그래밍-연습"><a href="#프로그래밍-연습" class="headerlink" title="프로그래밍 연습"></a>프로그래밍 연습</h5><blockquote>
<p>데이터가 네 개일 때 버블 정렬 알고리즘 방식으로 정렬해보세요</p>
</blockquote>
<ul>
<li>데이터가 네 개 일때 (데이터 갯수에 따라 복잡도가 떨어지는 것은 아니므로, 네 개로 바로 로직을 이해해보자.)<ul>
<li>예: data_list = [1, 9, 3, 2]<ul>
<li>1차 로직 적용<ul>
<li>1 와 9 비교, 자리바꿈없음 [1, 9, 3, 2]</li>
<li>9 와 3 비교, 자리바꿈 [1, 3, 9, 2]</li>
<li>9 와 2 비교, 자리바꿈 [1, 3, 2, 9]</li>
</ul>
</li>
<li>2차 로직 적용<ul>
<li>1 와 3 비교, 자리바꿈없음 [1, 3, 2, 9]</li>
<li>3 과 2 비교, 자리바꿈 [1, 2, 3, 9]</li>
<li><del>3 와 9 비교, 자리바꿈없음 [1, 2, 3, 9]</del></li>
</ul>
</li>
<li>3차 로직 적용<ul>
<li>1 과 2 비교, 자리바꿈없음 [1, 2, 3, 9]</li>
<li><del>2 과 3 비교, 자리바꿈없음 [1, 2, 3, 9]</del></li>
<li><del>3 과 9 비교, 자리바꿈없음 [1, 2, 3, 9]</del></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">데이터길이</th>
<th align="center"><del>조건체크</del></th>
<th align="center"><del>턴</del></th>
<th align="right">조건체크&amp;턴</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center"><del>1</del></td>
<td align="center"><del>1</del></td>
<td align="right">1!</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><del>2</del></td>
<td align="center"><del>2</del></td>
<td align="right">2!</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><del>3</del></td>
<td align="center"><del>3</del></td>
<td align="right">3!</td>
</tr>
</tbody></table>
<h3 id="4-알고리즘-구현"><a href="#4-알고리즘-구현" class="headerlink" title="4. 알고리즘 구현"></a>4. 알고리즘 구현</h3><ul>
<li><strong>특이점 찾아보기</strong><ul>
<li>n개의 리스트가 있는 경우 최대 n-1번의 로직을 적용한다.</li>
<li>로직을 1번 적용할 때마다 가장 큰 숫자가 뒤에서부터 1개씩 결정된다.</li>
<li>로직이 경우에 따라 일찍 끝날 수도 있다. 따라서 로직을 적용할 때 한 번도 데이터가 교환된 적이 없다면 이미 정렬된 상태이므로 더 이상 로직을 반복 적용할 필요가 없다.<img src="https://www.fun-coding.org/00_Images/bubblealgo.png" />
</li>
</ul>
</li>
</ul>
<ol>
<li>for num in range(len(data_list)) 반복</li>
<li>swap = 0 (교환이 되었는지를 확인하는 변수를 두자)</li>
<li>반복문 안에서, for index in range(len(data_list) - num - 1) n - 1번 반복해야 하므로</li>
<li>반복문안의 반복문 안에서, if data_list[index] &gt; data_list[index + 1] 이면</li>
<li><pre><code>           data_list[index], data_list[index + 1] = data_list[index + 1], data_list[index]
</code></pre>
</li>
<li><pre><code>           swap += 1
</code></pre>
</li>
<li>반복문 안에서, if swap == 0 이면, break 끝</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubblesort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> turn <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        swap = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> index2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - turn - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[index2] &gt; data[index2 + <span class="number">1</span>]:</span><br><span class="line">                data[index2], data[index2 + <span class="number">1</span>] = data[index2 + <span class="number">1</span>], data[index2]</span><br><span class="line">                swap = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> swap == <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span> (bubblesort(data_list))</span><br></pre></td></tr></table></figure>
<h3 id="5-알고리즘-분석"><a href="#5-알고리즘-분석" class="headerlink" title="5. 알고리즘 분석"></a>5. 알고리즘 분석</h3><ul>
<li>반복문이 두 개 O($n^2$)<ul>
<li>최악의 경우, <font size=5em>$\frac { n * (n - 1)}{ 2 }$</font></li>
</ul>
</li>
<li>완전 정렬이 되어 있는 상태라면 최선은 O(n)</li>
</ul>
<h2 id="선택-정렬-selection-sort"><a href="#선택-정렬-selection-sort" class="headerlink" title="선택 정렬 (selection sort)"></a>선택 정렬 (selection sort)</h2><p>최소값을 선택해서 앞으로 보냄</p>
<h3 id="1-선택-정렬-selection-sort-란"><a href="#1-선택-정렬-selection-sort-란" class="headerlink" title="1. 선택 정렬 (selection sort) 란?"></a>1. 선택 정렬 (selection sort) 란?</h3><ul>
<li>다음과 같은 순서를 반복하며 정렬하는 알고리즘<ol>
<li>주어진 데이터 중, 최소값을 찾음</li>
<li>해당 최소값을 데이터 맨 앞에 위치한 값과 교체함</li>
<li>맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복함</li>
</ol>
</li>
</ul>
<h4 id="직접-눈으로-확인-https-visualgo-net-en-sorting"><a href="#직접-눈으로-확인-https-visualgo-net-en-sorting" class="headerlink" title="직접 눈으로 확인 : https://visualgo.net/en/sorting"></a>직접 눈으로 확인 : <a target="_blank" rel="noopener" href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></h4><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" width=100>

<p>출처: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Selection_sort">https://en.wikipedia.org/wiki/Selection_sort</a></p>
<h3 id="2-어떻게-코드로-만들까"><a href="#2-어떻게-코드로-만들까" class="headerlink" title="2. 어떻게 코드로 만들까?"></a>2. 어떻게 코드로 만들까?</h3><ul>
<li>데이터가 두 개 일때<ul>
<li>예: dataList = [9, 1]<ul>
<li>data_list[0] &gt; data_list[1] 이므로 data_list[0] 값과 data_ list[1] 값을 교환</li>
</ul>
</li>
</ul>
</li>
<li>데이터가 세 개 일때<ul>
<li>예: data_list = [9, 1, 7]<ul>
<li>처음 한번 실행하면, 1, 9, 7 이 됨</li>
<li>두 번째 실행하면, 1, 7, 9 가 됨</li>
</ul>
</li>
</ul>
</li>
<li>데이터가 네 개 일때<ul>
<li>예: data_list = [9, 3, 2, 1]<ul>
<li>처음 한번 실행하면, 1, 3, 2, 9 가 됨</li>
<li>두 번째 실행하면, 1, 2, 3, 9 가 됨</li>
<li>세 번째 실행하면, 변화 없음</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
데이터가 두개 일때 동작하는 선택 정렬 알고리즘을 함수로 만들어보세요<br>
프로그래밍 근육을 키우는 방법
</div>
<pre>
* 데이터가 두 개 일때
  - 예: data_list = [9, 1]
    - data_list[0] > data_list[1] 이므로 data_list[0] 값과 data_ list[1] 값을 교환
</pre>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
데이터가 두개 일때 동작하는 선택 정렬 알고리즘을 함수로 만들어보세요<br>
프로그래밍 근육을 키우는 방법
</div>

<ul>
<li>데이터가 세 개 일때<ul>
<li>예: data_list = [9, 1, 7]<ul>
<li>처음 한번 실행하면, 1, 9, 7 이 됨</li>
<li>두 번째 실행하면, 1, 7, 9 가 됨<br></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
데이터가 두개 일때 동작하는 선택 정렬 알고리즘을 함수로 만들어보세요<br>
프로그래밍 근육을 키우는 방법
</div>

<ul>
<li>데이터가 네 개 일때<ul>
<li>예: data_list = [9, 3, 2, 1]<ul>
<li>처음 한번 실행하면, 1, 3, 2, 9 가 됨</li>
<li>두 번째 실행하면, 1, 2, 3, 9 가 됨</li>
<li>세 번째 실행하면, 변화 없음<br></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-알고리즘-구현"><a href="#3-알고리즘-구현" class="headerlink" title="3. 알고리즘 구현"></a>3. 알고리즘 구현</h3><ol>
<li>for stand in range(len(data_list) - 1) 로 반복</li>
<li>lowest = stand 로 놓고,</li>
<li>for num in range(stand, len(data_list)) stand 이후부터 반복<ul>
<li>내부 반복문 안에서 data_list[lowest] &gt; data_list[num] 이면, <ul>
<li>lowest = num</li>
</ul>
</li>
</ul>
</li>
<li>data_list[num], data_list[lowest] = data_list[lowest], data_list[num]   </li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> stand <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        lowest = stand</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(stand + <span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="keyword">if</span> data[lowest] &gt; data[index]:</span><br><span class="line">                lowest = index</span><br><span class="line">        data[lowest], data[stand] = data[stand], data[lowest]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selection_sort(data_list)</span><br></pre></td></tr></table></figure>
<p>   [9, 12, 13, 24, 53, 55, 69, 80, 87, 98]</p>
<h3 id="4-알고리즘-분석"><a href="#4-알고리즘-분석" class="headerlink" title="4. 알고리즘 분석"></a>4. 알고리즘 분석</h3><ul>
<li>반복문이 두 개 O($n^2$)<ul>
<li>실제로 상세하게 계산하면, <font size=5em>$\frac { n * (n - 1)}{ 2 }$</font></li>
</ul>
</li>
</ul>
<h2 id="삽입-정렬-insertion-sort"><a href="#삽입-정렬-insertion-sort" class="headerlink" title="삽입 정렬 (insertion sort)"></a>삽입 정렬 (insertion sort)</h2><p>앞에서부터 작은 값을 찾으면 앞으로 보냄(삽입함)<br>선택정렬과는 달리 최솟값이 아닌 앞에보다 작은 값(local min)을 찾음</p>
<h3 id="1-삽입-정렬-insertion-sort-란"><a href="#1-삽입-정렬-insertion-sort-란" class="headerlink" title="1. 삽입 정렬 (insertion sort) 란?"></a>1. 삽입 정렬 (insertion sort) 란?</h3><ul>
<li>삽입 정렬은 두 번째 인덱스부터 시작</li>
<li>해당 인덱스(key 값) 앞에 있는 데이터(B)부터 비교해서 key 값이 더 작으면, B값을 뒤 인덱스로 복사</li>
<li>이를 key 값이 더 큰 데이터를 만날때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 key 값을 이동</li>
</ul>
<h4 id="직접-눈으로-확인-https-visualgo-net-en-sorting-1"><a href="#직접-눈으로-확인-https-visualgo-net-en-sorting-1" class="headerlink" title="직접 눈으로 확인: https://visualgo.net/en/sorting"></a>직접 눈으로 확인: <a target="_blank" rel="noopener" href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></h4><img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" />

<blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif">https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span> (index)</span><br></pre></td></tr></table></figure>
<pre><code>10
9
8
7
6
5
4
3
2
</code></pre>
<table>
<thead>
<tr>
<th align="center">데이터길이</th>
<th align="center">조건체크</th>
<th align="center">턴</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h3 id="2-어떻게-코드로-만들까-결국-프로그래밍으로-일반화할-수-있도록-만드는-것"><a href="#2-어떻게-코드로-만들까-결국-프로그래밍으로-일반화할-수-있도록-만드는-것" class="headerlink" title="2. 어떻게 코드로 만들까? (결국 프로그래밍으로 일반화할 수 있도록 만드는 것)"></a>2. 어떻게 코드로 만들까? (결국 프로그래밍으로 일반화할 수 있도록 만드는 것)</h3><blockquote>
<p>알고리즘 연습 방법에 기반해서 단계별로 생각해봅니다.</p>
</blockquote>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
데이터가 두개 일때 동작하는 삽입 정렬 알고리즘을 함수로 만들어보세요<br>
프로그래밍 근육을 키우는 방법
</div>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
데이터가 세개 일때 동작하는 선택 정렬 알고리즘을 함수로 만들어보세요<br>
프로그래밍 근육을 키우는 방법
</div>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
데이터가 네개 일때 동작하는 선택 정렬 알고리즘을 함수로 만들어보세요<br>
프로그래밍 근육을 키우는 방법
</div>

<ul>
<li>데이터가 네 개 일때 (데이터 갯수에 따라 복잡도가 떨어지는 것은 아니므로, 네 개로 바로 로직을 이해해보자.)<ul>
<li>예: data_list = [9, 3, 2, 5]<ul>
<li>처음 한번 실행하면, key값은 9, 인덱스(0) - 1 은 0보다 작으므로 끝: [9, 3, 2, 5]</li>
<li>두 번째 실행하면, key값은 3, 9보다 3이 작으므로 자리 바꾸고, 끝: [3, 9, 2, 5]</li>
<li>세 번째 실행하면, key값은 2, 9보다 2가 작으므로 자리 바꾸고, 다시 3보다 2가 작으므로 끝: [2, 3, 9, 5]</li>
<li>네 번째 실행하면, key값은 5, 9보다 5이 작으므로 자리 바꾸고, 3보다는 5가 크므로 끝: [2, 3, 5, 9]        </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-알고리즘-구현-1"><a href="#3-알고리즘-구현-1" class="headerlink" title="3. 알고리즘 구현"></a>3. 알고리즘 구현</h3><ol>
<li>for stand in range(len(data_list)) 로 반복</li>
<li>key = data_list[stand]</li>
<li>for num in range(stand, 0, -1) 반복<ul>
<li>내부 반복문 안에서 data_list[stand] &lt; data_list[num - 1] 이면, <ul>
<li>data_list[num - 1], data_list[num] = data_list[num], data_list[num - 1]   </li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>print(*range(5, 0, -1))</p>
<blockquote>
<p>5 4 3 2 1</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> turn <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> index2 <span class="keyword">in</span> <span class="built_in">range</span>(turn + <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[index2] &lt; data[index2 - <span class="number">1</span>]:</span><br><span class="line">                data[index2], data[index2 - <span class="number">1</span>] = data[index2 - <span class="number">1</span>], data[index2]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span> (insertion_sort(data_list))</span><br></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 5, 8, 9, 10, 11, 14, 16, 17, 20, 22, 23, 32, 33, 34, 36, 40, 43, 46, 47, 49, 50, 51, 53, 56, 57, 60, 61, 62, 64, 65, 67, 68, 71, 72, 74, 75, 81, 82, 83, 85, 86, 89, 90, 91, 93, 96, 99]
</code></pre>
<h3 id="4-알고리즘-분석-1"><a href="#4-알고리즘-분석-1" class="headerlink" title="4. 알고리즘 분석"></a>4. 알고리즘 분석</h3><ul>
<li>반복문이 두 개 O($n^2$)<ul>
<li>최악의 경우, <font size=5em>$\frac { n * (n - 1)}{ 2 }$</font></li>
</ul>
</li>
<li>완전 정렬이 되어 있는 상태라면 최선은 O(n)</li>
</ul>
<ul>
<li>이해가 안가면, 이 코드를 보면서 이해하기: <a target="_blank" rel="noopener" href="https://goo.gl/XKBXuk">https://goo.gl/XKBXuk</a></li>
</ul>
<h2 id="재귀-용법-recursive-call-재귀-호출"><a href="#재귀-용법-recursive-call-재귀-호출" class="headerlink" title="재귀 용법 (recursive call, 재귀 호출)"></a>재귀 용법 (recursive call, 재귀 호출)</h2><blockquote>
<p>고급 정렬 알고리즘엥서 재귀 용법을 사용하므로, 고급 정렬 알고리즘을 익히기 전에 재귀 용법을 먼저 익히기로 합니다.</p>
</blockquote>
<h3 id="1-재귀-용법-recursive-call-재귀-호출"><a href="#1-재귀-용법-recursive-call-재귀-호출" class="headerlink" title="1. 재귀 용법 (recursive call, 재귀 호출)"></a>1. 재귀 용법 (recursive call, 재귀 호출)</h3><ul>
<li>함수 안에서 동일한 함수를 호출하는 형태</li>
<li>여러 알고리즘 작성시 사용되므로, 익숙해져야 함</li>
</ul>
<h3 id="2-재귀-용법-이해"><a href="#2-재귀-용법-이해" class="headerlink" title="2. 재귀 용법 이해"></a>2. 재귀 용법 이해</h3><ul>
<li>예제를 풀어보며, 재귀 용법을 이해해보기</li>
</ul>
<h4 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h4><ul>
<li>팩토리얼을 구하는 알고리즘을 Recursive Call 을 활용해서 알고리즘 작성하기</li>
</ul>
<h5 id="분석하기"><a href="#분석하기" class="headerlink" title="분석하기"></a>분석하기</h5><ul>
<li>간단한 경우부터 생각해보기<ul>
<li>2! = 1 X 2</li>
<li>3! = 1 X 2 X 3</li>
<li>4! = 1 X 2 X 3 X 4 = 4 X 3!</li>
</ul>
</li>
<li>규칙이 보임: n! = n X (n - 1)!<ol>
<li>함수를 하나 만든다.</li>
<li>함수(n) 은 n &gt; 1 이면 return n X 함수(n - 1)</li>
<li>함수(n) 은 n = 1 이면 return n</li>
</ol>
</li>
<li>검증 (코드로 검증하지 않고, 직접 간단한 경우부터 대입해서 검증해야 함)<ol>
<li>먼저 2! 부터 </li>
</ol>
<ul>
<li>함수(2) 이면, 2 &gt; 1 이므로 2 X 함수(1)<ul>
<li>함수(1) 은 1 이므로, return 2 X 1 = 2 맞다!</li>
</ul>
</li>
</ul>
<ol start="2">
<li>먼저 3! 부터 </li>
</ol>
<ul>
<li>함수(3) 이면, 3 &gt; 1 이므로 3 X 함수(2)<ul>
<li>함수(2) 는 결국 1번에 의해 2! 이므로, return 2 X 1 = 2 </li>
<li>3 X 함수(2) = 3 X 2 = 3 X 2 X 1 = 6 맞다!</li>
</ul>
</li>
</ul>
<ol start="3">
<li>먼저 4! 부터 </li>
</ol>
<ul>
<li>함수(4) 이면, 4 &gt; 1 이므로 4 X 함수(3)<ul>
<li>함수(3) 은 결국 2번에 의해 3 X 2 X 1 = 6 </li>
<li>4 X 함수(3) = 4 X 6 = 24 맞다! </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="코드-레벨로-적어보기"><a href="#코드-레벨로-적어보기" class="headerlink" title="코드 레벨로 적어보기"></a>코드 레벨로 적어보기</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span> (factorial(num))</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
6
24
120
720
5040
40320
362880
</code></pre>
<h5 id="시간-복잡도와-공간-복잡도"><a href="#시간-복잡도와-공간-복잡도" class="headerlink" title="시간 복잡도와 공간 복잡도"></a>시간 복잡도와 공간 복잡도</h5><ul>
<li><p>factorial(n) 은 n - 1 번의 factorial() 함수를 호출해서, 곱셈을 함 </p>
<ul>
<li>일종의 n-1번 반복문을 호출한 것과 동일</li>
<li>factorial() 함수를 호출할 때마다, 지역변수 n 이 생성됨</li>
</ul>
</li>
<li><p>시간 복잡도/공간 복잡도는 O(n-1) 이므로 결국, 둘 다 O(n)</p>
</li>
</ul>
<h3 id="3-재귀-호출의-일반적인-형태"><a href="#3-재귀-호출의-일반적인-형태" class="headerlink" title="3. 재귀 호출의 일반적인 형태"></a>3. 재귀 호출의 일반적인 형태</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 일반적인 형태1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">입력</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 입력 &gt; 일정값:                           <span class="comment"># 입력이 일정 값 이상이면</span></span><br><span class="line">        <span class="keyword">return</span> function(입력 - <span class="number">1</span>)               <span class="comment"># 입력보다 작은 값</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> 일정값, 입력값, 또는 특정값       <span class="comment"># 재귀 호출 종료</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 일반적인 형태2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">입력</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 입력 &lt;= 일정값:                          <span class="comment"># 입력이 일정 값보다 작으면</span></span><br><span class="line">        <span class="keyword">return</span> 일정값, 입력값, 또는 특정값       <span class="comment"># 재귀 호출 종료</span></span><br><span class="line">    function(입력보다 작은 값)</span><br><span class="line">    <span class="keyword">return</span> 결과값</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span> (factorial(num))</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
6
24
120
720
5040
40320
362880
</code></pre>
<h3 id="재귀-호출은-스택의-전형적인-예"><a href="#재귀-호출은-스택의-전형적인-예" class="headerlink" title="재귀 호출은 스택의 전형적인 예"></a>재귀 호출은 스택의 전형적인 예</h3><blockquote>
<p>함수는 내부적오르 스택처럼 관리된다.</p>
</blockquote>
<img src="https://www.fun-coding.org/00_Images/recursivecall.png" />

<ul>
<li>재귀 호출이 이해가 가지 않는다면? - <a target="_blank" rel="noopener" href="http://pythontutor.com/live.html#code=%23%20factorial%20%ED%95%A8%EC%88%98%20%EC%95%88%EC%97%90%EC%84%9C%20factorial%20%ED%95%A8%EC%88%98%EB%A5%BC%20%ED%98%B8%EC%B6%9C%0Adef%20factorial%28num%29%3A%0A%20%20%20%20if%20num%20%3E%201%3A%0A%20%20%20%20%20%20%20%20return%20num%20*%20factorial%28num%20-%201%29%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20num%0A%0Afactorial%285%29&cumulative=false&curInstr=22&heapPrimitives=false&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false">코드분석</a></li>
</ul>
<blockquote>
<p>참고: 파이썬에서 재귀 함수는 깊이가(한번에 호출되는…) 1000회 이하가 되어야 함 (파이썬에서 스택공간을 미리 잡아놨다는 뜻)</p>
</blockquote>
<h3 id="4-재귀-용법을-활용한-프로그래밍-연습"><a href="#4-재귀-용법을-활용한-프로그래밍-연습" class="headerlink" title="4. 재귀 용법을 활용한 프로그래밍 연습"></a>4. 재귀 용법을 활용한 프로그래밍 연습</h3><h4 id="팩토리얼"><a href="#팩토리얼" class="headerlink" title="팩토리얼"></a>팩토리얼</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
다음 함수를 재귀 함수를 활용해서 완성해서 1부터 num까지의 곱이 출력되게 만드세요
</div>
<pre>
def muliple(data):
    if data <= 1:
        return data
    
    return -------------------------
    
multiple(10)
</pre>
</div>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple</span>(<span class="params">num</span>):</span></span><br><span class="line">    return_value = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        return_value = return_value * index</span><br><span class="line">    <span class="keyword">return</span> return_value</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> num * multiple(num - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiple(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>3628800</p>
<h4 id="리스트합"><a href="#리스트합" class="headerlink" title="리스트합"></a>리스트합</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
숫자가 들어 있는 리스트가 주어졌을 때, 리스트의 합을 리턴하는 함수를 만드세요
</div>
<pre>
참고: 임의 값으로 리스트 만들기 random.sample(0 ~ 99까지 중에서, 임의로 10개를 만들어서 10개 값을 가지는 리스트 변수 만들기
import random 
data = random.sample(range(100), 10)
</pre>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random </span><br><span class="line">data = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>[72, 50, 8, 38, 77, 32, 90, 48, 74, 79]</p>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
숫자가 들어 있는 리스트가 주어졌을 때, 리스트의 합을 리턴하는 함수를 만드세요 (재귀함수를 써보세요)
</div>
<pre>
def sum_list(data):
    if len(data) == 1:
        return data[0]
    
    return --------------------------------

<p>import random<br>data = random.sample(range(100), 10)<br>print (sum_list(data))<br></pre></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_list</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">0</span>] + sum_list(data[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum_list(data)</span><br></pre></td></tr></table></figure>
<p>568</p>
<h4 id="회문판단문제"><a href="#회문판단문제" class="headerlink" title="회문판단문제"></a>회문판단문제</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
회문(palindrome)은 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 의미함<br>
회문을 판별할 수 있는 함수를 리스트 슬라이싱을 활용해서 만드세요
<img src="https://www.fun-coding.org/00_Images/palindrome.png" width=200/>
</div>
<pre>
참고 - 리스트 슬라이싱
string = 'Dave' 
string[-1] --> e
string[0] --> D
string[1:-1] --> av
string[:-1] --> Dav
</pre>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
회문(palindrome)은 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 의미함<br>
회문을 판별할 수 있는 함수를 재귀함수를 활용해서 만들어봅니다.
</div>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrome</span>(<span class="params">string</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strung) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> string[<span class="number">0</span>] == string[-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> palindrome(string[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="재귀용법-문제"><a href="#재귀용법-문제" class="headerlink" title="재귀용법 문제"></a>재귀용법 문제</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
1, 정수 n에 대해<br>
1. n이 홀수이면 3 X n + 1 을 하고,<br>
2. n이 짝수이면 n 을 2로 나눕니다.<br>
3. 이렇게 계속 진행해서 n 이 결국 1이 될 때까지 2와 3의 과정을 반복합니다.<br>
<br>
예를 들어 n에 3을 넣으면,  
<pre>
3
10
5
16
8
4
2
1
</pre>
이 됩니다.

<p>이렇게 정수 n을 입력받아, 위 알고리즘에 의해 1이 되는 과정을 모두 출력하는 함수를 작성하세요.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_one</span>(<span class="params">n</span>):</span></span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> make_one(<span class="number">3</span>*n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> make_one(<span class="built_in">int</span>(n/<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_one(<span class="number">3</span>)        </span><br></pre></td></tr></table></figure>

<pre><code>3
10
5
16
8
4
2
1
</code></pre>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
<pre>
문제: 정수 4를 1, 2, 3의 조합으로 나타내는 방법은 다음과 같이 총 7가지가 있음
1+1+1+1
1+1+2
1+2+1
2+1+1
2+2
1+3
3+1
정수 n이 입력으로 주어졌을 때, n을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수를 구하시오
</pre>    

<p>힌트: 정수 n을 만들 수 있는 경우의 수를 리턴하는 함수를 f(n) 이라고 하면,<br><br>f(n)은 f(n-1) + f(n-2) + f(n-3) 과 동일하다는 패턴 찾기<br><br>출처: ACM-ICPC &gt; Regionals &gt; Asia &gt; Korea &gt; Asia Regional - Taejon 2001 </p>
</div>

<h4 id="문제-분석을-연습장에-작성해-본-예"><a href="#문제-분석을-연습장에-작성해-본-예" class="headerlink" title="문제 분석을 연습장에 작성해 본 예"></a>문제 분석을 연습장에 작성해 본 예</h4><img src="https://www.fun-coding.org/00_Images/algopractice.jpg" />


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> data == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> data == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> data == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> func(data -<span class="number">1</span>) + func(data - <span class="number">2</span>) + func(data - <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<pre><code>13
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="동적-계획법과-분할-정복"><a href="#동적-계획법과-분할-정복" class="headerlink" title="동적 계획법과 분할 정복"></a>동적 계획법과 분할 정복</h2><p>Dynamic Programming &amp; Divide and Conquer</p>
<h3 id="1-정의"><a href="#1-정의" class="headerlink" title="1. 정의"></a>1. 정의</h3><ul>
<li>동적계획법 (Dynamic Programming, DP)<ul>
<li>입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘</li>
<li>상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식 </li>
<li>bottom-up: 작은 문제들부터 해결 후 이를 바탕으로 더 큰 문제들을 해결, 반복(iterative) 방식 사용</li>
<li>Memoization 기법을 사용함<ul>
<li>Memoization (메모이제이션) 이란: 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술</li>
</ul>
</li>
<li>문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용됨<ul>
<li>예: 피보나치 수열</li>
</ul>
</li>
</ul>
</li>
<li>분할 정복 (divide-and-conquer)<ul>
<li>문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘</li>
<li>하향식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식<ul>
<li>top-down: 처음부터 큰 문제를 방문 후 작은 문제를 호출, 재귀(recursive)방식 사용</li>
<li>일반적으로 재귀함수로 구현</li>
</ul>
</li>
<li>문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음<ul>
<li>예: 병합 정렬, 퀵 정렬 등</li>
</ul>
</li>
<li>최소값(최대값) 찾기 알고리즘, 이진 탐색 알고리즘, 병합 정렬 알고리즘</li>
</ul>
</li>
</ul>
<h3 id="2-공통점과-차이점"><a href="#2-공통점과-차이점" class="headerlink" title="2. 공통점과 차이점"></a>2. 공통점과 차이점</h3><ul>
<li>공통점<ul>
<li>문제를 잘게 쪼개서, 가장 작은 단위로 분할</li>
</ul>
</li>
<li>차이점<ul>
<li>동적 계획법<ul>
<li>부분 문제는 중복되어, 상위 문제 해결 시 재활용됨</li>
<li>Memoization 기법 사용 (부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)</li>
</ul>
</li>
<li>분할 정복<ul>
<li>부분 문제는 서로 중복되지 않음</li>
<li>Memoization 기법 사용 안함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-동적-계획법-알고리즘-이해"><a href="#3-동적-계획법-알고리즘-이해" class="headerlink" title="3. 동적 계획법 알고리즘 이해"></a>3. 동적 계획법 알고리즘 이해</h3><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
피보나치 수열: n 을 입력받아서 다음과 같이 계산됨<br>
n 을 입력받았을 때 피보나치 수열로 결과값을 출력하세요<br>
</div>
<img src="https://www.fun-coding.org/00_Images/Fibonacci.png" />
<pre>
함수를 fibonacci 라고 하면,
fibonacci(0):0
fibonacci(1):1
fibonacci(2):1
fibonacci(3):2
fibonacci(4):3
fibonacci(5):5
fibonacci(6):8
fibonacci(7):13
fibonacci(8):21
fibonacci(9):34
</pre>

<img src="https://www.fun-coding.org/00_Images/dp.png" />

<h4 id="recursive-call-활용"><a href="#recursive-call-활용" class="headerlink" title="recursive call 활용"></a>recursive call 활용</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> fibo(num - <span class="number">1</span>) + fibo(num - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fibo(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>3</p>
<h4 id="동적-계획법-활용-Mamorization"><a href="#동적-계획법-활용-Mamorization" class="headerlink" title="동적 계획법 활용 (Mamorization)"></a>동적 계획법 활용 (Mamorization)</h4><p>숫자가 커질 수록 속도가 재귀함수보다 빠름  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibo_dp</span>(<span class="params">num</span>):</span></span><br><span class="line">    cache = [ <span class="number">0</span> <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(num + <span class="number">1</span>)]</span><br><span class="line">    cache[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    cache[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num + <span class="number">1</span>):</span><br><span class="line">        cache[index] = cache[index - <span class="number">1</span>] + cache[index - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> cache[num]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fibo(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>55</p>
<h3 id="실행-코드를-보며-이해해보기-코드분석"><a href="#실행-코드를-보며-이해해보기-코드분석" class="headerlink" title="실행 코드를 보며 이해해보기: 코드분석"></a>실행 코드를 보며 이해해보기: <a target="_blank" rel="noopener" href="http://www.pythontutor.com/live.html#code=def%20fibo_dp%28num%29%3A%0A%20%20%20%20cache%20%3D%20%20%5B%200%20for%20index%20in%20range%28num%20%2B%201%29%20%5D%0A%20%20%20%20cache%5B0%5D%20%3D%200%0A%20%20%20%20cache%5B1%5D%20%3D%201%0A%20%20%20%20%0A%20%20%20%20for%20index%20in%20range%282,%20num%20%2B%201%29%3A%0A%20%20%20%20%20%20%20%20cache%5Bindex%5D%20%3D%20cache%5Bindex%20-%201%5D%20%2B%20cache%5Bindex%20-%202%5D%0A%20%20%20%20return%20cache%5Bnum%5D%0A%0Aprint%28fibo_dp%2810%29%29&cumulative=false&curInstr=41&heapPrimitives=nevernest&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false">코드분석</a></h3><blockquote>
<p>분할 정복 알고리즘의 예는 별도 챕터에서 다루는 병합 정렬과 퀵 정렬을 통해 이해</p>
</blockquote>
<h3 id="Brute-Force-완전탐색"><a href="#Brute-Force-완전탐색" class="headerlink" title="Brute Force(완전탐색)"></a>Brute Force(완전탐색)</h3><p>모든 선택지를 고려하여 최적의 답을 찾아내는 완전탐색과 동적 계획법 알고리즘</p>
<h2 id="퀵-정렬-quick-sort"><a href="#퀵-정렬-quick-sort" class="headerlink" title="퀵 정렬 (quick sort)"></a>퀵 정렬 (quick sort)</h2><h3 id="1-퀵-정렬-quick-sort-이란"><a href="#1-퀵-정렬-quick-sort-이란" class="headerlink" title="1. 퀵 정렬 (quick sort) 이란?"></a>1. 퀵 정렬 (quick sort) 이란?</h3><ul>
<li><font color='#BF360C'>정렬 알고리즘의 꽃</font></li>
<li>기준점(pivot 이라고 부름)을 정해서, 기준점보다 작은 데이터는 왼쪽(left), 큰 데이터는 오른쪽(right) 으로 모으는 함수를 작성함</li>
<li>각 왼쪽(left), 오른쪽(right)은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복함</li>
<li>함수는 왼쪽(left) + 기준점(pivot) + 오른쪽(right) 을 리턴함</li>
</ul>
<p><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC.png" alt="퀵정렬"><br><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC2.png" alt="퀵정렬2"><br><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC3.png" alt="퀵정렬3"><br><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC%EA%B2%B0%EA%B3%BC.png" alt="퀵정렬결과"></p>
<h3 id="2-어떻게-코드로-만들까-1"><a href="#2-어떻게-코드로-만들까-1" class="headerlink" title="2. 어떻게 코드로 만들까?"></a>2. 어떻게 코드로 만들까?</h3><blockquote>
<p>퀵소트 알고리즘에 대해서는 위에서 언급이 되었으므로, 이를 구현하기 위한 세부 코드에 대해 연습을 통해 이해합니다.</p>
</blockquote>
<p><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/%ED%80%B5%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png" alt="퀵정렬알고리즘"></p>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
다음 리스트를 리스트 슬라이싱(예 [:2])을 이용해서 세 개로 짤라서 각 리스트 변수에 넣고 출력해보기<br>
</div>
<pre>
data_list = [1, 2, 3, 4, 5]
출력:
print (data1)
print (data2)
print (data3)
[1, 2]
3
[4, 5]
</pre>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
다음 리스트를 맨 앞에 데이터를 기준으로 작은 데이터는 left 변수에, 그렇지 않은 데이터는 right 변수에 넣기<br>
</div>
<pre>
data_list = [4, 1, 2, 5, 7]
</pre>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
다음 리스트를 맨 앞에 데이터를 pivot 변수에 넣고, pivot 변수 값을 기준으로 작은 데이터는 left 변수에, 그렇지 않은 데이터는 right 변수에 넣기<br>
</div>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
data_list 가 임의 길이일 때 리스트를 맨 앞에 데이터를 기준으로 작은 데이터는 left 변수에, 그렇지 않은 데이터는 right 변수에 넣기<br>
</div>
<pre>
import random 
data_list = random.sample(range(100), 10)

<p>left = list()<br>right = list()<br>pivot = data_list[0]</p>
<p>for index in range(1, —————–):<br>    if data_list[index] &lt; pivot:<br>        left.append(data_list[index])<br>    else:<br>        right.append(data_list[index])<br></pre></p>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
data_list 가 다음 세 데이터를 가지고 있을 때 리스트를 맨 앞에 데이터를 기준으로 작은 데이터는 left 변수에, 그렇지 않은 데이터는 right 변수에 넣고 left, right, pivot 변수 값을 사용해서 정렬된 데이터 출력해보기<br>
</div>
<pre>
data_list = [4, 3, 2]
</pre>

<h3 id="3-알고리즘-구현-2"><a href="#3-알고리즘-구현-2" class="headerlink" title="3. 알고리즘 구현"></a>3. 알고리즘 구현</h3><ul>
<li><p>quicksort 함수 만들기</p>
<ul>
<li>만약 리스트 갯수가 한개이면 해당 리스트 리턴</li>
<li>그렇지 않으면, 리스트 맨 앞의 데이터를 기준점(pivot)으로 놓기</li>
<li>left, right 리스트 변수를 만들고,</li>
<li>맨 앞의 데이터를 뺀 나머지 데이터를 기준점과 비교(pivot)<ul>
<li>기준점보다 작으면 left.append(해당 데이터)</li>
<li>기준점보다 크면 right.append(해당 데이터)</li>
</ul>
</li>
<li>return quicksort(left) + pivot + quicksort(right) 로 재귀 호출</li>
</ul>
<blockquote>
<p>리스트로 만들어서 리턴하기: return quick_sort(left) + [pivot] + quick_sort(right)</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    left, right = <span class="built_in">list</span>(), <span class="built_in">list</span>()</span><br><span class="line">    pivot = data[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> pivot &gt; data[index]:</span><br><span class="line">            left.append(data[index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(data[index])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> qsort(left) + [pivot] + qsort(right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">qsort(data_list)</span><br></pre></td></tr></table></figure>
<p>[2, 20, 35, 39, 49, 51, 57, 74, 82, 94]</p>
<h4 id="list-comprehension으로-구현"><a href="#list-comprehension으로-구현" class="headerlink" title="list comprehension으로 구현"></a>list comprehension으로 구현</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
위 퀵정렬 코드를 파이썬 list comprehension을 사용해서 더 깔끔하게 작성해보기<br>
</div>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    pivot = data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    left = [ item <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="number">1</span>:] <span class="keyword">if</span> pivot &gt; item ]</span><br><span class="line">    right = [ item <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="number">1</span>:] <span class="keyword">if</span> pivot &lt;= item ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> qsort(left) + [pivot] + qsort(right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">qsort(data_list)</span><br></pre></td></tr></table></figure>
<p>[5, 10, 37, 43, 61, 71, 77, 78, 82, 84]</p>
<h3 id="4-알고리즘-분석-2"><a href="#4-알고리즘-분석-2" class="headerlink" title="4. 알고리즘 분석"></a>4. 알고리즘 분석</h3><ul>
<li><font color='#BF360C'>병합정렬과 유사, 시간복잡도는 O(n log n)</font><ul>
<li>단, 최악의 경우 <ul>
<li>맨 처음 pivot이 가장 크거나, 가장 작으면</li>
<li>모든 데이터를 비교하는 상황이 나옴</li>
<li>O($n^2$)<img src="https://www.fun-coding.org/00_Images/quicksortworks.jpg" />






</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="병합-정렬-merge-sort"><a href="#병합-정렬-merge-sort" class="headerlink" title="병합 정렬 (merge sort)"></a>병합 정렬 (merge sort)</h2><p>이거 잘 모르겠음!!!!!!!</p>
<h3 id="1-병합-정렬-개요"><a href="#1-병합-정렬-개요" class="headerlink" title="1. 병합 정렬 개요"></a>1. 병합 정렬 개요</h3><ul>
<li>재귀용법을 활용한 정렬 알고리즘<ol>
<li>리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.</li>
<li>각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.</li>
<li>두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.</li>
</ol>
</li>
</ul>
<h4 id="직접-눈으로-보면-더-이해가-쉽다-https-visualgo-net-en-sorting"><a href="#직접-눈으로-보면-더-이해가-쉽다-https-visualgo-net-en-sorting" class="headerlink" title="직접 눈으로 보면 더 이해가 쉽다: https://visualgo.net/en/sorting"></a>직접 눈으로 보면 더 이해가 쉽다: <a target="_blank" rel="noopener" href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></h4><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" width=500/>

<p>출처: <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC">위키피디아</a></p>
<h3 id="2-알고리즘-이해"><a href="#2-알고리즘-이해" class="headerlink" title="2. 알고리즘 이해"></a>2. 알고리즘 이해</h3><ul>
<li>데이터가 네 개 일때 (데이터 갯수에 따라 복잡도가 떨어지는 것은 아니므로, 네 개로 바로 로직을 이해해보자.)<ul>
<li>예: data_list = [1, 9, 3, 2]<ul>
<li>먼저 [1, 9], [3, 2] 로 나누고</li>
<li>다시 앞 부분은 [1], [9] 로 나누고</li>
<li>다시 정렬해서 합친다. [1, 9]</li>
<li>다음 [3, 2] 는 [3], [2] 로 나누고</li>
<li>다시 정렬해서 합친다 [2, 3]</li>
<li>이제 [1, 9] 와 [2, 3]을 합친다.<ul>
<li>1 &lt; 2 이니 [1]</li>
<li>9 &gt; 2 이니 [1, 2]</li>
<li>9 &gt; 3 이니 [1, 2, 3]</li>
<li>9 밖에 없으니, [1, 2, 3, 9]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-알고리즘-구현-3"><a href="#3-알고리즘-구현-3" class="headerlink" title="3. 알고리즘 구현"></a>3. 알고리즘 구현</h3><ul>
<li><p>mergesplit 함수 만들기</p>
<ul>
<li>만약 리스트 갯수가 한개이면 해당 값 리턴</li>
<li>그렇지 않으면, 리스트를 앞뒤, 두 개로 나누기</li>
<li>left = mergesplit(앞)</li>
<li>right = mergesplit(뒤)</li>
<li>merge(left, right)</li>
</ul>
</li>
<li><p>merge 함수 만들기</p>
<ul>
<li>리스트 변수 하나 만들기 (sorted)</li>
<li>left_index, right_index = 0</li>
<li>while left_index &lt; len(left) or right_index &lt; len(right):<ul>
<li>만약 left_index 나 right_index 가 이미 left 또는 right 리스트를 다 순회했다면, 그 반대쪽 데이터를 그대로 넣고, 해당 인덱스 1 증가</li>
<li>if left[left_index] &lt; right[right_index]:<ul>
<li>sorted.append(left[left_index])</li>
<li>left_index += 1</li>
</ul>
</li>
<li>else:<ul>
<li>sorted.append(right[right_index])</li>
<li>right_index += 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="작은-부분부터-작성해서-하나씩-구현하기"><a href="#작은-부분부터-작성해서-하나씩-구현하기" class="headerlink" title="작은 부분부터 작성해서 하나씩 구현하기"></a>작은 부분부터 작성해서 하나씩 구현하기</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
어떤 데이터리스트가 있을 때 리스트를 앞뒤로 짜르는 코드 작성해보기 (일반화)
</div>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_func</span>(<span class="params">data</span>):</span></span><br><span class="line">    medium = <span class="built_in">int</span>(<span class="built_in">len</span>(data) / <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span> (medium)</span><br><span class="line">    left = data[:medium]</span><br><span class="line">    right = data[medium:]</span><br><span class="line">    <span class="built_in">print</span> (left, right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">split_func([<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2<br>[3, 4] [1, 5, 2]</p>
<h4 id="재귀용법-활용하기"><a href="#재귀용법-활용하기" class="headerlink" title="재귀용법 활용하기"></a>재귀용법 활용하기</h4><div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
</div>
<pre>
다음 문장을 코드로 작성해보기 (merge함수는 아직은 없는 상태, 있다고만 가정)
* mergesplit 함수 만들기
  - 만약 리스트 갯수가 한개이면 해당 값 리턴
  - 그렇지 않으면, 리스트를 앞뒤, 두 개로 나누기
  - left = mergesplit(앞)
  - right = mergesplit(뒤)
  - merge(left, right)
</pre>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesplit</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    medium = <span class="built_in">int</span>(<span class="built_in">len</span>(data) / <span class="number">2</span>)</span><br><span class="line">    left = mergesplit(data[:medium])</span><br><span class="line">    right = mergesplit(data[medium:])</span><br><span class="line">    <span class="keyword">return</span> left, right <span class="comment">#merge(left, right)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left, right = mergesplit([<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">52</span>,<span class="number">35</span>,<span class="number">64</span>,<span class="number">23</span>])</span><br><span class="line"><span class="built_in">len</span>(left), <span class="built_in">len</span>(right)</span><br></pre></td></tr></table></figure>
<p>(2, 2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left</span><br></pre></td></tr></table></figure>
<p>(([3], ([4], [1])), (([5], [2]), ([8], [6])))<br>[24]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">right</span><br></pre></td></tr></table></figure>
<p>((([7], [0]), ([9], [11])), (([52], [35]), ([64], [23])))</p>
<h4 id="merge-함수-만들기"><a href="#merge-함수-만들기" class="headerlink" title="merge 함수 만들기"></a>merge 함수 만들기</h4><ul>
<li>목표: left 와 right 의 리스트 데이터를 정렬해서 sorted_list 라는 이름으로 return 하기</li>
<li>left와 right는 이미 정렬된 상태 또는 데이터가 하나임</li>
</ul>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
</div>

<ol>
<li>left 부터 하나씩 right과 비교</li>
<li>left &gt; right 이면, left 를 sorted_list에 넣고, 다음 left 리스트와 right 비교<ul>
<li>그렇지않으면 반대로 하기<pre>
다음 경우만 프로그래밍으로 작성해보기
left = [0]
right = [3]
결과는 별도의 리스트 변수를 만들어 적은 숫자 순으로 순서대로 저장해서 리턴
</pre>

</li>
</ul>
</li>
</ol>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
</div>
<pre>
다음 경우만 프로그래밍으로 작성해보기
left = [0, 2]
right = [1]
결과는 별도의 리스트 변수를 만들어 적은 숫자 순으로 순서대로 저장해서 리턴
</pre>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
</div>
<pre>
다음 경우만 프로그래밍으로 작성해보기
left = [0, 2]
right = [1, 3]
결과는 별도의 리스트 변수를 만들어 적은 숫자 순으로 순서대로 저장해서 리턴
</pre>

<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
left, right 리스트 변수의 데이터 수가 한 개에서 여러 개가 될 수 있을때 작성해보기(일반화)
</div>
<pre>
1. sorted_list 리스트 변수 선언하기
2. left_index, right_index 를 0 으로 초기화 하기
3. while left_index < len(left) or right_index < len(right) 이면,
   - 만약 left_index >= len(left)이면, sorted_list 에 right[right_index] 를 추가하고, right_index 값을 1증가
   - 만약 right_index >= len(right)이면, sorted_list 에 left[left_index] 를 추가하고, left_index 값을 1증가
   - 만약 left[left_index] < right[right_index]이면, sorted_list 에 left[left_index] 를 추가하고, left_index 값을 1증가
   - 위 세가지가 아니면, sorted_list 에 right[right_index] 를 추가하고, right_index 값을 1증가
</pre>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    merged = <span class="built_in">list</span>()</span><br><span class="line">    left_point, right_point = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># case1 - left/right 둘다 있을때</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(left) &gt; left_point <span class="keyword">and</span> <span class="built_in">len</span>(right) &gt; right_point:</span><br><span class="line">        <span class="keyword">if</span> left[left_point] &gt; right[right_point]:</span><br><span class="line">            merged.append(right[right_point])</span><br><span class="line">            right_point += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(left[left_point])</span><br><span class="line">            left_point += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># case2 - left 데이터가 없을 때</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(left) &gt; left_point:</span><br><span class="line">        merged.append(left[left_point])</span><br><span class="line">        left_point += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># case3 - right 데이터가 없을 때</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(right) &gt; right_point:</span><br><span class="line">        merged.append(right[right_point])</span><br><span class="line">        right_point += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<h4 id="최종-코드"><a href="#최종-코드" class="headerlink" title="최종 코드"></a>최종 코드</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    merged = <span class="built_in">list</span>()</span><br><span class="line">    left_point, right_point = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># case1 - left/right 둘다 있을때</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(left) &gt; left_point <span class="keyword">and</span> <span class="built_in">len</span>(right) &gt; right_point:</span><br><span class="line">        <span class="keyword">if</span> left[left_point] &gt; right[right_point]:</span><br><span class="line">            merged.append(right[right_point])</span><br><span class="line">            right_point += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged.append(left[left_point])</span><br><span class="line">            left_point += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># case2 - left 데이터가 없을 때</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(left) &gt; left_point:</span><br><span class="line">        merged.append(left[left_point])</span><br><span class="line">        left_point += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># case3 - right 데이터가 없을 때</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(right) &gt; right_point:</span><br><span class="line">        merged.append(right[right_point])</span><br><span class="line">        right_point += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesplit</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    medium = <span class="built_in">int</span>(<span class="built_in">len</span>(data) / <span class="number">2</span>)</span><br><span class="line">    left = mergesplit(data[:medium])</span><br><span class="line">    right = mergesplit(data[medium:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line">mergesplit(data_list)</span><br></pre></td></tr></table></figure>
<p>[8, 12, 24, 40, 47, 70, 81, 87, 92, 96]</p>
<h3 id="4-알고리즘-분석-3"><a href="#4-알고리즘-분석-3" class="headerlink" title="4. 알고리즘 분석"></a>4. 알고리즘 분석</h3><ul>
<li>알고리즘 분석은 쉽지 않음, <font color='#BF360C'>이 부분은 참고로만 알아두자.</font><ul>
<li>다음을 보고 이해해보자<ul>
<li>몇 단계 깊이까지 만들어지는지를 depth 라고 하고 i로 놓자. 맨 위 단계는 0으로 놓자.<ul>
<li>다음 그림에서 n/$2^2$ 는 2단계 깊이라고 해보자.</li>
<li>각 단계에 있는 하나의 노드 안의 리스트 길이는 n/$2^2$ 가 된다.</li>
<li>각 단계에는 $2^i$ 개의 노드가 있다.</li>
</ul>
</li>
<li>따라서, 각 단계는 항상 <font size=4em>$2^i * \frac { n }{ 2^i } = O(n)$</font></li>
<li>단계는 항상 $log_2 n$ 개 만큼 만들어짐, 시간 복잡도는 결국 O(log n), 2는 역시 상수이므로 삭제</li>
<li>따라서, 단계별 시간 복잡도 O(n) * O(log n) = O(n log n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/mergesortcomplexity.png" />


<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
지금 설명한 병합 정렬을 지금 다시 스스로 작성해보세요<br>
</div>



<h2 id="순차-탐색-Sequential-Search"><a href="#순차-탐색-Sequential-Search" class="headerlink" title="순차 탐색 (Sequential Search)"></a>순차 탐색 (Sequential Search)</h2><h3 id="1-순차-탐색-Sequential-Search-이란"><a href="#1-순차-탐색-Sequential-Search-이란" class="headerlink" title="1. 순차 탐색 (Sequential Search) 이란?"></a>1. 순차 탐색 (Sequential Search) 이란?</h3><ul>
<li>탐색은 여러 데이터 중에서 원하는 데이터를 찾아내는 것을 의미</li>
<li>데이터가 담겨있는 리스트를 앞에서부터 하나씩 비교해서 원하는 데이터를 찾는 방법</li>
</ul>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
임의 리스트가 다음과 같이 rand_data_list로 있을 때, 원하는 데이터의 위치를 리턴하는 순차탐색 알고리즘 작성해보기<br>
- 가장 기본적인 방법이므로, 직접 작성해보겠습니다.
- 원하는 데이터가 리스트에 없을 경우 -1을 리턴
</div>
<pre>
## 데이터 준비: data_list 10개 만들기
from random import *
 
rand_data_list = list()
for num in range(10):
    rand_data_list.append(randint(1, 100))
</pre>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">rand_data_list = <span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    rand_data_list.append(randint(<span class="number">1</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand_data_list</span><br></pre></td></tr></table></figure>
<p>[71, 63, 75, 33, 6, 37, 81, 79, 3, 29]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequencial</span>(<span class="params">data_list, search_data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data_list)):</span><br><span class="line">        <span class="keyword">if</span> data_list[index] == search_data:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequencial(rand_data_list, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>-1</p>
<h3 id="2-알고리즘-분석"><a href="#2-알고리즘-분석" class="headerlink" title="2. 알고리즘 분석"></a>2. 알고리즘 분석</h3><ul>
<li>최악의 경우 리스트 길이가 n일 때, n번 비교해야 함<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
<h2 id="이진-탐색-Binary-Search"><a href="#이진-탐색-Binary-Search" class="headerlink" title="이진 탐색 (Binary Search)"></a>이진 탐색 (Binary Search)</h2><h3 id="1-이진-탐색-Binary-Search-이란"><a href="#1-이진-탐색-Binary-Search-이란" class="headerlink" title="1. 이진 탐색 (Binary Search) 이란?"></a>1. 이진 탐색 (Binary Search) 이란?</h3><ul>
<li>탐색할 자료를 둘로 나누어 해당 데이터가 있을만한 곳을 탐색하는 방법</li>
</ul>
<h4 id="다음-문제를-먼저-생각해보자"><a href="#다음-문제를-먼저-생각해보자" class="headerlink" title="다음 문제를 먼저 생각해보자"></a>다음 문제를 먼저 생각해보자</h4><img src="https://www.fun-coding.org/00_Images/binarysearch.png" />

<h4 id="이진-탐색의-이해-순차-탐색과-비교하며-이해하기"><a href="#이진-탐색의-이해-순차-탐색과-비교하며-이해하기" class="headerlink" title="이진 탐색의 이해 (순차 탐색과 비교하며 이해하기)"></a>이진 탐색의 이해 (순차 탐색과 비교하며 이해하기)</h4><img src="https://www.mathwarehouse.com/programming/images/binary-vs-linear-search/binary-and-linear-search-animations.gif">

<ul>
<li>[저작자] by penjee.com <a target="_blank" rel="noopener" href="https://blog.penjee.com/binary-vs-linear-search-animated-gifs">이미지 출처</a></li>
</ul>
<h3 id="2-분할-정복-알고리즘과-이진-탐색"><a href="#2-분할-정복-알고리즘과-이진-탐색" class="headerlink" title="2. 분할 정복 알고리즘과 이진 탐색"></a>2. 분할 정복 알고리즘과 이진 탐색</h3><ul>
<li>분할 정복 알고리즘 (Divide and Conquer)<ul>
<li>Divide: 문제를 하나 또는 둘 이상으로 나눈다.</li>
<li>Conquer: 나눠진 문제가 충분히 작고, 해결이 가능하다면 해결하고, 그렇지 않다면 다시 나눈다.</li>
</ul>
</li>
<li>이진 탐색<ul>
<li>Divide: 리스트를 두 개의 서브 리스트로 나눈다.</li>
<li>Comquer<ul>
<li>검색할 숫자 (search) &gt; 중간값 이면, 뒷 부분의 서브 리스트에서 검색할 숫자를 찾는다.</li>
<li>검색할 숫자 (search) &lt; 중간값 이면, 앞 부분의 서브 리스트에서 검색할 숫자를 찾는다.  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-어떻게-코드로-만들까-1"><a href="#3-어떻게-코드로-만들까-1" class="headerlink" title="3. 어떻게 코드로 만들까?"></a>3. 어떻게 코드로 만들까?</h3><ul>
<li>이진 탐색은 데이터가 정렬되있는 상태에서 진행</li>
<li>데이터가 [2, 3, 8, 12, 20] 일 때,<ul>
<li>binary_search(data_list, find_data) 함수를 만들고<ul>
<li>find_data는 찾는 숫자</li>
<li>data_list는 데이터 리스트</li>
<li>data_list의 중간값을 find_data와 비교해서<ul>
<li>find_data &lt; data_list의 중간값 이라면<ul>
<li>맨 앞부터 data_list의 중간까지 에서 다시 find_data 찾기</li>
</ul>
</li>
<li>data_list의 중간값 &lt; find_data 이라면<ul>
<li>data_list의 중간부터 맨 끝까지에서 다시 find_data 찾기</li>
</ul>
</li>
<li>그렇지 않다면, data_list의 중간값은 find_data 인 경우로, return data_list 중간위치</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-알고리즘-구현-1"><a href="#4-알고리즘-구현-1" class="headerlink" title="4. 알고리즘 구현"></a>4. 알고리즘 구현</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">data, search</span>):</span></span><br><span class="line">    <span class="built_in">print</span> (data)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">1</span> <span class="keyword">and</span> search == data[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">1</span> <span class="keyword">and</span> search != data[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    medium = <span class="built_in">len</span>(data) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> search == data[medium]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> search &gt; data[medium]:</span><br><span class="line">            <span class="keyword">return</span> binary_search(data[medium+<span class="number">1</span>:], search)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(data[:medium], search)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), <span class="number">10</span>)</span><br><span class="line">data_list</span><br></pre></td></tr></table></figure>



<pre><code>[69, 65, 18, 71, 11, 10, 42, 68, 36, 89]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_list.sort()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_list</span><br></pre></td></tr></table></figure>



<pre><code>[10, 11, 18, 36, 42, 65, 68, 69, 71, 89]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_search(data_list, <span class="number">66</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[10, 11, 18, 36, 42, 65, 68, 69, 71, 89]
[68, 69, 71, 89]
[68, 69]
[68]





False
</code></pre>
<h3 id="5-알고리즘-분석-1"><a href="#5-알고리즘-분석-1" class="headerlink" title="5. 알고리즘 분석"></a>5. 알고리즘 분석</h3><ul>
<li>n개의 리스트를 매번 2로 나누어 1이 될 때까지 비교연산을 k회 진행<ul>
<li><font size=4em>n X $\frac { 1 }{ 2 }$ X $\frac { 1 }{ 2 }$ X $\frac { 1 }{ 2 }$ … = 1</font></li>
<li><font size=4em>n X $\frac { 1 }{ 2 }^k$ = 1</font></li>
<li><font size=4em>n = $2^k$ = $log_2 n$ = $log_2 2^k$</font></li>
<li><font size=4em>$log_2 n$ = k</font></li>
<li>빅 오 표기법으로는 k + 1 이 결국 최종 시간 복잡도임 (1이 되었을 때도, 비교연산을 한번 수행)<ul>
<li>결국 O($log_2 n$ + 1) 이고, 2와 1, 상수는 삭제 되므로, O($log n$)</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="alert alert-block alert-warning">
<strong><font color="blue" size="4em">프로그래밍 연습</font></strong><br>
다음 10000개의 데이터를 삽입 정렬, 퀵 정렬로 정렬하는 함수를 각각 만들어보고, 각각의 정렬 시간을 출력하기<br>
</div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 데이터 셋</span></span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line">data_list = random.sample(<span class="built_in">range</span>(<span class="number">100000</span>), <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 현재 시간 구하기</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="built_in">print</span> (datetime.datetime.now())</span><br></pre></td></tr></table></figure>


<!-- ## <<<중간에 빠짐>>>
[이진 트리 탐색 (Binary Tree Search)](https://www.fun-coding.org/Chapter10-bst.html)
[중첩 함수 (Nested function)](https://www.fun-coding.org/PL&OOP4-1.html)
[First-class function](https://www.fun-coding.org/PL&OOP4-2.html)
[Closure function](https://www.fun-coding.org/PL&OOP4-3.html)
[데코레이터 (Decorator)](https://www.fun-coding.org/PL&OOP4-4.html)
[이터레이터 (iterator)](https://www.fun-coding.org/PL&OOP5-1.html)
[파이썬 Comprehension](https://www.fun-coding.org/PL&OOP5-2.html)
[파이썬 제너레이터 (Generator)](https://www.fun-coding.org/PL&OOP5-3.html) -->


<h2 id="그래프-이해"><a href="#그래프-이해" class="headerlink" title="그래프 이해"></a>그래프 이해</h2><h3 id="1-그래프-Graph-란"><a href="#1-그래프-Graph-란" class="headerlink" title="1. 그래프 (Graph) 란?"></a>1. 그래프 (Graph) 란?</h3><ul>
<li>그래프는 실제 세계의 현상이나 사물을 정점(Vertex) 또는 노드(Node) 와 간선(Edge)로 표현하기 위해 사용<h4 id="예제-집에서-회사로-가는-경로를-그래프로-표현한-예"><a href="#예제-집에서-회사로-가는-경로를-그래프로-표현한-예" class="headerlink" title="예제 집에서 회사로 가는 경로를 그래프로 표현한 예"></a>예제 집에서 회사로 가는 경로를 그래프로 표현한 예</h4><img src="https://www.fun-coding.org/00_Images/graph.png" width=400>

</li>
</ul>
<h3 id="2-그래프-Graph-관련-용어"><a href="#2-그래프-Graph-관련-용어" class="headerlink" title="2. 그래프 (Graph) 관련 용어"></a>2. 그래프 (Graph) 관련 용어</h3><ul>
<li><p>노드 (Node): 위치를 말함, 정점(Vertex)라고도 함</p>
</li>
<li><p>간선 (Edge): 위치 간의 관계를 표시한 선으로 노드를 연결한 선이라고 보면 됨 (link 또는 branch 라고도 함)</p>
</li>
<li><p>인접 정점 (Adjacent Vertex) : 간선으로 직접 연결된 정점(또는 노드)</p>
</li>
<li><p>참고 용어</p>
<ul>
<li>정점의 차수 (Degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수</li>
<li>진입 차수 (In-Degree): 방향 그래프에서 외부에서 오는 간선의 수</li>
<li>진출 차수 (Out-Degree): 방향 그래프에서 외부로 향하는 간선의 수</li>
<li>경로 길이 (Path Length): 경로를 구성하기 위해 사용된 간선의 수</li>
<li>단순 경로 (Simple Path): 중복된 정점이 없는 경로 (처음과 끝 정점이 동일한 경우 제외)</li>
<li>사이클 (Cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우</li>
</ul>
<blockquote>
<p>단순 경로 (A - B - C)</p>
<img src="https://www.fun-coding.org/00_Images/simplepath.png" width=200>
</blockquote>
</li>
</ul>
<h3 id="3-그래프-Graph-종류"><a href="#3-그래프-Graph-종류" class="headerlink" title="3. 그래프 (Graph) 종류"></a>3. 그래프 (Graph) 종류</h3><h4 id="무방향-그래프-Undirected-Graph"><a href="#무방향-그래프-Undirected-Graph" class="headerlink" title="무방향 그래프 (Undirected Graph)"></a>무방향 그래프 (Undirected Graph)</h4><ul>
<li>방향이 없는 그래프</li>
<li>간선을 통해, 노드는 양방향으로 갈 수 있음</li>
<li>보통 노드 A, B가 연결되어 있을 경우, (A, B) 또는 (B, A) 로 표기<img src="https://www.fun-coding.org/00_Images/undirectedgraph.png" width=300>

</li>
</ul>
<h4 id="방향-그래프-Directed-Graph"><a href="#방향-그래프-Directed-Graph" class="headerlink" title="방향 그래프 (Directed Graph)"></a>방향 그래프 (Directed Graph)</h4><ul>
<li>간선에 방향이 있는 그래프</li>
<li>보통 노드 A, B가 A -&gt; B 로 가는 간선으로 연결되어 있을 경우, &lt;A, B&gt; 로 표기 (&lt;B, A&gt; 는 B -&gt; A 로 가는 간선이 있는 경우이므로 &lt;A, B&gt; 와 다름)<img src="https://www.fun-coding.org/00_Images/directedgraph.png" width=300>

</li>
</ul>
<h4 id="가중치-그래프-Weighted-Graph-또는-네트워크-Network"><a href="#가중치-그래프-Weighted-Graph-또는-네트워크-Network" class="headerlink" title="가중치 그래프 (Weighted Graph) 또는 네트워크 (Network)"></a>가중치 그래프 (Weighted Graph) 또는 네트워크 (Network)</h4><ul>
<li>간선에 비용 또는 가중치가 할당된 그래프</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/weightedgraph.png" width=300>

<h4 id="연결-그래프-Connected-Graph-와-비연결-그래프-Disconnected-Graph"><a href="#연결-그래프-Connected-Graph-와-비연결-그래프-Disconnected-Graph" class="headerlink" title="연결 그래프 (Connected Graph) 와 비연결 그래프 (Disconnected Graph)"></a>연결 그래프 (Connected Graph) 와 비연결 그래프 (Disconnected Graph)</h4><ul>
<li><p>연결 그래프 (Connected Graph)</p>
<ul>
<li>무방향 그래프에 있는 모든 노드에 대해 항상 경로가 존재하는 경우</li>
</ul>
</li>
<li><p>비연결 그래프 (Disconnected Graph)</p>
<ul>
<li>무방향 그래프에서 특정 노드에 대해 경로가 존재하지 않는 경우</li>
</ul>
<blockquote>
<p>비연결 그래프 예</p>
<img src="https://www.fun-coding.org/00_Images/disconnectedgraph.png" width=300>
</blockquote>
</li>
</ul>
<h4 id="사이클-Cycle-과-비순환-그래프-Acyclic-Graph"><a href="#사이클-Cycle-과-비순환-그래프-Acyclic-Graph" class="headerlink" title="사이클 (Cycle) 과 비순환 그래프 (Acyclic Graph)"></a>사이클 (Cycle) 과 비순환 그래프 (Acyclic Graph)</h4><ul>
<li><p>사이클 (Cycle)</p>
<ul>
<li>단순 경로의 시작 노드와 종료 노드가 동일한 경우</li>
</ul>
</li>
<li><p>비순환 그래프 (Acyclic Graph)</p>
<ul>
<li>사이클이 없는 그래프</li>
</ul>
<blockquote>
<p>비순환 그래프 예</p>
<img src="https://www.fun-coding.org/00_Images/acyclicgraph.png" width=300>
</blockquote>
</li>
</ul>
<h4 id="완전-그래프-Complete-Graph"><a href="#완전-그래프-Complete-Graph" class="headerlink" title="완전 그래프 (Complete Graph)"></a>완전 그래프 (Complete Graph)</h4><ul>
<li>그래프의 모든 노드가 서로 연결되어 있는 그래프</li>
</ul>
<blockquote>
<p>완전 그래프 예<br><img src="https://www.fun-coding.org/00_Images/completegraph.png" width=300></p>
</blockquote>
<h3 id="3-그래프와-트리의-차이"><a href="#3-그래프와-트리의-차이" class="headerlink" title="3. 그래프와 트리의 차이"></a>3. 그래프와 트리의 차이</h3><ul>
<li>트리는 그래프 중에 속한 특별한 종류라고 볼 수 있음</li>
</ul>
<div style="text-align:left">
<table>
  <tr>
    <th></th>
    <th style="text-align:center">그래프</th>
    <th style="text-align:center">트리</th>
  </tr>
  <tr>
    <td style="text-align:center">정의</td>
    <td style="text-align:left">노드와 노드를 연결하는 간선으로 표현되는 자료 구조</td>
    <td style="text-align:left">그래프의 한 종류, 방향성이 있는 비순환 그래프</td>
  </tr>
  <tr>
    <td style="text-align:center">방향성</td>
    <td style="text-align:left">방향 그래프, 무방향 그래프 둘다 존재함</td>
    <td style="text-align:left">방향 그래프만 존재함</td>
  </tr>
  <tr>
    <td style="text-align:center">사이클</td>
    <td style="text-align:left">사이클 가능함, 순환 및 비순환 그래프 모두 존재함</td>
    <td style="text-align:left">비순환 그래프로 사이클이 존재하지 않음</td>
  </tr>
  <tr>
    <td style="text-align:center">루트 노드</td>
    <td style="text-align:left">루트 노드 존재하지 않음</td>
    <td style="text-align:left">루트 노드 존재함</td>
  </tr>
  <tr>
    <td style="text-align:center">부모/자식 관계</td>
    <td style="text-align:left">부모 자식 개념이 존재하지 않음</td>
    <td style="text-align:left">부모 자식 관계가 존재함</td>
  </tr>
</table>
</div>



<h2 id="너비-우선-탐색-Breadth-First-Search"><a href="#너비-우선-탐색-Breadth-First-Search" class="headerlink" title="너비 우선 탐색 (Breadth-First Search)"></a>너비 우선 탐색 (Breadth-First Search)</h2><h3 id="1-BFS-와-DFS-란"><a href="#1-BFS-와-DFS-란" class="headerlink" title="1. BFS 와 DFS 란?"></a>1. BFS 와 DFS 란?</h3><ul>
<li>대표적인 그래프 <strong>탐색</strong> 알고리즘<ul>
<li>너비 우선 탐색 (Breadth First Search): 정점들과 같은 레벨에 있는 노드들 (형제 노드들)을 먼저 탐색하는 방식</li>
<li>깊이 우선 탐색 (Depth First Search): 정점의 자식들을 먼저 탐색하는 방식</li>
</ul>
</li>
</ul>
<h4 id="BFS-DFS-방식-이해를-위한-예제"><a href="#BFS-DFS-방식-이해를-위한-예제" class="headerlink" title="BFS/DFS 방식 이해를 위한 예제"></a>BFS/DFS 방식 이해를 위한 예제</h4><ul>
<li>BFS 방식: A - B - C - D - G - H - I - E - F - J <ul>
<li>한 단계씩 내려가면서, 해당 노드와 같은 레벨에 있는 노드들 (형제 노드들)을 먼저 순회함</li>
</ul>
</li>
<li>DFS 방식: A - B - D - E - F - C - G - H - I - J <ul>
<li>한 노드의 자식을 타고 끝까지 순회한 후, 다시 돌아와서 다른 형제들의 자식을 타고 내려가며 순화함</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/BFSDFS.png" width=700>

<h3 id="2-파이썬으로-그래프를-표현하는-방법"><a href="#2-파이썬으로-그래프를-표현하는-방법" class="headerlink" title="2. 파이썬으로 그래프를 표현하는 방법"></a>2. 파이썬으로 그래프를 표현하는 방법</h3><ul>
<li>파이썬에서 제공하는 딕셔너리와 리스트 자료 구조를 활용해서 그래프를 표현할 수 있음</li>
</ul>
<h4 id="그래프-예와-파이썬-표현"><a href="#그래프-예와-파이썬-표현" class="headerlink" title="그래프 예와 파이썬 표현"></a>그래프 예와 파이썬 표현</h4><img src="https://www.fun-coding.org/00_Images/bfsgraph.png" width=700>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">graph[<span class="string">&#x27;A&#x27;</span>] = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;B&#x27;</span>] = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;C&#x27;</span>] = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;D&#x27;</span>] = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;E&#x27;</span>] = [<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;F&#x27;</span>] = [<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;G&#x27;</span>] = [<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;H&#x27;</span>] = [<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;I&#x27;</span>] = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;J&#x27;</span>] = [<span class="string">&#x27;I&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br></pre></td></tr></table></figure>



<pre><code>&#123;&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;],
 &#39;B&#39;: [&#39;A&#39;, &#39;D&#39;],
 &#39;C&#39;: [&#39;A&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;],
 &#39;D&#39;: [&#39;B&#39;, &#39;E&#39;, &#39;F&#39;],
 &#39;E&#39;: [&#39;D&#39;],
 &#39;F&#39;: [&#39;D&#39;],
 &#39;G&#39;: [&#39;C&#39;],
 &#39;H&#39;: [&#39;C&#39;],
 &#39;I&#39;: [&#39;C&#39;, &#39;J&#39;],
 &#39;J&#39;: [&#39;I&#39;]&#125;
</code></pre>
<h3 id="3-BFS-알고리즘-구현"><a href="#3-BFS-알고리즘-구현" class="headerlink" title="3. BFS 알고리즘 구현"></a>3. BFS 알고리즘 구현</h3><ul>
<li>자료구조 큐를 활용함<ul>
<li>need_visit 큐와 visited 큐, 두 개의 큐를 생성</li>
</ul>
</li>
</ul>
<h4 id="그래프-큐-사용"><a href="#그래프-큐-사용" class="headerlink" title="그래프 큐 사용"></a>그래프 큐 사용</h4><p><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/BFSQueue.png" alt="BFSQueue"><br><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/BFSQueue2.png" alt="BFSQueue2"></p>
<!-- <img src="https://www.fun-coding.org/00_Images/bfsqueue.png" width=700> -->

<ul>
<li>큐의 구현은 간단히 파이썬 리스트를 활용</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">data.extend([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>



<pre><code>[1, 2, 3, 4, 5]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">graph, start_node</span>):</span></span><br><span class="line">    visited = <span class="built_in">list</span>()</span><br><span class="line">    need_visit = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    need_visit.append(start_node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> need_visit:</span><br><span class="line">        node = need_visit.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.append(node)</span><br><span class="line">            need_visit.extend(graph[node])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfs(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>



<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;E&#39;, &#39;F&#39;, &#39;J&#39;]
</code></pre>
<p><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/graph_dict.png" alt="graph_dict"></p>
<!-- <img src="https://www.fun-coding.org/00_Images/bfsgraph.png" width=700> -->

<h3 id="4-시간-복잡도"><a href="#4-시간-복잡도" class="headerlink" title="4. 시간 복잡도"></a>4. 시간 복잡도</h3><ul>
<li>일반적인 BFS 시간 복잡도<ul>
<li>노드 수: V</li>
<li>간선 수: E<ul>
<li>위 코드에서 while need_visit 은 V + E 번 만큼 수행함</li>
</ul>
</li>
<li>시간 복잡도: O(V + E)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">graph, start_node</span>):</span></span><br><span class="line">    visited = <span class="built_in">list</span>()</span><br><span class="line">    need_visit = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    need_visit.append(start_node)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> need_visit:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        node = need_visit.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.append(node)</span><br><span class="line">            need_visit.extend(graph[node])</span><br><span class="line">    <span class="built_in">print</span> (count)</span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfs(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>19





[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;E&#39;, &#39;F&#39;, &#39;J&#39;]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="깊이-우선-탐색-Depth-First-Search"><a href="#깊이-우선-탐색-Depth-First-Search" class="headerlink" title="깊이 우선 탐색 (Depth-First Search)"></a>깊이 우선 탐색 (Depth-First Search)</h2><h3 id="1-BFS-와-DFS-란-1"><a href="#1-BFS-와-DFS-란-1" class="headerlink" title="1. BFS 와 DFS 란?"></a>1. BFS 와 DFS 란?</h3><ul>
<li>대표적인 그래프 <strong>탐색</strong> 알고리즘<ul>
<li><strong>너비</strong> 우선 탐색 (<strong>Breadth</strong> First Search): 정점들과 같은 레벨에 있는 노드들 (형제 노드들)을 먼저 탐색하는 방식</li>
<li><strong>깊이</strong> 우선 탐색 (<strong>Depth</strong> First Search): 정점의 자식들을 먼저 탐색하는 방식</li>
</ul>
</li>
</ul>
<h4 id="BFS-DFS-방식-이해를-위한-예제-1"><a href="#BFS-DFS-방식-이해를-위한-예제-1" class="headerlink" title="BFS/DFS 방식 이해를 위한 예제"></a>BFS/DFS 방식 이해를 위한 예제</h4><ul>
<li>BFS 방식: A - B - C - D - G - H - I - E - F - J <ul>
<li>한 단계씩 내려가면서, 해당 노드와 같은 레벨에 있는 노드들 (형제 노드들)을 먼저 순회함</li>
</ul>
</li>
<li>DFS 방식: A - B - D - E - F - C - G - H - I - J <ul>
<li>한 노드의 자식을 타고 끝까지 순회한 후, 다시 돌아와서 다른 형제들의 자식을 타고 내려가며 순화함</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/BFSDFS.png" width=700>

<h3 id="2-파이썬으로-그래프를-표현하는-방법-1"><a href="#2-파이썬으로-그래프를-표현하는-방법-1" class="headerlink" title="2. 파이썬으로 그래프를 표현하는 방법"></a>2. 파이썬으로 그래프를 표현하는 방법</h3><ul>
<li>파이썬에서 제공하는 딕셔너리와 리스트 자료 구조를 활용해서 그래프를 표현할 수 있음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">graph[<span class="string">&#x27;A&#x27;</span>] = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;B&#x27;</span>] = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;C&#x27;</span>] = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;D&#x27;</span>] = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;E&#x27;</span>] = [<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;F&#x27;</span>] = [<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;G&#x27;</span>] = [<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;H&#x27;</span>] = [<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;I&#x27;</span>] = [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;J&#x27;</span>]</span><br><span class="line">graph[<span class="string">&#x27;J&#x27;</span>] = [<span class="string">&#x27;I&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graph</span><br></pre></td></tr></table></figure>



<pre><code>&#123;&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;],
 &#39;B&#39;: [&#39;A&#39;, &#39;D&#39;],
 &#39;C&#39;: [&#39;A&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;],
 &#39;D&#39;: [&#39;B&#39;, &#39;E&#39;, &#39;F&#39;],
 &#39;E&#39;: [&#39;D&#39;],
 &#39;F&#39;: [&#39;D&#39;],
 &#39;G&#39;: [&#39;C&#39;],
 &#39;H&#39;: [&#39;C&#39;],
 &#39;I&#39;: [&#39;C&#39;, &#39;J&#39;],
 &#39;J&#39;: [&#39;I&#39;]&#125;
</code></pre>
<img src="https://www.fun-coding.org/00_Images/dfsgraph.png" width=700>

<p>오른쪽이든 왼쪽이든 아래로 탐색하면 됨<br><img src="/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_files/DFSQueStack.png" alt="DFSQueStack"></p>
<h3 id="3-DFS-알고리즘-구현"><a href="#3-DFS-알고리즘-구현" class="headerlink" title="3. DFS 알고리즘 구현"></a>3. DFS 알고리즘 구현</h3><ul>
<li>자료구조 스택과 큐를 활용함<ul>
<li>need_visit 스택과 visited 큐, 두 개의 자료 구조를 생성</li>
</ul>
</li>
</ul>
<blockquote>
<p>BFS 자료구조는 두 개의 큐를 활용하는데 반해, DFS 는 스택과 큐를 활용한다는 차이가 있음을 인지해야 함</p>
</blockquote>
<ul>
<li>큐와 스택 구현은 별도 라이브러리를 활용할 수도 있지만, 간단히 파이썬 리스트를 활용할 수도 있음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">graph, start_node</span>):</span></span><br><span class="line">    visited, need_visit = <span class="built_in">list</span>(), <span class="built_in">list</span>()</span><br><span class="line">    need_visit.append(start_node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> need_visit:</span><br><span class="line">        node = need_visit.pop()</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.append(node)</span><br><span class="line">            need_visit.extend(graph[node])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(graph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>



<pre><code>[&#39;A&#39;, &#39;C&#39;, &#39;I&#39;, &#39;J&#39;, &#39;H&#39;, &#39;G&#39;, &#39;B&#39;, &#39;D&#39;, &#39;F&#39;, &#39;E&#39;]
</code></pre>
<img src="00_Images/dfsgraph.png" width=700>

<h3 id="4-시간-복잡도-1"><a href="#4-시간-복잡도-1" class="headerlink" title="4. 시간 복잡도"></a>4. 시간 복잡도</h3><ul>
<li>일반적인 DFS 시간 복잡도<ul>
<li>노드 수: V</li>
<li>간선 수: E<ul>
<li>위 코드에서 while need_visit 은 V + E 번 만큼 수행함</li>
</ul>
</li>
<li>시간 복잡도: O(V + E)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="탐욕-알고리즘의-이해"><a href="#탐욕-알고리즘의-이해" class="headerlink" title="탐욕 알고리즘의 이해"></a>탐욕 알고리즘의 이해</h2><h3 id="1-탐욕-알고리즘-이란"><a href="#1-탐욕-알고리즘-이란" class="headerlink" title="1. 탐욕 알고리즘 이란?"></a>1. 탐욕 알고리즘 이란?</h3><ul>
<li>Greedy algorithm 또는 탐욕 알고리즘 이라고 불리움</li>
<li>최적의 해에 가까운 값을 구하기 위해 사용됨</li>
<li>여러 경우 중 하나를 결정해야할 때마다, <strong>매순간 최적이라고 생각되는 경우를 선택</strong>하는 방식으로 진행해서, 최종적인 값을 구하는 방식</li>
</ul>
<h3 id="2-탐욕-알고리즘-예"><a href="#2-탐욕-알고리즘-예" class="headerlink" title="2. 탐욕 알고리즘 예"></a>2. 탐욕 알고리즘 예</h3><h4 id="문제1-동전-문제"><a href="#문제1-동전-문제" class="headerlink" title="문제1: 동전 문제"></a>문제1: 동전 문제</h4><ul>
<li>지불해야 하는 값이 4720원 일 때 1원 50원 100원, 500원 동전으로 동전의 수가 가장 적게 지불하시오.<ul>
<li>가장 큰 동전부터 최대한 지불해야 하는 값을 채우는 방식으로 구현 가능</li>
<li>탐욕 알고리즘으로 매순간 최적이라고 생각되는 경우를 선택하면 됨</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">coin_list = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">500</span>]</span><br><span class="line"><span class="built_in">print</span> (coin_list)</span><br><span class="line">coin_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span> (coin_list)</span><br></pre></td></tr></table></figure>
<pre><code>[1, 100, 50, 500]
[500, 100, 50, 1]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">coin_list = [<span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_coin_count</span>(<span class="params">value, coin_list</span>):</span></span><br><span class="line">    total_coin_count = <span class="number">0</span></span><br><span class="line">    details = <span class="built_in">list</span>()</span><br><span class="line">    coin_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coin_list:</span><br><span class="line">        coin_num = value // coin</span><br><span class="line">        total_coin_count += coin_num</span><br><span class="line">        value -= coin_num * coin</span><br><span class="line">        details.append([coin, coin_num])</span><br><span class="line">    <span class="keyword">return</span> total_coin_count, details</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_coin_count(<span class="number">4720</span>, coin_list)</span><br></pre></td></tr></table></figure>



<pre><code>(31, [[500, 9], [100, 2], [50, 0], [1, 20]])
</code></pre>
<h4 id="문제2-부분-배낭-문제-Fractional-Knapsack-Problem"><a href="#문제2-부분-배낭-문제-Fractional-Knapsack-Problem" class="headerlink" title="문제2: 부분 배낭 문제 (Fractional Knapsack Problem)"></a>문제2: 부분 배낭 문제 (Fractional Knapsack Problem)</h4><ul>
<li>무게 제한이 k인 배낭에 최대 가치를 가지도록 물건을 넣는 문제<ul>
<li>각 물건은 무게(w)와 가치(v)로 표현될 수 있음</li>
<li>물건은 쪼갤 수 있으므로 물건의 일부분이 배낭에 넣어질 수 있음, 그래서 Fractional Knapsack Problem 으로 부름<ul>
<li>Fractional Knapsack Problem 의 반대로 물건을 쪼개서 넣을 수 없는 배낭 문제도 존재함 (0/1 Knapsack Problem 으로 부름)<img src="https://www.fun-coding.org/00_Images/knapsack.png">


</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_list = [(<span class="number">10</span>, <span class="number">10</span>), (<span class="number">15</span>, <span class="number">12</span>), (<span class="number">20</span>, <span class="number">10</span>), (<span class="number">25</span>, <span class="number">8</span>), (<span class="number">30</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_max_value</span>(<span class="params">data_list, capacity</span>):</span></span><br><span class="line">    data_list = <span class="built_in">sorted</span>(data_list, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>] / x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    total_value = <span class="number">0</span></span><br><span class="line">    details = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">        <span class="keyword">if</span> capacity - data[<span class="number">0</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            capacity -= data[<span class="number">0</span>]</span><br><span class="line">            total_value += data[<span class="number">1</span>]</span><br><span class="line">            details.append([data[<span class="number">0</span>], data[<span class="number">1</span>], <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fraction = capacity / data[<span class="number">0</span>]</span><br><span class="line">            total_value += data[<span class="number">1</span>] * fraction</span><br><span class="line">            details.append([data[<span class="number">0</span>], data[<span class="number">1</span>], fraction])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_value, details</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_max_value(data_list, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>



<pre><code>(24.5, [[10, 10, 1], [15, 12, 1], [20, 10, 0.25]])
</code></pre>
<h3 id="3-탐욕-알고리즘의-한계"><a href="#3-탐욕-알고리즘의-한계" class="headerlink" title="3. 탐욕 알고리즘의 한계"></a>3. 탐욕 알고리즘의 한계</h3><blockquote>
<p>지금의 선택이 앞으로 남은 선택들에 어떠한 영향을 끼치는지 고려하지 않는다</p>
</blockquote>
<ul>
<li>탐욕 알고리즘은 근사치 추정에 활용</li>
<li>반드시 최적의 해를 구할 수 있는 것은 아니기 때문</li>
<li>최적의 해에 가까운 값을 구하는 방법 중의 하나임</li>
</ul>
<h4 id="예"><a href="#예" class="headerlink" title="예"></a>예</h4><img src="https://www.fun-coding.org/00_Images/greedy.png" width=300>

<ul>
<li>‘시작’ 노드에서 시작해서 가장 작은 값을 찾아 leaf node 까지 가는 경로를 찾을 시에<ul>
<li>Greedy 알고리즘 적용시 시작 -&gt; 7 -&gt; 12 를 선택하게 되므로 7 + 12 = 19 가 됨 </li>
<li>하지만 실제 가장 작은 값은 시작 -&gt; 10 -&gt; 5 이며, 10 + 5 = 15 가 답</li>
</ul>
</li>
</ul>
<h2 id="Shortest-Path-최단-경로-알고리즘"><a href="#Shortest-Path-최단-경로-알고리즘" class="headerlink" title="Shortest Path (최단 경로 알고리즘)"></a>Shortest Path (최단 경로 알고리즘)</h2><h3 id="1-최단-경로-문제란"><a href="#1-최단-경로-문제란" class="headerlink" title="1. 최단 경로 문제란?"></a>1. 최단 경로 문제란?</h3><ul>
<li>두 노드를 잇는 가장 짧은 경로를 찾는 문제</li>
<li>가중치 그래프 (Weighted Graph) 에서 간선 (Edge)의 <strong>가중치 합이 최소</strong>가 되도록 하는 경로를 찾는 것이 목적</li>
</ul>
<h4 id="최단-경로-문제-종류"><a href="#최단-경로-문제-종류" class="headerlink" title="최단 경로 문제 종류"></a>최단 경로 문제 종류</h4><ol>
<li>단일 소스 및 단일 도착 최단 경로 문제</li>
</ol>
<ul>
<li><strong>single-source and single-destination</strong> shortest path problem</li>
<li>그래프 내의 <strong>특정 노드 u 에</strong>서 출발, 또<strong>다른 특정 노드 v</strong> 에 도착하는 가장 짧은 경로를 찾는 문제</li>
</ul>
<ol start="2">
<li>단일 소스 최단 경로 문제</li>
</ol>
<ul>
<li><strong>single-source shortest</strong> path problem</li>
<li>그래프 내의 특정 노드 u 와 그래프 내 다른 <strong>모든 노드 각각</strong>의 가장 짧은 경로를 찾는 문제<ul>
<li>예시<blockquote>
<p>A, B, C, D 라는 노드를 가진 그래프에서 특정 노드를 A 라고 한다면,<br>A 외 모든 노드인 B, C, D 각 노드와 A 간에 가장 짧은 경로를 찾는 문제를 의미<br>즉, A - B, A - C, A - D 각각의 가장 짧은 경로 찾기</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>전체 쌍 최단 경로</li>
</ol>
<ul>
<li><strong>all-pair</strong> shortest path problem</li>
<li>그래프 내의 <strong>모든 노드 쌍</strong> (u, v) 에 대한 최단 경로를 찾는 문제</li>
</ul>
<h3 id="2-최단-경로-알고리즘"><a href="#2-최단-경로-알고리즘" class="headerlink" title="2. 최단 경로 알고리즘"></a>2. 최단 경로 알고리즘</h3><p>다익스트라 알고리즘 (Dijkstra algorithm) : 단일 소스 최단 경로 알고리즘 중 점근적으로 가장 빠른 알고리즘</p>
<ul>
<li>다익스트라 알고리즘은 단일 소스 최단 경로 문제<ul>
<li>하나의 정점에서 다른 모든 정점 간의 각각 <strong>가장 짧은 거리</strong>를 구하는 문제</li>
<li>도로 교통망 같은 곳에서 나타날 수 있는 그래프에서 꼭짓점 간의 최단 경로를 찾는 알고리즘</li>
</ul>
</li>
</ul>
<h4 id="Dijkstra-algorithm-로직"><a href="#Dijkstra-algorithm-로직" class="headerlink" title="Dijkstra algorithm 로직"></a>Dijkstra algorithm 로직</h4><ul>
<li><p>첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단 거리를 갱신하는 기법</p>
</li>
<li><p>다익스트라 알고리즘은 너비우선탐색(BFS)와 유사</p>
<ul>
<li>첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서, 첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트<blockquote>
<p> 다익스트라 알고리즘의 <em>다양한 변형 로직</em>이 있지만, 가장 개선된 <strong>우선순위 큐</strong>를 사용하는 방식에 집중해서 설명하기로 함</p>
</blockquote>
</li>
</ul>
</li>
<li><p>우선순위 큐를 활용한 다익스트라 알고리즘</p>
<ul>
<li>우선순위 큐는 MinHeap 방식을 활용해서, 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 됨</li>
</ul>
<ol>
<li><p>첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장</p>
<ul>
<li>초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장함 (inf 라고 표현함)</li>
<li>우선순위 큐에 (첫 정점, 거리 0) 만 먼저 넣음 </li>
</ul>
</li>
<li><p>우선순위 큐에서 노드를 꺼냄</p>
<ul>
<li>처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐</li>
<li>첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교함</li>
<li>배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리를 업데이트함</li>
<li>배열에 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 넣음<ul>
<li>결과적으로 <strong>너비 우선 탐색 방식과 유사</strong>하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨</li>
<li>만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드, 거리)의 경우에는 해당 노드와 인접한 노드간의 거리 계산을 하지 않음</li>
</ul>
</li>
</ul>
</li>
<li><p>2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복!</p>
</li>
</ol>
</li>
</ul>
<h3 id="3-예제로-이해하는-다익스트라-알고리즘-우선순위-큐-활용"><a href="#3-예제로-이해하는-다익스트라-알고리즘-우선순위-큐-활용" class="headerlink" title="3. 예제로 이해하는 다익스트라 알고리즘 (우선순위 큐 활용)"></a>3. 예제로 이해하는 다익스트라 알고리즘 (우선순위 큐 활용)</h3><p>우선순위 큐 : <strong>최소 힙 기반</strong><br><img src="https://www.fun-coding.org/00_Images/dijkstra.png" width=300></p>
<h4 id="1단계-초기화"><a href="#1단계-초기화" class="headerlink" title="1단계: 초기화"></a>1단계: 초기화</h4><ul>
<li>첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장<ul>
<li>초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장함 (inf 라고 표현함)</li>
<li>우선순위 큐에 (첫 정점, 거리 0) 만 먼저 넣음 </li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/dijkstra_initial.png">

<h4 id="2단계-우선순위-큐에서-추출한-A-0-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산"><a href="#2단계-우선순위-큐에서-추출한-A-0-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산" class="headerlink" title="2단계: 우선순위 큐에서 추출한 (A, 0) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산"></a>2단계: 우선순위 큐에서 추출한 (A, 0) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</h4><ul>
<li>우선순위 큐에서 노드를 꺼냄<ul>
<li><p>처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐</p>
</li>
<li><p>첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교함</p>
</li>
<li><p>배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리를 업데이트함</p>
</li>
<li><p>배열에 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 넣음</p>
<ul>
<li>결과적으로 <strong>너비 우선 탐색 방식과 유사</strong>하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨</li>
<li>만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드, 거리)의 경우에는 해당 노드와 인접한 노드간의 거리 계산을 하지 않음</li>
</ul>
<blockquote>
<p>이전 표에서 보듯이, 첫 정점 이외에 모두 inf 였었으므로, 첫 정점에 인접한 노드들은 모두 우선순위 큐에 들어가고, 첫 정점과 인접한 노드간의 거리가 배열에 업데이트됨</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/dijkstra_1st.png">

<h4 id="3단계-우선순위-큐에서-C-1-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산"><a href="#3단계-우선순위-큐에서-C-1-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산" class="headerlink" title="3단계: 우선순위 큐에서 (C, 1) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산"></a>3단계: 우선순위 큐에서 (C, 1) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</h4><ul>
<li>우선순위 큐가 MinHeap(최소 힙) 방식이므로, 위 표에서 넣어진 (C, 1), (D, 2), (B, 8) 중 (C, 1) 이 먼저 추출됨 (pop)</li>
<li>위 표에서 보듯이 1단계까지의 A - B 최단 거리는 8 인 상황임<ul>
<li>A - C 까지의 거리는 1, C 에 인접한 B, D에서 C - B는 5, 즉 A - C - B 는 1 + 5 = 6 이므로, A - B 최단 거리 8보다 더 작은 거리를 발견, 이를 배열에 업데이트<ul>
<li>배열에 업데이트했으므로 B, 6 (즉 A에서 B까지의 현재까지 발견한 최단 거리) 값이 우선순위 큐에 넣어짐</li>
</ul>
</li>
<li>C - D 의 거리는 2, 즉 A - C - D 는 1 + 2 = 3 이므로, A - D의 현재 최단 거리인 2 보다 긴 거리, 그래서 D 의 거리는 업데이트되지 않음</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/dijkstra_2nd.png">

<h4 id="4단계-우선순위-큐에서-D-2-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산"><a href="#4단계-우선순위-큐에서-D-2-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산" class="headerlink" title="4단계: 우선순위 큐에서 (D, 2) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산"></a>4단계: 우선순위 큐에서 (D, 2) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</h4><ul>
<li>지금까지 접근하지 못했던 E와 F 거리가 계산됨<ul>
<li>A - D 까지의 거리인 2 에 D - E 가 3 이므로 이를 더해서 E, 5</li>
<li>A - D 까지의 거리인 2 에 D - F 가 5 이므로 이를 더해서 F, 7</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/dijkstra_3rd.png">

<h4 id="5단계-우선순위-큐에서-E-5-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산"><a href="#5단계-우선순위-큐에서-E-5-노드-첫-노드와의-거리-를-기반으로-인접한-노드와의-거리-계산" class="headerlink" title="5단계: 우선순위 큐에서 (E, 5) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산"></a>5단계: 우선순위 큐에서 (E, 5) [노드, 첫 노드와의 거리] 를 기반으로 인접한 노드와의 거리 계산</h4><ul>
<li>A - E 거리가 5인 상태에서, E에 인접한 F를 가는 거리는 1, 즉 A - E - F 는 5 + 1 = 6, 현재 배열에 A - F 최단거리가 7로 기록되어 있으므로, F, 6 으로 업데이트<ul>
<li>우선순위 큐에 F, 6 추가</li>
</ul>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/dijkstra_3-2th.png">

<h4 id="6단계-우선순위-큐에서-B-6-F-6-를-순차적으로-추출해-각-노드-기반으로-인접한-노드와의-거리-계산"><a href="#6단계-우선순위-큐에서-B-6-F-6-를-순차적으로-추출해-각-노드-기반으로-인접한-노드와의-거리-계산" class="headerlink" title="6단계: 우선순위 큐에서 (B, 6), (F, 6) 를 순차적으로 추출해 각 노드  기반으로 인접한 노드와의 거리 계산"></a>6단계: 우선순위 큐에서 (B, 6), (F, 6) 를 순차적으로 추출해 각 노드  기반으로 인접한 노드와의 거리 계산</h4><ul>
<li>예제의 방향 그래프에서 B 노드는 다른 노드로 가는 루트가 없음 </li>
<li>F 노드는 A 노드로 가는 루트가 있으나, 현재 A - A 가 0 인 반면에 A - F - A 는 6 + 5 = 11, 즉 더 긴 거리이므로 업데이트되지 않음</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/dijkstra_4th.png">

<h4 id="6단계-우선순위-큐에서-F-7-B-8-를-순차적으로-추출해-각-노드-기반으로-인접한-노드와의-거리-계산"><a href="#6단계-우선순위-큐에서-F-7-B-8-를-순차적으로-추출해-각-노드-기반으로-인접한-노드와의-거리-계산" class="headerlink" title="6단계: 우선순위 큐에서 (F, 7), (B, 8) 를 순차적으로 추출해 각 노드  기반으로 인접한 노드와의 거리 계산"></a>6단계: 우선순위 큐에서 (F, 7), (B, 8) 를 순차적으로 추출해 각 노드  기반으로 인접한 노드와의 거리 계산</h4><ul>
<li>A - F 로 가는 하나의 루트의 거리가 7 인 상황이나, 배열에서 이미 A - F 로 가는 현재의 최단 거리가 6인 루트의 값이 있는 상황이므로, 더 긴거리인 F, 7 루트 기반 인접 노드까지의 거리는 계산할 필요가 없음, 그래서 계산없이 스킵함<ul>
<li>계산하더라도 A - F 거리가 6인 루트보다 무조건 더 긴거리가 나올 수 밖에 없음</li>
</ul>
</li>
<li>B, 8 도 현재 A - B 거리가 6이므로, 인접 노드 거리 계산이 필요 없음 </li>
</ul>
<blockquote>
<p>우선순위 큐를 사용하면 불필요한 계산 과정을 줄일 수 있음</p>
</blockquote>
<img src="https://www.fun-coding.org/00_Images/dijkstra_5th.png">

<h4 id="우선순위-큐-사용-장점"><a href="#우선순위-큐-사용-장점" class="headerlink" title="우선순위 큐 사용 장점"></a>우선순위 큐 사용 장점</h4><ul>
<li>지금까지 발견된 가장 짧은 거리의 노드에 대해서 먼저 계산</li>
<li>더 긴 거리로 계산된 루트에 대해서는 계산을 스킵할 수 있음</li>
</ul>
<h3 id="4-다익스트라-알고리즘-파이썬-구현-우선순위-큐-활용까지-포함"><a href="#4-다익스트라-알고리즘-파이썬-구현-우선순위-큐-활용까지-포함" class="headerlink" title="4. 다익스트라 알고리즘 파이썬 구현 (우선순위 큐 활용까지 포함)"></a>4. 다익스트라 알고리즘 파이썬 구현 (우선순위 큐 활용까지 포함)</h3><h4 id="참고-heapq-라이브러리-활용을-통해-우선순위-큐-사용하기"><a href="#참고-heapq-라이브러리-활용을-통해-우선순위-큐-사용하기" class="headerlink" title="참고: heapq 라이브러리 활용을 통해 우선순위 큐 사용하기"></a>참고: heapq 라이브러리 활용을 통해 우선순위 큐 사용하기</h4><ul>
<li>데이터가 리스트 형태일 경우, 0번 인덱스를 우선순위로 인지, 우선순위가 낮은 순서대로 pop 할 수 있음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line"></span><br><span class="line">heapq.heappush(queue, [<span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>])</span><br><span class="line">heapq.heappush(queue, [<span class="number">5</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">heapq.heappush(queue, [<span class="number">1</span>, <span class="string">&#x27;C&#x27;</span>])</span><br><span class="line">heapq.heappush(queue, [<span class="number">7</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (queue)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">    <span class="built_in">print</span> (heapq.heappop(queue))</span><br></pre></td></tr></table></figure>
<pre><code>[[1, &#39;C&#39;], [5, &#39;B&#39;], [2, &#39;A&#39;], [7, &#39;D&#39;]]
[1, &#39;C&#39;]
[2, &#39;A&#39;]
[5, &#39;B&#39;]
[7, &#39;D&#39;]
</code></pre>
<h4 id="다익스트라-알고리즘"><a href="#다익스트라-알고리즘" class="headerlink" title="다익스트라 알고리즘"></a>다익스트라 알고리즘</h4><ul>
<li>탐색할 그래프의 시작 정점과 다른 정점들간의 최단 거리 구하기</li>
</ul>
<ol>
<li>그래프화<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mygraph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;E&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: &#123;<span class="string">&#x27;F&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>우선순위큐(최소 힙 기반)를 사용해 코드 작성<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 초기화</span></span><br><span class="line">    distances = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distances[start] = <span class="number">0</span></span><br><span class="line">    queue = []</span><br><span class="line">    heapq.heappush(queue, [distances[start], start])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        current_distance, current_node = heapq.heappop(queue)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> distances[current_node] &lt; current_distance:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> adjacent, weight <span class="keyword">in</span> graph[current_node].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[adjacent]:</span><br><span class="line">                distances[adjacent] = distance</span><br><span class="line">                heapq.heappush(queue, [distance, adjacent])</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> distances</span><br></pre></td></tr></table></figure>
<img src="https://www.fun-coding.org/00_Images/dijkstra.png" width=300>


</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dijkstra(mygraph, <span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>



<pre><code>&#123;&#39;A&#39;: 0, &#39;B&#39;: 6, &#39;C&#39;: 1, &#39;D&#39;: 2, &#39;E&#39;: 5, &#39;F&#39;: 6&#125;
</code></pre>
<h4 id="참고-최단-경로-출력"><a href="#참고-최단-경로-출력" class="headerlink" title="참고: 최단 경로 출력"></a>참고: 최단 경로 출력</h4><ul>
<li>탐색할 그래프의 시작 정점과 다른 정점들간의 최단 거리 및 최단 경로 출력하기</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="comment">## 탐색할 그래프와 시작 정점을 인수로 전달받습니다.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">graph, start, end</span>):</span></span><br><span class="line">    <span class="comment"># 시작 정점에서 각 정점까지의 거리를 저장할 딕셔너리를 생성하고, 무한대(inf)로 초기화합니다.</span></span><br><span class="line">    distances = &#123;vertex: [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), start] <span class="keyword">for</span> vertex <span class="keyword">in</span> graph&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 그래프의 시작 정점의 거리는 0으로 초기화 해줌</span></span><br><span class="line">    distances[start] = [<span class="number">0</span>, start]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 모든 정점이 저장될 큐를 생성합니다.</span></span><br><span class="line">    queue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 그래프의 시작 정점과 시작 정점의 거리(0)을 최소힙에 넣어줌</span></span><br><span class="line">    heapq.heappush(queue, [distances[start][<span class="number">0</span>], start])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 큐에서 정점을 하나씩 꺼내 인접한 정점들의 가중치를 모두 확인하여 업데이트합니다.</span></span><br><span class="line">        current_distance, current_vertex = heapq.heappop(queue)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 더 짧은 경로가 있다면 무시한다.</span></span><br><span class="line">        <span class="keyword">if</span> distances[current_vertex][<span class="number">0</span>] &lt; current_distance:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> adjacent, weight <span class="keyword">in</span> graph[current_vertex].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            <span class="comment"># 만약 시작 정점에서 인접 정점으로 바로 가는 것보다 현재 정점을 통해 가는 것이 더 가까울 경우에는</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[adjacent][<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 거리를 업데이트합니다.</span></span><br><span class="line">                distances[adjacent] = [distance, current_vertex]</span><br><span class="line">                heapq.heappush(queue, [distance, adjacent])</span><br><span class="line">    </span><br><span class="line">    path = end</span><br><span class="line">    path_output = end + <span class="string">&#x27;-&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> distances[path][<span class="number">1</span>] != start:</span><br><span class="line">        path_output += distances[path][<span class="number">1</span>] + <span class="string">&#x27;-&gt;&#x27;</span></span><br><span class="line">        path = distances[path][<span class="number">1</span>]</span><br><span class="line">    path_output += start</span><br><span class="line">    <span class="built_in">print</span> (path_output)</span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br><span class="line"><span class="comment">## 방향 그래프</span></span><br><span class="line">mygraph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;E&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: &#123;<span class="string">&#x27;F&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(dijkstra(mygraph, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>))</span><br></pre></td></tr></table></figure>
<pre><code>F-&gt;E-&gt;D-&gt;A
&#123;&#39;A&#39;: [0, &#39;A&#39;], &#39;B&#39;: [6, &#39;C&#39;], &#39;C&#39;: [1, &#39;A&#39;], &#39;D&#39;: [2, &#39;A&#39;], &#39;E&#39;: [5, &#39;D&#39;], &#39;F&#39;: [6, &#39;E&#39;]&#125;
</code></pre>
<h3 id="5-시간-복잡도"><a href="#5-시간-복잡도" class="headerlink" title="5. 시간 복잡도"></a>5. 시간 복잡도</h3><ul>
<li><p>위 다익스트라 알고리즘은 크게 다음 두 가지 과정을 거침</p>
<ul>
<li>과정1: 각 노드마다 인접한 간선들을 모두 <strong>검사</strong></li>
<li>과정2: 우선순위 큐에 노드/거리 정보를 넣고 <strong>삭제(pop)</strong></li>
</ul>
</li>
<li><p>각 과정별 시간 복잡도</p>
<ul>
<li><p>과정1: 각 노드는 최대 한 번씩 방문하므로 (첫 노드와 해당 노드간의 갈 수 있는 루트가 있는 경우만 해당), 그래프의 모든 간선은 최대 한 번씩 검사</p>
<ul>
<li>즉, 각 노드마다 인접한 간선들을 모두 검사하는 과정은 O(E) 시간이 걸림<ul>
<li>E 는 간선(edge)의 약자</li>
</ul>
</li>
</ul>
</li>
<li><p>과정2: 우선순위 큐에 가장 많은 노드, 거리 정보가 들어가는 경우, 우선순위 큐에 노드/거리 정보를 넣고, 삭제하는 과정이 최악의 시간이 걸림</p>
<ul>
<li>우선순위 큐에 가장 많은 노드, 거리 정보가 들어가는 시나리오는 그래프의 모든 간선이 검사될 때마다, 배열의 최단 거리가 갱신되고, 우선순위 큐에 노드/거리가 추가되는 것임</li>
<li>이 때 추가는 각 간선마다 최대 한 번 일어날 수 있으므로, 최대 O(E)의 시간이 걸리고, O(E) 개의 노드/거리 정보에 대해 우선순위 큐를 유지하는 작업은 $ O(log{E}) $ 가 걸림<ul>
<li>따라서 해당 과정의 시간 복잡도는 $ O(Elog{E}) $ </li>
<li>[참고] 최소힙을 유지하는 시간이 O(logE)라서</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="총-시간-복잡도"><a href="#총-시간-복잡도" class="headerlink" title="총 시간 복잡도"></a>총 시간 복잡도</h4><ul>
<li><p>과정1 + 과정2 = O(E) + $ O(Elog{E}) $  = $ O(E + Elog{E}) = O(Elog{E}) $</p>
<h4 id="참고-힙의-시간-복잡도"><a href="#참고-힙의-시간-복잡도" class="headerlink" title="참고: 힙의 시간 복잡도"></a>참고: 힙의 시간 복잡도</h4></li>
<li><p>depth (트리의 높이) 를 h라고 표기한다면,</p>
</li>
<li><p>n개의 노드를 가지는 heap 에 데이터 삽입 또는 삭제시, 최악의 경우 root 노드에서 leaf 노드까지 비교해야 하므로  h=log2n  에 가까우므로, 시간 복잡도는  O(logn)</p>
</li>
</ul>
<h2 id="Spanning-Tree-신장-트리"><a href="#Spanning-Tree-신장-트리" class="headerlink" title="Spanning Tree (신장 트리)"></a>Spanning Tree (신장 트리)</h2><p>최소 신장 트리의 이해</p>
<h3 id="1-신장-트리-란"><a href="#1-신장-트리-란" class="headerlink" title="1. 신장 트리 란?"></a>1. 신장 트리 란?</h3><ul>
<li><p>Spanning Tree, 또는 신장 트리 라고 불리움 (Spanning Tree가 보다 자연스러워 보임)</p>
</li>
<li><p>원래의 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족하는 그래프</p>
</li>
<li><p>신장 트리의 조건</p>
<ul>
<li>본래의 그래프의 모든 노드를 포함해야 함</li>
<li><em>모든 노드가 서로 연결</em></li>
<li>트리의 속성을 만족시킴 (<em>사이클이 존재하지 않음</em>)</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/spanningtree.png">

</li>
</ul>
<h3 id="2-최소-신장-트리"><a href="#2-최소-신장-트리" class="headerlink" title="2. 최소 신장 트리"></a>2. 최소 신장 트리</h3><ul>
<li>Minimum Spanning Tree, MST 라고 불리움</li>
<li>가능한 Spanning Tree 중에서, 간선의 가중치 합이 최소인 Spanning Tree를 지칭함</li>
<li>(마지막 노드 뺀) 한붓그리기</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/mst.png" width=600>

<h3 id="3-최소-신장-트리-알고리즘"><a href="#3-최소-신장-트리-알고리즘" class="headerlink" title="3. 최소 신장 트리 알고리즘"></a>3. 최소 신장 트리 알고리즘</h3><ul>
<li>그래프에서 최소 신장 트리를 찾을 수 있는 알고리즘이 존재함</li>
<li>대표적인 최소 신장 트리 알고리즘<ul>
<li>Kruskal’s algorithm (크루스칼 알고리즘) : 모든 정점에 대해서</li>
<li>Prim’s algorithm (프림 알고리즘) : 지금 연결된 노드에 붙어있는 간선 중에서</li>
</ul>
</li>
</ul>
<h4 id="1-크루스칼-알고리즘-Kruskal’s-algorithm"><a href="#1-크루스칼-알고리즘-Kruskal’s-algorithm" class="headerlink" title="1. 크루스칼 알고리즘 (Kruskal’s algorithm)"></a>1. 크루스칼 알고리즘 (Kruskal’s algorithm)</h4><ol>
<li>모든 정점을 독립적인 집합으로 만들기</li>
<li>모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교</li>
<li>두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결<ul>
<li>(<strong>사이클이 생기지 않도록</strong> 하기 위함)</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>탐욕 알고리즘을 기초</strong>로 하고 있음<br>(당장 눈 앞의 최소 비용을 선택해서, 결과적으로 최적의 솔루션을 찾음)</p>
</blockquote>
<img src="https://www.fun-coding.org/00_Images/kruscal_internal1.png" width=650>

<img src="https://www.fun-coding.org/00_Images/kruscal_internal2.png" width=800>

<h4 id="2-Union-Find-알고리즘"><a href="#2-Union-Find-알고리즘" class="headerlink" title="2. Union-Find 알고리즘"></a>2. Union-Find 알고리즘</h4><ul>
<li>Disjoint Set을 표현할 때 사용하는 알고리즘으로 트리 구조를 활용하는 알고리즘</li>
<li>간단하게, 노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때 (합칠 때) 사용</li>
<li>Disjoint Set이란<ul>
<li>서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조</li>
<li>공통 원소가 없는 (서로소) 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 자료구조를 의미함</li>
<li>Disjoint Set = 서로소 집합 자료구조</li>
</ul>
</li>
</ul>
<ol>
<li><p>초기화</p>
<ul>
<li>n 개의 원소가 개별 집합으로 이뤄지도록 초기화<img src="https://www.fun-coding.org/00_Images/initial_findunion.png" width=400></li>
</ul>
</li>
<li><p>Union</p>
<ul>
<li>두 개별 집합을 하나의 집합으로 합침, 두 트리를 하나의 트리로 만들음<img src="https://www.fun-coding.org/00_Images/union_findunion.png" width=600>
</li>
</ul>
</li>
<li><p>Find</p>
<ul>
<li>집합을 합칠 때 싸이클이 있는지 없는지 보는 것</li>
<li>여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하기 위해, 각 그룹의 최상단 원소 (즉, 루트 노드)를 확인   <img src="https://www.fun-coding.org/00_Images/find_findunion.png" width=500>

</li>
</ul>
</li>
</ol>
<h5 id="Union-Find-알고리즘의-고려할-점"><a href="#Union-Find-알고리즘의-고려할-점" class="headerlink" title="Union-Find 알고리즘의 고려할 점"></a>Union-Find 알고리즘의 고려할 점</h5><ul>
<li>Union 순서에 따라서, 최악의 경우 링크드 리스트와 같은 형태가 될 수 있음.</li>
<li>이 때는 Find/Union 시 계산량이 O(N) 이 될 수 있으므로, 해당 문제를 해결하기 위해, union-by-rank, path compression 기법을 사용함 </li>
</ul>
<img src="https://www.fun-coding.org/00_Images/worst_findunion.png" width=200>

<h5 id="union-by-rank-기법"><a href="#union-by-rank-기법" class="headerlink" title="union-by-rank 기법"></a>union-by-rank 기법</h5><ul>
<li><p>각 트리에 대해 높이(rank)를 기억해 두고,</p>
</li>
<li><p>Union시 두 트리의 높이(rank)가 다르면, 높이가 작은 트리를 높이가 큰 트리에 붙임 (즉, 높이가 큰 트리의 루트 노드가 합친 집합의 루트 노드가 되게 함)</p>
<img src="https://www.fun-coding.org/00_Images/unionbyrank_findunion.png" width=700>
</li>
<li><p>높이가 h - 1 인 두 개의 트리를 합칠 때는 한 쪽의 트리 높이를 1 증가시켜주고, 다른 쪽의 트리를 해당 트리에 붙여줌</p>
<img src="https://www.fun-coding.org/00_Images/unionbyranksame_findunion.png" width=700>
</li>
<li><p>초기화시, 모든 원소는 높이(rank) 가 0 인 개별 집합인 상태에서, 하나씩 원소를 합칠 때, union-by-rank 기법을 사용한다면,</p>
<ul>
<li>높이가 h 인 트리가 만들어지려면, 높이가 h - 1 인 두 개의 트리가 합쳐져야 함</li>
<li>높이가 h - 1 인 트리를 만들기 위해 최소 n개의 원소가 필요하다면, 높이가 h 인 트리가 만들어지기 위해서는 최소 2n개의 원소가 필요함</li>
<li>따라서 union-by-rank 기법을 사용하면, union/find 연산의 시간복잡도는 O(N) 이 아닌, $ O(log{N}) $ 로 낮출 수 있음</li>
</ul>
</li>
</ul>
<h5 id="path-compression"><a href="#path-compression" class="headerlink" title="path compression"></a>path compression</h5><ul>
<li>Find를 실행한 노드에서 거쳐간 노드를 루트에 다이렉트로 연결하는 기법</li>
<li>Find를 실행한 노드는 이후부터는 루트 노드를 한번에 알 수 있음</li>
</ul>
<center><img src="https://www.fun-coding.org/00_Images/pathcompression_findunion.png" width=400></center>

<ul>
<li>union-by-rank 와 path compression 기법 사용시 시간 복잡도는 다음 계산식을 만족함이 증명되었음<ul>
<li>$ O(M log^*{N}) $</li>
<li>$ log^*{N} $ 은 다음 값을 가짐이 증명되었음<ul>
<li>N이 $ 2^{65536} $ 값을 가지더라도, $ log^*{N} $ 의 값이 5의 값을 가지므로, 거의 O(1), 즉 상수값에 가깝다고 볼 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="text-align:left">
<table>
  <tr>
    <th style="text-align:center">N</th>
    <th style="text-align:center">$ log^*{N} $</th>
  </tr>
  <tr>
    <td style="text-align:left">1</td>
    <td style="text-align:left">0</td>
  </tr>
  <tr>
    <td style="text-align:left">2</td>
    <td style="text-align:left">1</td>
  </tr>
  <tr>
    <td style="text-align:left">4</td>
    <td style="text-align:left">2</td>
  </tr>
  <tr>
    <td style="text-align:left">16</td>
    <td style="text-align:left">3</td>
  </tr>
  <tr>
    <td style="text-align:left">65536</td>
    <td style="text-align:left">4</td>
  </tr>
  <tr>
    <td style="text-align:left">$ 2^{65536} $</td>
    <td style="text-align:left">5</td>
  </tr>
</table>
</div>

<h3 id="4-크루스칼-알고리즘-Kruskal’s-algorithm-코드-작성"><a href="#4-크루스칼-알고리즘-Kruskal’s-algorithm-코드-작성" class="headerlink" title="4. 크루스칼 알고리즘 (Kruskal’s algorithm) 코드 작성"></a>4. 크루스칼 알고리즘 (Kruskal’s algorithm) 코드 작성</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mygraph = &#123;</span><br><span class="line">    <span class="string">&#x27;vertices&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;edges&#x27;</span>: [</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">        (<span class="number">8</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        (<span class="number">8</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;B&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;B&#x27;</span>),</span><br><span class="line">        (<span class="number">5</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        (<span class="number">7</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">        (<span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>),</span><br><span class="line">        (<span class="number">6</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">        (<span class="number">8</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        (<span class="number">11</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>),</span><br><span class="line">        (<span class="number">9</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        (<span class="number">11</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">parent = <span class="built_in">dict</span>()</span><br><span class="line">rank = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="comment"># path compression 기법</span></span><br><span class="line">    <span class="keyword">if</span> parent[node] != node:  <span class="comment"># root node가 있다면</span></span><br><span class="line">        parent[node] = find(parent[node])</span><br><span class="line">    <span class="keyword">return</span> parent[node]       <span class="comment"># 자기노드가 루트로드인 시점</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">node_v, node_u</span>):</span></span><br><span class="line">    root1 = find(node_v)</span><br><span class="line">    root2 = find(node_u)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># union-by-rank 기법</span></span><br><span class="line">    <span class="keyword">if</span> rank[root1] &gt; rank[root2]:</span><br><span class="line">        parent[root2] = root1 <span class="comment"># 높은 쪽을 낮은 쪽의 root 로드로</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[root1] = root2</span><br><span class="line">        <span class="keyword">if</span> rank[root1] == rank[root2]:</span><br><span class="line">            rank[root2] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_set</span>(<span class="params">node</span>):</span></span><br><span class="line">    parent[node] = node</span><br><span class="line">    rank[node] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kruskal</span>(<span class="params">graph</span>):</span></span><br><span class="line">    mst = <span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 초기화</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph[<span class="string">&#x27;vertices&#x27;</span>]:</span><br><span class="line">        make_set(node)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 간선 weight 기반 sorting</span></span><br><span class="line">    edges = graph[<span class="string">&#x27;edges&#x27;</span>]</span><br><span class="line">    edges.sort() <span class="comment"># 나중에 심심하면 Quick sort 구현해보기</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 간선 연결 (사이클 없는)</span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        weight, node_v, node_u = edge</span><br><span class="line">        <span class="keyword">if</span> find(node_v) != find(node_u):</span><br><span class="line">            union(node_v, node_u)</span><br><span class="line">            mst.append(edge)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mst</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kruskal(mygraph)</span><br></pre></td></tr></table></figure>



<pre><code>[(5, &#39;A&#39;, &#39;D&#39;),
 (5, &#39;C&#39;, &#39;E&#39;),
 (6, &#39;D&#39;, &#39;F&#39;),
 (7, &#39;A&#39;, &#39;B&#39;),
 (7, &#39;B&#39;, &#39;E&#39;),
 (9, &#39;E&#39;, &#39;G&#39;)]
</code></pre>
<h4 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h4><ul>
<li>크루스컬 알고리즘의 시간 복잡도는 O(E log E)<ul>
<li>다음 단계에서 2번, 간선을 비용 기준으로 정렬하는 시간에 좌우됨<ul>
<li>즉, 간선을 비용 기준으로 정렬하는 시간이 가장 큼</li>
</ul>
</li>
</ul>
<ol>
<li>모든 정점을 독립적인 집합으로 만듦 (초기화할 때 노드의 수 만큼 부분 집합을 만든다)</li>
<li>모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교함<ul>
<li>퀵소트를 사용한다면 시간 복잡도는 O(n log n) 이며, 간선이 n 이므로 O(E log E)</li>
</ul>
</li>
<li>두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결함 (최소 신장 트리는 사이클이 없으므로, 사이클이 생기지 않도록 하는 것임)<ul>
<li>union-by-rank 와 path compression 기법 사용시 시간 복잡도가 결국 상수값에 가까움, O(1)</li>
</ul>
</li>
</ol>
</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/kruscal_time.png">





<h3 id="5-프림-알고리즘-Prim’s-algorithm"><a href="#5-프림-알고리즘-Prim’s-algorithm" class="headerlink" title="5. 프림 알고리즘 (Prim’s algorithm)"></a>5. 프림 알고리즘 (Prim’s algorithm)</h3><p>기본 : 간선을 중심으로 반복<br>개선 : 노드의 개수를 중심으로 반복 (노드갯수&lt;간선갯수 이므로 더 효율적)</p>
<p>업데이트 된 키값으로 최소 신장트리 만듦</p>
<ul>
<li>대표적인 최소 신장 트리 알고리즘<ul>
<li>Kruskal’s algorithm (크루스칼 알고리즘), Prim’s algorithm (프림 알고리즘)</li>
</ul>
</li>
<li>프림 알고리즘 <ul>
<li>시작 정점을 선택한 후, 정점에 인접한 간선중 최소 간선으로 연결된 정점을 선택하고, 해당 정점에서 다시 최소 간선으로 연결된 정점을 선택하는 방식으로 최소 신장 트리를 확장해가는 방식<blockquote>
<p>지금까지 연결된 간선 중에서 가장 작은 가중치를 가지는 간선을 선택! (예: 스타크래프트 유닛이 점점 보이는 위치 넓혀가는 거?) </p>
</blockquote>
</li>
</ul>
</li>
<li>Kruskal’s algorithm 과 Prim’s algorithm 비교<ul>
<li>둘다, 탐욕 알고리즘을 기초로 하고 있음 (당장 눈 앞의 최소 비용을 선택해서, 결과적으로 최적의 솔루션을 찾음)</li>
<li>Kruskal’s algorithm은 가장 가중치가 작은 간선부터 선택하면서 MST를 구함</li>
<li>Prim’s algorithm은 특정 정점에서 시작, 해당 정점에 연결된 가장 가중치가 작은 간선을 선택, 간선으로 연결된 정점들에 연결된 간선 중에서 가장 가중치가 작은 간선을 택하는 방식으로 MST를 구함</li>
</ul>
</li>
</ul>
<h4 id="1-그림으로-이해하는-프림-알고리즘"><a href="#1-그림으로-이해하는-프림-알고리즘" class="headerlink" title="1. 그림으로 이해하는 프림 알고리즘"></a>1. 그림으로 이해하는 프림 알고리즘</h4><ol>
<li>임의의 정점을 선택, ‘연결된 노드 집합’에 삽입</li>
<li>선택된 정점에 연결된 간선들을 간선 리스트에 삽입</li>
<li>간선 리스트에서 최소 가중치를 가지는 간선부터 추출해서,<ul>
<li>해당 간선에 연결된 인접 정점이 ‘연결된 노드 집합’에 이미 들어 있다면, 스킵함(cycle 발생을 막기 위함)</li>
<li>해당 간선에 연결된 인접 정점이 ‘연결된 노드 집합’에 들어 있지 않으면, 해당 간선을 선택하고, 해당 간선 정보를 ‘최소 신장 트리’에 삽입</li>
</ul>
</li>
<li>추출한 간선은 간선 리스트에서 제거</li>
<li>간선 리스트에 더 이상의 간선이 없을 때까지 3-4번을 반복</li>
</ol>
<img src="https://www.fun-coding.org/00_Images/prim1.png" width=800>

<img src="https://www.fun-coding.org/00_Images/prim2.png" width=800>

<img src="https://www.fun-coding.org/00_Images/prim3.png" width=800>

<h4 id="2-프림-알고리즘-Prim’s-algorithm-베이스-코드"><a href="#2-프림-알고리즘-Prim’s-algorithm-베이스-코드" class="headerlink" title="2. 프림 알고리즘 (Prim’s algorithm) 베이스 코드"></a>2. 프림 알고리즘 (Prim’s algorithm) 베이스 코드</h4><ol>
<li>heapq 라이브러리 활용을 통해 우선순위 큐 사용하기<blockquote>
<ul>
<li>heapq.heappush를 통해 데이터를 heap 형태로 넣을 수 있음 (0번 인덱스를 우선순위로 인지함)</li>
</ul>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">graph_data = [[<span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>], [<span class="number">5</span>, <span class="string">&#x27;B&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> graph_data:</span><br><span class="line">    heapq.heappush(queue, edge)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">    <span class="built_in">print</span> (heapq.heappop(queue))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (queue)</span><br></pre></td></tr></table></figure>
<pre><code>[2, &#39;A&#39;]
[3, &#39;C&#39;]
[5, &#39;B&#39;]
[]
</code></pre>
<p>1.2. 한방에 전체 리스트를 힙구조로 만들어주는 코드 (별도의 queue 리스트 필요 없음)</p>
<blockquote>
<ul>
<li>heapq.heapify() 함수를 통해 리스트 데이터를 heap 형태로 한 번에 변환할 수 있음 (0번 인덱스를 우선순위로 인지함)</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">graph_data = [[<span class="number">2</span>, <span class="string">&#x27;A&#x27;</span>], [<span class="number">5</span>, <span class="string">&#x27;B&#x27;</span>], [<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">heapq.heapify(graph_data)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph_data)):</span><br><span class="line">    <span class="built_in">print</span> (heapq.heappop(graph_data))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (graph_data)</span><br></pre></td></tr></table></figure>
<pre><code>[2, &#39;A&#39;]
[3, &#39;C&#39;]
[5, &#39;B&#39;]
[]
</code></pre>
<ol start="2">
<li>collections 라이브러리의 defaultdict 함수 활용하기<blockquote>
<ul>
<li>defaultdict 함수를 사용해서, key에 대한 value를 지정하지 않았을 시, 빈 리스트로 초기화하기</li>
</ul>
</blockquote>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">list_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span> (list_dict[<span class="string">&#x27;key1&#x27;</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[]
</code></pre>
<h4 id="3-프림-알고리즘-코드-작성-파이썬"><a href="#3-프림-알고리즘-코드-작성-파이썬" class="headerlink" title="3. 프림 알고리즘 코드 작성 (파이썬)"></a>3. 프림 알고리즘 코드 작성 (파이썬)</h4><ol start="0">
<li>모든 간선 정보를 저장 (<strong>adjacent_edges</strong>)</li>
<li>임의의 정점을 선택, ‘연결된 노드 집합(<strong>connected_nodes</strong>)’에 삽입</li>
<li>선택된 정점에 연결된 간선들을 간선 리스트(<strong>candidate_edge_list</strong>)에 삽입</li>
<li>간선 리스트(<strong>candidate_edge_list</strong>)에서 최소 가중치를 가지는 간선부터 추출해서,<ul>
<li>해당 간선에 연결된 인접 정점이 ‘연결된 노드 집합’에 이미 들어 있다면, 스킵함(cycle 발생을 막기 위함)</li>
<li>해당 간선에 연결된 인접 정점이 ‘연결된 노드 집합’에 들어 있지 않으면, 해당 간선을 선택하고, 해당 간선 정보를 ‘최소 신장 트리(<strong>mst</strong>)’에 삽입<ul>
<li>해당 간선에 연결된 인접 정점의 간선들 중, ‘연결된 노드 집합(<strong>connected_nodes</strong>)’ 에 없는 노드와 연결된 간선들만 간선 리스트(<strong>candidate_edge_list</strong>) 에 삽입 <ul>
<li>‘연결된 노드 집합(<strong>connected_nodes</strong>)’ 에 있는 노드와 연결된 간선들을 간선 리스트에 삽입해도, 해당 간선은 스킵될 것이기 때문</li>
<li>어차피 스킵될 간선을 간선 리스트(<strong>candidate_edge_list</strong>)에 넣지 않으므로 해서, 간선 리스트(<strong>candidate_edge_list</strong>)에서 최소 가중치를 가지는 간선부터 추출하기 위한 자료구조 유지를 위한 effort를 줄일 수 있음 (예, 최소힙 구조 사용)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>선택된 간선은 간선 리스트에서 제거</li>
<li>간선 리스트에 더 이상의 간선이 없을 때까지 3-4번을 반복</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myedges = [</span><br><span class="line">    (<span class="number">7</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>), (<span class="number">9</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>), (<span class="number">7</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>), (<span class="number">6</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>), (<span class="number">9</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;G&#x27;</span>),</span><br><span class="line">    (<span class="number">11</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span>(<span class="params">start_node, edges</span>):</span></span><br><span class="line">    mst = <span class="built_in">list</span>()</span><br><span class="line">    adjacent_edges = defaultdict(<span class="built_in">list</span>) <span class="comment"># 연결되어 있는 간선을 저장</span></span><br><span class="line">    <span class="keyword">for</span> weight, n1, n2 <span class="keyword">in</span> edges:</span><br><span class="line">        adjacent_edges[n1].append((weight, n1, n2))</span><br><span class="line">        adjacent_edges[n2].append((weight, n2, n1))</span><br><span class="line"></span><br><span class="line">    connected_nodes = <span class="built_in">set</span>(start_node)</span><br><span class="line">    candidate_edge_list = adjacent_edges[start_node]</span><br><span class="line">    heapify(candidate_edge_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> candidate_edge_list:</span><br><span class="line">        weight, n1, n2 = heappop(candidate_edge_list)</span><br><span class="line">        <span class="keyword">if</span> n2 <span class="keyword">not</span> <span class="keyword">in</span> connected_nodes:</span><br><span class="line">            connected_nodes.add(n2)</span><br><span class="line">            mst.append((weight, n1, n2))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> edge <span class="keyword">in</span> adjacent_edges[n2]:</span><br><span class="line">                <span class="keyword">if</span> edge[<span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> connected_nodes:</span><br><span class="line">                    heappush(candidate_edge_list, edge)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mst</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prim (<span class="string">&#x27;A&#x27;</span>, myedges)</span><br></pre></td></tr></table></figure>



<pre><code>[(5, &#39;A&#39;, &#39;D&#39;),
 (6, &#39;D&#39;, &#39;F&#39;),
 (7, &#39;A&#39;, &#39;B&#39;),
 (7, &#39;B&#39;, &#39;E&#39;),
 (5, &#39;E&#39;, &#39;C&#39;),
 (9, &#39;E&#39;, &#39;G&#39;)]
</code></pre>
<h5 id="뜯어보기"><a href="#뜯어보기" class="headerlink" title="뜯어보기"></a>뜯어보기</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span>(<span class="params">start_node, edges</span>):</span></span><br><span class="line">    mst = <span class="built_in">list</span>()</span><br><span class="line">    adjacent_edges = defaultdict(<span class="built_in">list</span>) <span class="comment"># 연결되어 있는 간선을 저장</span></span><br><span class="line">    <span class="keyword">for</span> weight, n1, n2 <span class="keyword">in</span> edges:</span><br><span class="line">        adjacent_edges[n1].append((weight, n1, n2))</span><br><span class="line">        adjacent_edges[n2].append((weight, n2, n1))</span><br><span class="line">    <span class="comment"># 확인</span></span><br><span class="line">    print(adjacent_edges)</span><br><span class="line"><span class="comment">## 확인</span></span><br><span class="line">prim(<span class="string">&#x27;A&#x27;</span>, myedges)</span><br></pre></td></tr></table></figure>
<pre><code>defaultdict(&lt;class &#39;list&#39;&gt;, &#123;&#39;A&#39;: [(7, &#39;A&#39;, &#39;B&#39;), (5, &#39;A&#39;, &#39;D&#39;)], &#39;B&#39;: [(7, &#39;B&#39;, &#39;A&#39;), (8, &#39;B&#39;, &#39;C&#39;), (9, &#39;B&#39;, &#39;D&#39;), (7, &#39;B&#39;, &#39;E&#39;)], &#39;D&#39;: [(5, &#39;D&#39;, &#39;A&#39;), (9, &#39;D&#39;, &#39;B&#39;), (7, &#39;D&#39;, &#39;E&#39;), (6, &#39;D&#39;, &#39;F&#39;)], &#39;C&#39;: [(8, &#39;C&#39;, &#39;B&#39;), (5, &#39;C&#39;, &#39;E&#39;)], &#39;E&#39;: [(7, &#39;E&#39;, &#39;B&#39;), (5, &#39;E&#39;, &#39;C&#39;), (7, &#39;E&#39;, &#39;D&#39;), (8, &#39;E&#39;, &#39;F&#39;), (9, &#39;E&#39;, &#39;G&#39;)], &#39;F&#39;: [(6, &#39;F&#39;, &#39;D&#39;), (8, &#39;F&#39;, &#39;E&#39;), (11, &#39;F&#39;, &#39;G&#39;)], &#39;G&#39;: [(9, &#39;G&#39;, &#39;E&#39;), (11, &#39;G&#39;, &#39;F&#39;)]&#125;)
</code></pre>
<h4 id="4-시간-복잡도-2"><a href="#4-시간-복잡도-2" class="headerlink" title="4. 시간 복잡도"></a>4. 시간 복잡도</h4><ul>
<li>최악의 경우, while 구문에서 모든 간선에 대해 반복하고, 최소 힙 구조를 사용하므로 <strong>O($ElogE$)</strong> 시간 복잡도를 가짐<ul>
<li>E : 간선</li>
</ul>
</li>
</ul>
<h4 id="참고-개선된-프림-알고리즘"><a href="#참고-개선된-프림-알고리즘" class="headerlink" title="참고: 개선된 프림 알고리즘"></a>참고: 개선된 프림 알고리즘</h4><ul>
<li><p>간선이 아닌 노드를 중심으로 우선순위 큐를 적용하는 방식</p>
<ul>
<li>초기화 - 정점:key 구조를 만들어놓고, 특정 정점의 key값은 0, 이외의 정점들의 key값은 무한대로 놓음.  모든 정점:key 값은 우선순위 큐에 넣음</li>
<li>가장 key값이 적은 정점:key를 추출한 후(pop 하므로 해당 정점:key 정보는 우선순위 큐에서 삭제됨), (extract min 로직이라고 부름)</li>
<li>해당 정점의 인접한 정점들에 대해 key 값과 연결된 가중치 값을 비교하여 key값이 작으면 해당 정점:key 값을 갱신<ul>
<li>정점:key 값 갱신시, 우선순위 큐는 최소 key값을 가지는 정점:key 를 루트노드로 올려놓도록 재구성함 (decrease key 로직이라고 부름)</li>
</ul>
</li>
</ul>
</li>
<li><p>개선된 프림 알고리즘 구현시 고려 사항</p>
<ul>
<li>우선순위 큐(최소힙) 구조에서, 이미 들어가 있는 데이터의 값 변경시, 최소값을 가지는 데이터를 루트노드로 올려놓도록 재구성하는 기능이 필요함</li>
<li>구현 복잡도를 줄이기 위해, heapdict 라이브러리를 통해, 해당 기능을 간단히 구현<ul>
<li>최소 heap의 루트가 팝되는 (우선순위 큐) 구조를 가짐</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapdict <span class="keyword">import</span> heapdict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    mst, keys, pi, total_weight = <span class="built_in">list</span>(), heapdict(), <span class="built_in">dict</span>(), <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph.keys():</span><br><span class="line">        keys[node] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        pi[node] = <span class="literal">None</span></span><br><span class="line">    keys[start], pi[start] = <span class="number">0</span>, start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> keys:</span><br><span class="line">        current_node, current_key = keys.popitem()</span><br><span class="line">        mst.append([pi[current_node], current_node, current_key])</span><br><span class="line">        total_weight += current_key</span><br><span class="line">        <span class="keyword">for</span> adjacent, weight <span class="keyword">in</span> mygraph[current_node].items():</span><br><span class="line">            <span class="keyword">if</span> adjacent <span class="keyword">in</span> keys <span class="keyword">and</span> weight &lt; keys[adjacent]:</span><br><span class="line">                keys[adjacent] = weight</span><br><span class="line">                pi[adjacent] = current_node</span><br><span class="line">    <span class="keyword">return</span> mst, total_weight</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mygraph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">7</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">6</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;G&#x27;</span>: <span class="number">9</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>: &#123;<span class="string">&#x27;D&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;G&#x27;</span>: <span class="number">11</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;G&#x27;</span>: &#123;<span class="string">&#x27;E&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">11</span>&#125;    </span><br><span class="line">&#125;</span><br><span class="line">mst, total_weight = prim(mygraph, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;MST:&#x27;</span>, mst)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Total Weight:&#x27;</span>, total_weight)</span><br></pre></td></tr></table></figure>
<pre><code>MST: [[&#39;A&#39;, &#39;A&#39;, 0], [&#39;A&#39;, &#39;D&#39;, 5], [&#39;D&#39;, &#39;F&#39;, 6], [&#39;A&#39;, &#39;B&#39;, 7], [&#39;D&#39;, &#39;E&#39;, 7], [&#39;E&#39;, &#39;C&#39;, 5], [&#39;E&#39;, &#39;G&#39;, 9]]
Total Weight: 39
</code></pre>
<h4 id="개선된-프림-알고리즘의-시간-복잡도-O-ElogV"><a href="#개선된-프림-알고리즘의-시간-복잡도-O-ElogV" class="headerlink" title="개선된 프림 알고리즘의 시간 복잡도: $ O(ElogV) $"></a>개선된 프림 알고리즘의 시간 복잡도: $ O(ElogV) $</h4><ul>
<li><p>최초 key 생성 시간 복잡도: $ O(V) $</p>
<ul>
<li>V : 노드의 수</li>
</ul>
</li>
<li><p>while 구문과 keys.popitem() 의 시간 복잡도는 $ O(VlogV) $</p>
<ul>
<li>while 구문은 V(노드 갯수) 번 실행됨</li>
<li>heap 에서 최소 key 값을 가지는 노드 정보 추출 시(pop)의 시간 복잡도: $ O(logV) $</li>
</ul>
</li>
<li><p>for 구문의 총 시간 복잡도는 $ O(ElogV) $</p>
<ul>
<li>for 구문은 while 구문 반복시에 결과적으로 총 최대 간선의 수 E만큼 실행 가능 $ O(E) $</li>
<li>for 구문 안에서 key값 변경시마다 heap 구조를 변경해야 하며, heap 에는 최대 V 개의 정보가 있으므로 $ O(logV) $<blockquote>
<p>일반적인 heap 자료 구조 자체에는 본래 heap 내부의 데이터 우선순위 변경시, 최소 우선순위 데이터를 루트노드로 만들어주는 로직은 없음. 이를 decrease key 로직이라고 부름, 해당 로직은 heapdict 라이브러리를 활용해서 간단히 적용가능</p>
</blockquote>
</li>
</ul>
</li>
<li><p>따라서 총 시간 복잡도는 $ O(V + VlogV + ElogV) $ 이며,</p>
<ul>
<li>O(V)는 전체 시간 복잡도에 큰 영향을 미치지 않으므로 삭제,</li>
<li>E &gt; V 이므로 (최대 $ V^2 = E $ 가 될 수 있음), $ O((V + E)logV) $ 는 간단하게 $ O(ElogV) $ 로 나타낼 수 있음</li>
</ul>
</li>
</ul>
<h2 id="백-트래킹-기법"><a href="#백-트래킹-기법" class="headerlink" title="백 트래킹 기법"></a>백 트래킹 기법</h2><p>백 트래킹 : 문제를 푸는 전략/기법<br>여러가지 경우의 수가 있는 문제에서,<br>계산하다가 조건 불만족 시 이 경우는 아니다 체크 (체크한 애들 뒤에 있는 것들은 확일 할 필요가 없음)</p>
<h3 id="1-백-트래킹-backtracking-이란"><a href="#1-백-트래킹-backtracking-이란" class="headerlink" title="1. 백 트래킹 (backtracking) 이란?"></a>1. 백 트래킹 (backtracking) 이란?</h3><ul>
<li>백트래킹 (backtracking) 또는 퇴각 검색 (backtrack)으로 부름</li>
<li>제약 조건 만족 문제 (Constraint Satisfaction Problem) 에서 해를 찾기 위한 전략<ul>
<li>해를 찾기 위해, 후보군에 제약 조건을 점진적으로 체크하다가, 해당 후보군이 제약 조건을 만족할 수 없다고 판단되는 즉시 backtrack (다시는 이 후보군을 체크하지 않을 것을 표기)하고, 바로 다른 후보군으로 넘어가며, 결국 최적의 해를 찾는 방법</li>
</ul>
</li>
<li>실제 구현시, 고려할 수 있는 모든 경우의 수 (후보군)를 상태공간트리(State Space Tree)를 통해 표현<ul>
<li>각 후보군을 DFS 방식으로 확인</li>
<li>상태 공간 트리를 탐색하면서, 제약이 맞지 않으면 해의 후보가 될만한 곳으로 바로 넘어가서 탐색<ul>
<li>Promising: 해당 루트가 조건에 맞는지를 검사하는 기법</li>
<li>Pruning (가지치기): 조건에 맞지 않으면 포기하고 다른 루트로 바로 돌아서서, 탐색의 시간을 절약하는 기법</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>즉, 백트래킹은 트리 구조를 기반으로 DFS로 깊이 탐색을 진행하면서 각 루트에 대해 조건에 부합하는지 체크(Promising), 만약 해당 트리(나무)에서 조건에 맞지않는 노드는 더 이상 DFS로 깊이 탐색을 진행하지 않고, 가지를 쳐버림 (Pruning)</p>
</blockquote>
<h4 id="상태-공간-트리-State-Space-Tree"><a href="#상태-공간-트리-State-Space-Tree" class="headerlink" title="상태 공간 트리 (State Space Tree)"></a>상태 공간 트리 (State Space Tree)</h4><ul>
<li>문제 해결 과정의 중간 상태를 각각의 노드로 나타낸 트리<img src="https://www.fun-coding.org/00_Images/statespacetree.png" width=300>

</li>
</ul>
<h3 id="2-N-Queen-문제-이해"><a href="#2-N-Queen-문제-이해" class="headerlink" title="2. N Queen 문제 이해"></a>2. N Queen 문제 이해</h3><ul>
<li>대표적인 백트래킹 문제</li>
<li>NxN 크기의 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치하는 문제</li>
<li>퀸은 다음과 같이 이동할 수 있으므로, 배치된 퀸 간에 공격할 수 없는 위치로 배치해야 함<img src="https://www.fun-coding.org/00_Images/queen_move.png">

</li>
</ul>
<h4 id="Pruning-가지치기-for-N-Queen-문제"><a href="#Pruning-가지치기-for-N-Queen-문제" class="headerlink" title="Pruning (가지치기) for N Queen 문제"></a>Pruning (가지치기) for N Queen 문제</h4><ul>
<li>한 행에는 하나의 퀸 밖에 위치할 수 없음 (퀸은 수평 이동이 가능하므로)</li>
<li>맨 위에 있는 행부터 퀸을 배치하고, 다음 행에 해당 퀸이 이동할 수 없는 위치를 찾아 퀸을 배치</li>
<li>만약 앞선 행에 배치한 퀸으로 인해, 다음 행에 해당 퀸들이 이동할 수 없는 위치가 없을 경우에는, 더 이상 퀸을 배치하지 않고, 이전 행의 퀸의 배치를 바꿈<ul>
<li>즉, 맨 위의 행부터 전체 행까지 퀸의 배치가 가능한 경우의 수를 상태 공간 트리 형태로 만든 후, 각 경우를 맨 위의 행부터 DFS 방식으로 접근, 해당 경우가 진행이 어려울 경우, 더 이상 진행하지 않고, 다른 경우를 체크하는 방식<img src="https://www.fun-coding.org/00_Images/backtracking.png">

</li>
</ul>
</li>
</ul>
<h4 id="Promising-for-N-Queen-문제"><a href="#Promising-for-N-Queen-문제" class="headerlink" title="Promising for N Queen 문제"></a>Promising for N Queen 문제</h4><ul>
<li>해당 루트가 조건에 맞는지를 검사하는 기법을 활용하여,</li>
<li>현재까지 앞선 행에서 배치한 퀸이 이동할 수 없는 위치가 있는지를 다음과 같은 조건으로 확인<ul>
<li>한 행에 어차피 하나의 퀸만 배치 가능하므로 수평 체크는 별도로 필요하지 않음<img src="https://www.fun-coding.org/00_Images/nqueen.png">

</li>
</ul>
</li>
</ul>
<h3 id="3-N-Queen-문제-파이썬-코드-작성"><a href="#3-N-Queen-문제-파이썬-코드-작성" class="headerlink" title="3. N Queen 문제 파이썬 코드 작성"></a>3. N Queen 문제 파이썬 코드 작성</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_available</span>(<span class="params">candidate, current_col</span>):</span></span><br><span class="line">    current_row = <span class="built_in">len</span>(candidate)</span><br><span class="line">    <span class="keyword">for</span> queen_row <span class="keyword">in</span> <span class="built_in">range</span>(current_row):    </span><br><span class="line">        <span class="keyword">if</span> candidate[queen_row] == current_col <span class="keyword">or</span> <span class="built_in">abs</span>(candidate[queen_row] - current_col) == current_row - queen_row:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">N, current_row, current_candidate, final_result</span>):</span></span><br><span class="line">    <span class="keyword">if</span> current_row == N:</span><br><span class="line">        final_result.append(current_candidate[:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> candidate_col <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">if</span> is_available(current_candidate, candidate_col):</span><br><span class="line">            current_candidate.append(candidate_col)</span><br><span class="line">            DFS(N, current_row + <span class="number">1</span>, current_candidate, final_result)</span><br><span class="line">            current_candidate.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_n_queens</span>(<span class="params">N</span>):</span></span><br><span class="line">    final_result = []</span><br><span class="line">    DFS(N, <span class="number">0</span>, [], final_result)</span><br><span class="line">    <span class="keyword">return</span> final_result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve_n_queens(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<pre><code>[[1, 3, 0, 2], [2, 0, 3, 1]]
</code></pre>
<h2 id="알고리즘-챕터-수강-후기"><a href="#알고리즘-챕터-수강-후기" class="headerlink" title="알고리즘 챕터 수강 후기"></a>알고리즘 챕터 수강 후기</h2><p>듣기 괴로운 내용도 있었지만 재밌게 들었습니다. 개인적으로 Dave Lee 선생님의 강의 스타일이 정말 잘 맞았다고 생각합니다. 알고리즘 한 챕터를 끝낸 김에, 수업의 장점과 단점을 써보았습니다.</p>
<p>장점!</p>
<ol>
<li><p>맥락있는 진행<br>모든 것을 단계에 걸쳐서 설명해서 방향을 잃지 않을 수 있었습니다.</p>
<ul>
<li>___란?(개요/정의) </li>
<li>왜 배우지? 어디다 쓰지? </li>
<li>어떻게 구현하지?<ul>
<li>구현에 필요한 개념</li>
<li>코드 작성</li>
</ul>
</li>
<li>복잡도는? (실용성)  </li>
</ul>
</li>
<li><p>비전공자도 배울 수 있음<br>모르는 개념 혹은 단어이다 라는게 없습니다. 앞에서 먼저 설명하고 들어갑니다.</p>
</li>
<li><p>“외우세요” 라는 말이 없음<br>이해를 기반으로 합니다.</p>
</li>
<li><p>학습효율<br>자료가 갖춰져있고, 수업 커리큘럼도 잘 짜여져 있습니다. 방대한 인터넷 자료, 유튜브 영상을 뒤질 필요가 없습니다. 일단 알고리즘 “기본 강의”인 만큼 기본기가 없는 상태에서 중요한 것만 쏙쏙 익힐 수 있다는 것 자체가 시간적으로 굉장히 절약이 된다고 생각합니다.</p>
</li>
</ol>
<p>단점!</p>
<ol>
<li>자기주도학습…..<ul>
<li>나를 믿어선 안…됨..</li>
</ul>
</li>
<li>유료<ul>
<li>but 환급받으면 나쁘지 않은 수준</li>
<li>성실성이 높으신 분이라면 유튜브 강의나 블로그를 통한 공부도 가능 할거라고 생각 합니다.</li>
</ul>
</li>
</ol>
<p>그래도 패스트 캠퍼스 완주반으로 수업을 들으면서, 환급을 위해 밀리더라도 아직까진 꾸역꾸역 들을 수 있었습니다. 앞으로도 열심히 들어서 전액 환급<del>(제세공과금22퍼 제외)</del> 받을 수 있도록 해야겠습니다!!</p>
<h3 id="앞으로의-계획"><a href="#앞으로의-계획" class="headerlink" title="앞으로의 계획"></a>앞으로의 계획</h3><ol start="0">
<li><p>완강하기</p>
</li>
<li><p>코딩 문제를 풀면서, 위 개념들을 적용해보기</p>
</li>
<li><p>과제에 나왔던 코드들을 정리해서 올리기</p>
<ul>
<li>올려도 되는지는 멘토님께 여쭤보고 올릴 예정</li>
</ul>
</li>
</ol>
<h3 id="강의에-대해-더-알아보려면"><a href="#강의에-대해-더-알아보려면" class="headerlink" title="강의에 대해 더 알아보려면"></a>강의에 대해 더 알아보려면</h3><p><a target="_blank" rel="noopener" href="https://www.fun-coding.org/">잔재미코딩</a><br><a target="_blank" rel="noopener" href="http://fastcampus.co.kr/">패스트캠퍼스 코딩+알고리즘 완주반</a> </p>
<p>출처 : <a target="_blank" rel="noopener" href="https://www.fun-coding.org/">Dave Lee</a> - Fastcampus 코딩 + 알고리즘 온라인 완주반 </p>

      
       <hr><span style="font-style: italic;color: gray;"> Thanks for reading my post. </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">Title:</span>기본 핵심 알고리즘 (정렬, 탐색)</p>
    
    <p><span class="copy-title">Author:</span><a  title="Chaejin Kim">Chaejin Kim</a></p>
    <p><span class="copy-title">Created At:</span>2021-03-02, 11:50:47</p>
    <p><span class="copy-title">Updated At:</span>2021-03-02, 11:56:16</p>
    <span class="copy-title">Url:</span><a class="post-url" href="/2021/03/02/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" title="기본 핵심 알고리즘 (정렬, 탐색)">https://chaejin-jen.github.io/2021/03/02/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</a>
    <p>
        <span class="copy-title">Copyright:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#39;Attribution-non-commercial-shared in the same way 4.0&#39;</a> Reprint please keep the original link and author.
    </p>
</div>





    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021 Chaejin Kim
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 572px;
    }
    .nav.fullscreen {
        margin-right: -572px;
    }
    .nav-left {
        width: 150px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 542px;
        }
        .nav.fullscreen {
            margin-right: -542px;
        }
        .nav-left {
            width: 150px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 542px;
            margin-right: -542px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #3390FF;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
