<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>자료구조 | Chaejin&#39;s Blog</title>
  <meta name="keywords" content=" Algorithm , Data structure ">
  <meta name="description" content="자료구조 | Chaejin&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="article">
<meta property="og:title" content="Chaejin&#39;s Blog">
<meta property="og:url" content="https://chaejin-jen.github.io/2021/04/14/test/index.html">
<meta property="og:site_name" content="Chaejin&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-14T07:36:01.609Z">
<meta property="article:modified_time" content="2021-04-14T07:36:01.609Z">
<meta property="article:author" content="Chaejin Kim">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="hide-list">
        <div class="semicircle" data-title=" close">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>Chaejin Kim</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <i class="iconfont icon-rss"></i>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/chaejin-jen"
               target="_blank">
                
                    <i class="iconfont icon-github"></i>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(9)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="Algorithm">
                        <i class="fold iconfont icon-right"></i>
                        
                        Algorithm
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Algorithm<--->Basic">
                                        
                                        Basic
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="ComputerScience">
                        <i class="fold iconfont icon-right"></i>
                        
                        ComputerScience
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="ComputerScience<--->Bagic">
                                        
                                        Bagic
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Unity">
                        
                        Unity
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="right-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="9">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="outline-panel" style="display: none">
            <div class="right-title">Outline</div>
            <i class="iconfont icon-list" data-title="카테고리"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="이전"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="대소 문자 구분"></i>
            <i class="iconfont icon-tag" data-title="태그검색"></i>
        </div>
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="검색 "></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="개요보기 "></i>
        </div>        
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm Complexity</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Big-O</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Computer Architecture</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Computer Science</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Data structure</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>OS(Operating System)</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>System Programming</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All "
           href="/2021/04/14/test/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2021-04-14 16:36:01">2021/04/14</span>
        </a>
        
        <a  class="All ComputerScience Bagic "
           href="/2021/04/12/ComputerScience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"
           data-tag="Computer Science,Computer Architecture"
           data-author="" >
            <span class="post-title" title="컴퓨터 구조">컴퓨터 구조</span>
            <span class="post-date" title="2021-04-12 10:12:00">2021/04/12</span>
        </a>
        
        <a  class="All ComputerScience Bagic "
           href="/2021/04/05/ComputerScience/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"
           data-tag="Computer Science,System Programming"
           data-author="" >
            <span class="post-title" title="시스템 프로그래밍">시스템 프로그래밍</span>
            <span class="post-date" title="2021-04-05 23:12:00">2021/04/05</span>
        </a>
        
        <a  class="All Unity "
           href="/2021/03/25/Unity/unity_bagic/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity 기본">Unity 기본</span>
            <span class="post-date" title="2021-03-25 12:03:00">2021/03/25</span>
        </a>
        
        <a  class="All Unity "
           href="/2021/03/19/Unity/unity_install/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity 설치">Unity 설치</span>
            <span class="post-date" title="2021-03-19 08:53:00">2021/03/19</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/11/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
           data-tag="Algorithm"
           data-author="" >
            <span class="post-title" title="기본 핵심 알고리즘 (정렬, 탐색)">기본 핵심 알고리즘 (정렬, 탐색)</span>
            <span class="post-date" title="2021-03-11 22:43:00">2021/03/11</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/10/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%B3%B5%EC%9E%A1%EB%8F%84/"
           data-tag="Algorithm,Algorithm Complexity,Big-O"
           data-author="" >
            <span class="post-title" title="알고리즘 복잡도">알고리즘 복잡도</span>
            <span class="post-date" title="2021-03-10 20:26:00">2021/03/10</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/08/CodeAlgorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"
           data-tag="Algorithm,Data structure"
           data-author="" >
            <span class="post-title" title="자료구조">자료구조</span>
            <span class="post-date" title="2021-03-08 19:24:00">2021/03/08</span>
        </a>
        
        <a  class="All ComputerScience Bagic "
           href="/2021/03/07/ComputerScience/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"
           data-tag="Computer Science,OS(Operating System)"
           data-author="" >
            <span class="post-title" title="운영체제">운영체제</span>
            <span class="post-date" title="2021-03-07 21:18:00">2021/03/07</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-CodeAlgorithm/자료구조" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">자료구조</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Algorithm">Algorithm</a> > 
            
            <a  data-rel="Algorithm&lt;---&gt;Basic">Basic</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">Algorithm</a>
            
            <a class="color5">Data structure</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2021-04-14 14:27:09'>2021-03-08 19:24</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%AA%A9%EC%B0%A8"><span class="toc-text">목차</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%99%9C-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%A0%EA%B9%8C"><span class="toc-text">왜 배워야 할까</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%B0%B0%EC%97%B4"><span class="toc-text">배열</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%98%A4%ED%94%84%EC%85%8B-%EC%9D%B8%EB%8D%B1%EC%8B%B1"><span class="toc-text">오프셋 인덱싱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%81%90-Queue"><span class="toc-text">큐 (Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%ED%81%90-%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D"><span class="toc-text">1. 큐 처리방식</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EC%95%8C%EC%95%84%EB%91%98-%EC%9A%A9%EC%96%B4"><span class="toc-text">2. 알아둘 용어</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%ED%8C%8C%EC%9D%B4%EC%8D%AC-queue-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC"><span class="toc-text">3. 파이썬 queue 라이브러리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-queue-Queue"><span class="toc-text">3.1. queue.Queue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-LifoQueue-%EB%A1%9C-%ED%81%90-%EB%A7%8C%EB%93%A4%EA%B8%B0-LIFO-Last-In-First-Out"><span class="toc-text">3.2. LifoQueue()로 큐 만들기 (LIFO(Last-In, First-Out))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-PriorityQueue-%EB%A1%9C-%ED%81%90-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="toc-text">3.3. PriorityQueue()로 큐 만들기</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EC%96%B4%EB%94%94%EC%97%90-%ED%81%90%EA%B0%80-%EB%A7%8E%EC%9D%B4-%EC%93%B0%EC%9D%BC%EA%B9%8C"><span class="toc-text">참고: 어디에 큐가 많이 쓰일까?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%ED%81%90-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C"><span class="toc-text">4. 큐 연습문제</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%8A%A4%ED%83%9D-Stack"><span class="toc-text">스택 (Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%EC%8A%A4%ED%83%9D-%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D"><span class="toc-text">1. 스택 처리방식</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5"><span class="toc-text">2. 주요 기능</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%EC%8A%A4%ED%83%9D%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90"><span class="toc-text">3. 스택의 장단점</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%8A%A5%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EC%8A%A4%ED%83%9D-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0"><span class="toc-text">4. 파이썬 리스트 기능에서 제공하는 메서드로 스택 사용해보기</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C"><span class="toc-text">5. 연습문제</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98"><span class="toc-text">5.1. 재귀함수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-list%EB%A1%9C-%EC%8A%A4%ED%83%9D-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B5%AC%ED%98%84"><span class="toc-text">5.2. list로 스택 다루기 구현</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-Linked-List"><span class="toc-text">링크드 리스트 (Linked List)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-Linked-List-%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D"><span class="toc-text">1. 링크드 리스트 (Linked List) 처리방식</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9A%A9%EC%96%B4"><span class="toc-text">2. 링크드 리스트 기본 구조와 용어</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84"><span class="toc-text">3. 간단한 링크드 리스트 구현</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Singly-linked-list"><span class="toc-text">3.1 Singly linked list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%EC%97%B0%EA%B2%B0-%ED%95%A8%EC%88%98-%EA%B5%AC%ED%98%84"><span class="toc-text">3.2.1 연결 함수 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B3%A0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0"><span class="toc-text">3.2.2 연결하고 확인하기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B4%ED%95%B4%EB%A5%BC-%EC%9C%84%ED%95%B4-%EA%B5%AC%EA%B0%84%EA%B5%AC%EA%B0%84-%EC%B0%8D%EC%96%B4%EB%B3%B4%EA%B8%B0"><span class="toc-text">이해를 위해 구간구간 찍어보기</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90"><span class="toc-text">4. 링크드 리스트의 장단점</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B8%B0%EB%8A%A51-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AC%EC%9D%B4%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%B6%94%EA%B0%80"><span class="toc-text">5. 링크드 리스트의 복잡한 기능1 (링크드 리스트 데이터 사이에 데이터를 추가)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9C%BC%EB%A1%9C-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0"><span class="toc-text">6. 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B8%B0%EB%8A%A52-%ED%8A%B9%EC%A0%95-%EB%85%B8%EB%93%9C%EB%A5%BC-%EC%82%AD%EC%A0%9C"><span class="toc-text">7. 링크드 리스트의 복잡한 기능2 (특정 노드를 삭제)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-head-%EC%82%AD%EC%A0%9C"><span class="toc-text">7.1. head 삭제</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%EC%A4%91%EA%B0%84-%EB%85%B8%EB%93%9C-%EB%81%9D%EB%85%B8%EB%93%9C-%EC%82%AD%EC%A0%9C"><span class="toc-text">7.2. 중간 노드, 끝노드 삭제</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C"><span class="toc-text">7.3 연습문제</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%B0%EC%8A%B51-%EB%85%B8%EB%93%9C-%EC%82%AD%EC%A0%9C"><span class="toc-text">연습1 노드 삭제</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%B0%EC%8A%B52-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B0%BE%EA%B8%B0"><span class="toc-text">연습2 데이터 찾기</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%EC%A1%B0"><span class="toc-text">8. 다양한 링크드 리스트 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C"><span class="toc-text">연습문제</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%B0%EC%8A%B53-%ED%8A%B9%EC%A0%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%9E-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EA%B0%80"><span class="toc-text">연습3 특정 데이터 앞 데이터 추가</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%B0%EC%8A%B54-%ED%8A%B9%EC%A0%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%92%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EA%B0%80"><span class="toc-text">연습4 특정 데이터 뒤 데이터 추가</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%95%B4%EC%89%AC-%ED%85%8C%EC%9D%B4%EB%B8%94-Hash-Table"><span class="toc-text">해쉬 테이블 (Hash Table)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%ED%95%B4%EC%89%AC-%EA%B5%AC%EC%A1%B0"><span class="toc-text">1. 해쉬 구조</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EC%95%8C%EC%95%84%EB%91%98-%EC%9A%A9%EC%96%B4-1"><span class="toc-text">2. 알아둘 용어</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%95%B4%EC%89%AC-%EC%98%88"><span class="toc-text">3. 간단한 해쉬 예</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-hash-table-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="toc-text">3.1. hash table 만들기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%ED%95%B4%EC%89%AC%ED%95%A8%EC%88%98-%ED%82%A4%EC%B6%94%EC%B6%9C"><span class="toc-text">3.2. 해쉬함수(키추출)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%ED%95%B4%EC%89%AC-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%A0%80%EC%9E%A5%ED%95%A8%EC%88%98"><span class="toc-text">3.3. 해쉬 테이블 저장함수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%ED%95%B4%EC%89%AC-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B0%92-%EC%B6%94%EC%B6%9C-%ED%95%A8%EC%88%98"><span class="toc-text">3.4. 해쉬 테이블 값 추출 함수</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%89%AC-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90%EA%B3%BC-%EC%A3%BC%EC%9A%94-%EC%9A%A9%EB%8F%84"><span class="toc-text">4. 자료 구조 해쉬 테이블의 장단점과 주요 용도</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C-1"><span class="toc-text">5. 연습문제</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%EC%B6%A9%EB%8F%8C-Collision-%ED%95%B4%EA%B2%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">6. 충돌(Collision) 해결 알고리즘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Chaining-%EA%B8%B0%EB%B2%95"><span class="toc-text">6.1. Chaining 기법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Linear-Probing-%EA%B8%B0%EB%B2%95"><span class="toc-text">6.2. Linear Probing 기법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%EB%B9%88%EB%B2%88%ED%95%9C-%EC%B6%A9%EB%8F%8C%EC%9D%84-%EA%B0%9C%EC%84%A0%ED%95%98%EB%8A%94-%EA%B8%B0%EB%B2%95"><span class="toc-text">6.3. 빈번한 충돌을 개선하는 기법</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%ED%95%B4%EC%89%AC-%ED%95%A8%EC%88%98%EC%99%80-%ED%82%A4-%EC%83%9D%EC%84%B1-%ED%95%A8%EC%88%98"><span class="toc-text">참고: 해쉬 함수와 키 생성 함수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A01-SHA-1"><span class="toc-text">참고1 : SHA-1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A02-SHA-256"><span class="toc-text">참고2 : SHA-256</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%EB%8F%99%EC%9D%BC%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EB%8C%80%ED%95%B4-%EB%8F%99%EC%9D%BC%ED%95%9C-hash-address%EB%A1%9C-%EA%B0%9C%EC%84%A0"><span class="toc-text">6.4. 동일한 데이터에 대해 동일한 hash address로 개선</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">7. 시간 복잡도</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B2%80%EC%83%89%EC%97%90%EC%84%9C-%ED%95%B4%EC%89%AC-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%98%88"><span class="toc-text">검색에서 해쉬 테이블의 사용 예</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%8A%B8%EB%A6%AC"><span class="toc-text">트리</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%ED%8A%B8%EB%A6%AC-Tree-%EA%B5%AC%EC%A1%B0"><span class="toc-text">1. 트리 (Tree) 구조</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EC%95%8C%EC%95%84%EB%91%98-%EC%9A%A9%EC%96%B4-2"><span class="toc-text">2. 알아둘 용어</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-Binary-Search-Tree"><span class="toc-text">3. 이진 트리와 이진 탐색 트리 (Binary Search Tree)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EC%A3%BC%EC%9A%94-%EC%9A%A9%EB%8F%84"><span class="toc-text">4. 자료 구조 이진 탐색 트리의 장점과 주요 용도</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%A0%95%EB%A0%AC%EB%90%9C-%EB%B0%B0%EC%97%B4%EA%B0%84%EC%9D%98-%ED%83%90%EC%83%89-%EB%B9%84%EA%B5%90"><span class="toc-text">이진트리와 정렬된 배열간의 탐색 비교</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9C%BC%EB%A1%9C-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0"><span class="toc-text">5. 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%EB%85%B8%EB%93%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0"><span class="toc-text">5.1. 노드 클래스 만들기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%84%A3%EA%B8%B0"><span class="toc-text">5.2. 이진 탐색 트리에 데이터 넣기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%ED%83%90%EC%83%89"><span class="toc-text">5.3. 이진 탐색 트리 탐색</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EC%82%AD%EC%A0%9C"><span class="toc-text">5.4. 이진 탐색 트리 삭제</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-Leaf-Node-%EC%82%AD%EC%A0%9C"><span class="toc-text">5.4.1. Leaf Node 삭제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Child-Node-%EA%B0%80-%ED%95%98%EB%82%98%EC%9D%B8-Node-%EC%82%AD%EC%A0%9C"><span class="toc-text">5.4.2. Child Node 가 하나인 Node 삭제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-Child-Node-%EA%B0%80-%EB%91%90-%EA%B0%9C%EC%9D%B8-Node-%EC%82%AD%EC%A0%9C"><span class="toc-text">5.4.3. Child Node 가 두 개인 Node 삭제</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-1-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EC%9D%98-%EC%98%A4%EB%A5%B8%EC%AA%BD-%EC%9E%90%EC%8B%9D%EC%A4%91-%EA%B0%80%EC%9E%A5-%EC%9E%91%EC%9D%80-%EA%B0%92%EC%9D%84-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EC%9D%98-Parent-Node%EA%B0%80-%EA%B0%80%EB%A6%AC%ED%82%A4%EA%B2%8C-%ED%95%A0-%EA%B2%BD%EC%9A%B0"><span class="toc-text">5.4.3.1. 삭제할 Node의 오른쪽 자식중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키게 할 경우</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EC%82%AD%EC%A0%9C-%EC%BD%94%EB%93%9C-%EA%B5%AC%ED%98%84%EA%B3%BC-%EB%B6%84%EC%84%9D"><span class="toc-text">5.5. 이진 탐색 트리 삭제 코드 구현과 분석</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%EC%82%AD%EC%A0%9C%ED%95%A0-Node-%ED%83%90%EC%83%89"><span class="toc-text">5.5.1 삭제할 Node 탐색</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-Case1-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EA%B0%80-Leaf-Node%EC%9D%B8-%EA%B2%BD%EC%9A%B0"><span class="toc-text">5.5.2. Case1: 삭제할 Node가 Leaf Node인 경우</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-Case2-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EA%B0%80-Child-Node%EB%A5%BC-%ED%95%9C-%EA%B0%9C-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EC%9D%84-%EA%B2%BD%EC%9A%B0"><span class="toc-text">5.5.2. Case2: 삭제할 Node가 Child Node를 한 개 가지고 있을 경우</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-Case3-1-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EA%B0%80-Child-Node%EB%A5%BC-%EB%91%90-%EA%B0%9C-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EC%9D%84-%EA%B2%BD%EC%9A%B0-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EA%B0%80-Parent-Node-%EC%99%BC%EC%AA%BD%EC%97%90-%EC%9E%88%EC%9D%84-%EB%95%8C"><span class="toc-text">5.5.3. Case3-1: 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 왼쪽에 있을 때)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-4-Case3-2-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EA%B0%80-Child-Node%EB%A5%BC-%EB%91%90-%EA%B0%9C-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EC%9D%84-%EA%B2%BD%EC%9A%B0-%EC%82%AD%EC%A0%9C%ED%95%A0-Node%EA%B0%80-Parent-Node-%EC%98%A4%EB%A5%B8%EC%AA%BD%EC%97%90-%EC%9E%88%EC%9D%84-%EB%95%8C"><span class="toc-text">5.5.4. Case3-2: 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 오른쪽에 있을 때)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-5-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C-%EA%B5%AC%ED%98%84"><span class="toc-text">5.5.5. 파이썬 전체 코드 구현</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-6-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8"><span class="toc-text">5.5.6. 파이썬 전체 코드 테스트</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-%EB%8B%A8%EC%A0%90"><span class="toc-text">6. 이진 탐색 트리의 시간 복잡도와 단점</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%ED%83%90%EC%83%89%EC%8B%9C"><span class="toc-text">6.1. 시간 복잡도 (탐색시)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EB%8B%A8%EC%A0%90"><span class="toc-text">6.2. 이진 탐색 트리 단점</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%9E%99"><span class="toc-text">힙</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%ED%9E%99-Heap-%EC%9D%B4%EB%9E%80"><span class="toc-text">1. 힙 (Heap) 이란?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%ED%9E%99-Heap-%EC%A2%85%EB%A5%98-%EC%A1%B0%EA%B1%B4"><span class="toc-text">2. 힙 (Heap) 종류, 조건</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%9E%99%EA%B3%BC-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EA%B3%B5%ED%86%B5%EC%A0%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4%EC%A0%90"><span class="toc-text">힙과 이진 탐색 트리의 공통점과 차이점</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%ED%9E%99-Heap-%EB%8F%99%EC%9E%91"><span class="toc-text">3. 힙 (Heap) 동작</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%9E%99%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91"><span class="toc-text">힙에 데이터 삽입하기 - 기본 동작</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%9E%99%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0-%EC%82%BD%EC%9E%85%ED%95%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%9E%99%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B3%B4%EB%8B%A4-%ED%81%B4-%EA%B2%BD%EC%9A%B0-Max-Heap-%EC%9D%98-%EC%98%88"><span class="toc-text">힙에 데이터 삽입하기 - 삽입할 데이터가 힙의 데이터보다 클 경우 (Max Heap 의 예)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%9E%99%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0-Max-Heap-%EC%9D%98-%EC%98%88"><span class="toc-text">힙의 데이터 삭제하기 (Max Heap 의 예)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%ED%9E%99-%EA%B5%AC%ED%98%84"><span class="toc-text">4. 힙 구현</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%9E%99%EA%B3%BC-%EB%B0%B0%EC%97%B4"><span class="toc-text">힙과 배열</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Max-Heap-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%BD%EC%9E%85-%EA%B5%AC%ED%98%84"><span class="toc-text">Max Heap 데이터 삽입 구현</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Max-Heap-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AD%EC%A0%9C-%EA%B5%AC%ED%98%84"><span class="toc-text">Max Heap 데이터 삭제 구현</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%ED%9E%99-Heap-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84"><span class="toc-text">5. 힙 (Heap) 시간 복잡도</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%B4-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EB%A0%A4%EB%A9%B4"><span class="toc-text">강의에 대해 더 알아보려면</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>이 글은 자료구조를 알고계시는 분들이 <code>Ctrl+f</code> 또는 오른쪽에 위치한 <code>목차(단축키w)</code>로 헷갈리는 것을 찾아보기에 적합합니다.</p>
<p>모든 내용의 출처는 <a target="_blank" rel="noopener" href="https://www.fun-coding.org/">Dave Lee 선생님의 사이트</a>에 있음을 밝히며, 단기간에 끝내고자 하신다면 강의 들으시는 것을 추천 드립니다. (+ 강의 수강 시 아래 내용이, ipynb 파일로 제공됩니다.)</p>
<p>출처 : fastcampus 코딩 + 알고리즘 온라인 완주반</p>
<hr>
<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><p><code>w/W</code> : <strong>글 목차 확인</strong> 또는 글 목록 보기<br><code>s/S</code> : <strong>디렉토리 숨기기</strong> 또는 열기</p>
<hr>
<h1 id="왜-배워야-할까"><a href="#왜-배워야-할까" class="headerlink" title="왜 배워야 할까"></a>왜 배워야 할까</h1><blockquote>
<p>성능!! 아래 그냥 스킵 가능</p>
</blockquote>
<p>현실세계의 데이터를 컴퓨터로 옮기는 과정에서 어떤 데이터 구조를 사용하는지에 따라, 코드 효율이 달라짐</p>
<p>예시</p>
<blockquote>
<p>   우편번호 : 5자리 우편번호, 3자리는 시, 군, 자치구를 표기, 뒤 2자리는 일련번호로 구성<br>   학번 : 입학년도, 학과, 이름순 번호</p>
</blockquote>
<p>대표적인 자료구조</p>
<blockquote>
<p>   배열, 스택, 큐, 링크드 리스트, 해쉬 테이블, 힙 등</p>
</blockquote>
<p>알고리즘 이란?</p>
<blockquote>
<p>   문제를 풀기위한 절차/방법<br>   문제에 대해 <code>특정 입력 -&gt; 원하는 출력</code> 을 얻을 수 있도록 만드는 프로그래밍</p>
</blockquote>
<p>자료구조, 알고리즘 중요한 이유</p>
<blockquote>
<p>   성능!!!</p>
</blockquote>
<p>대표적인 자료 구조<br>배열, 큐, 스택, 링크드 리스트, 해쉬 테이블, 힙</p>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.png"></p>
<details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > 자세한 설명 </summary>
  <div>
     
    1. 단순구조(Simple Structure)
        
        자료값을 사용하기 위한 기본 형태
    
        C/C++, Python, Java와 같은 프로그래밍 언어에서 제공하는 정수(Integer), 실수(Real Number), 문자(Character), 문자열(String)등의 자료형(Data Type)
    
    2. 선형구조(Linear Structure)

<pre><code>    자료들간의 관계가 1:1인 자료
    
    순차리스트(Sequential List), 연결리스트(Linked List), 스택(Stack), 큐(Queue), 데크(Deque)등

3. 비선형구조(Nonlinear Structure)

    계층구조(Hierarchy)나 망구조(Network Structure)를 갖는 자료구조
    
    트리(Tree)와 그래프(Graph)

4. 파일구조(File Structure)

    파일에 대한 자료구조
    
    파일 : 서로 관련있는 필드(Field)로 구성된 레코드(Record)집합


    보조 기억장치에 데이터가 실제로 기록되는 형태

    파일의 구성 방식에 따라 순차파일(Sequential File), 색인파일(Index File), 직접파일(Direct File)등이 있다.

    
</code></pre>
  </div>
</details>

<p>출처 : <a target="_blank" rel="noopener" href="https://0verc10ck.tistory.com/1?category=783947">https://0verc10ck.tistory.com/1?category=783947</a></p>
<hr>
<h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><p>시작주소를 알면, 그 다음에 있던 5개 뒤에 있던, 바로바로 찾아갈 수 있다!</p>
<table>
<thead>
<tr>
<th>데이터</th>
<th>S</th>
<th>T</th>
<th>R</th>
<th>I</th>
<th>N</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>인덱스(index)</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<h2 id="오프셋-인덱싱"><a href="#오프셋-인덱싱" class="headerlink" title="오프셋 인덱싱"></a>오프셋 인덱싱</h2><ul>
<li>offset index : 특정 위치의 데이터를 출력할때 사용<ul>
<li>interable한 데이터 타입에서만 사용이 가능 (string, list, tuple, byte 등의 Sequences)</li>
<li>[] : mask, masking</li>
<li>[idx] : idx 위치 데이터 출력</li>
<li>[start:end] : start에서 end-1까지 출력</li>
<li>[시작:끝:stride] : stride 만큼씩 점프하여 출력</li>
</ul>
</li>
<li>예시<ul>
<li>[::2] : stride 2칸씩 뛰어서</li>
<li>[::-1] : 맨 뒤에서 1칸씩 뛰어서 = 역정렬<pre><code class="python">g = &quot;abcdefg&quot;
g[2], g[-2], g[2:5], g[:2], g[3:], g[-2:], g[::2]
</code></pre>
<blockquote>
<p>(‘c’, ‘f’, ‘cde’, ‘ab’, ‘defg’, ‘fg’, ‘aceg’)</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="큐-Queue"><a href="#큐-Queue" class="headerlink" title="큐 (Queue)"></a>큐 (Queue)</h1><p>FIFO</p>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/queue.png" alt="queue"></p>
<p>출처: <a target="_blank" rel="noopener" href="http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/">http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/</a></p>
<h2 id="1-큐-처리방식"><a href="#1-큐-처리방식" class="headerlink" title="1. 큐 처리방식"></a>1. 큐 처리방식</h2><ul>
<li><strong>줄을 서는 행위와 유사</strong></li>
<li>큐 처리방식  (큐잉 정책, Queuing Policy)<br>  ※ <code>입력/출력(삽입/삭제) 발생 순서에 대한 정책</code>에 따라 여러 큐잉 형태 가능</li>
</ul>
<ul>
<li><p>스택과 꺼내는 순서가 반대</p>
</li>
<li><p><strong>FIFO</strong> (First In First Out, 선입선출) <code>default</code></p>
<ul>
<li>먼저 입력된 것이 먼저 출력되는 형태</li>
<li>가장 단순한 방법으로, 단지 큐라고하면 보통 이런 형태를 일컬음</li>
</ul>
</li>
<li><p><strong>FILO</strong> (First In Last Out, 선입후출)</p>
<ul>
<li>FIFO와는 반대의 개념</li>
<li>Stack, LIFO</li>
</ul>
</li>
<li><p><strong>LILO</strong> (Last In First Out Queue, 후입선출) </p>
<ul>
<li>마지막 입력되는 것이 먼저 출력됨</li>
<li>한쪽끝에서만 삽입 삭제됨</li>
<li>스택(Stack) 참조</li>
</ul>
</li>
<li><p><strong>PQ</strong> (Priority Queuing, 우선순위 큐)</p>
<ul>
<li>우선순위에 따라 각 큐를 차별적 관리<br>. 임의 순서로 삽입되나(입력/추가), 일정 순서로 삭제됨(출력/제거)</li>
</ul>
</li>
<li><p>FQ (Fair Queuing, 공정 큐잉)</p>
<ul>
<li>각 큐를 공정하게 라운드로빈 방식으로 서비스함</li>
<li>multiprocessing을 위해 사용</li>
</ul>
</li>
<li><p>WFQ (Weighted Fair Queuing)</p>
<ul>
<li>각 큐에 어떤 가중값이 할당되는 FQ의 변형된 방식</li>
<li>network scheduling algorithm</li>
</ul>
</li>
<li><p>CQ (Custom Queuing, 맞춤예약 큐잉)</p>
</li>
<li><p>CB-WFQ (Class-Based Weighted Fair Queuing)</p>
  <!-- - 4, 5, 8 을 순서대로 넣으면?
      |순서|input| | | | | | |Output|
      |:-:|---|---|---|---|---|---|---|---|
      |처음|
      |1|| | | | | | 4||
      |2|| | | | | 5| 4||
      |3|| | | | 8| 5| 4||
  - 하나씩 출력하면
      |순서|input| | | | | | |Output|
      |:-:|---|---|---|---|---|---|---|:---:|
      |처음|| | | | 8| 5| 4||
      |1|| | | | | 8| 5|4|
      |2|||| | | | 8| 5|
      |3||||| | | | 8| -->

</li>
</ul>
<h2 id="2-알아둘-용어"><a href="#2-알아둘-용어" class="headerlink" title="2. 알아둘 용어"></a>2. 알아둘 용어</h2><ul>
<li><strong>Enqueue</strong> : 큐에 데이터를 넣는 기능</li>
<li><strong>Dequeue</strong> : 큐에서 데이터를 꺼내는 기능</li>
</ul>
<ul>
<li>Peek : 큐 자료 접근(자료 제거가 아닌 반환 만)<ul>
<li>Front/Head : 처음/전단 자료</li>
<li>Rear/Tail : 마지막/후단 자료</li>
</ul>
</li>
</ul>
<h2 id="3-파이썬-queue-라이브러리"><a href="#3-파이썬-queue-라이브러리" class="headerlink" title="3. 파이썬 queue 라이브러리"></a>3. 파이썬 queue 라이브러리</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.python.org/ko/3.9/library/queue.html">Doc</a> -  <a target="_blank" rel="noopener" href="https://github.com/python/cpython/tree/3.9/Lib/queue.py">Lib/queue.py</a></p>
</li>
<li><p>queue 라이브러리에는 다양한 큐 구조로 Queue(), LifoQueue(), PriorityQueue() 제공</p>
<ul>
<li><code>Queue()</code> : 가장 일반적인 큐 자료 구조</li>
<li><code>LifoQueue()</code> : 나중에 입력된 데이터가 먼저 출력되는 구조 (스택 구조라고 보면 됨)</li>
<li><code>PriorityQueue()</code> : 데이터마다 우선순위를 넣어서, 우선순위가 높은 순으로 데이터 출력</li>
</ul>
<h3 id="3-1-queue-Queue"><a href="#3-1-queue-Queue" class="headerlink" title="3.1. queue.Queue()"></a>3.1. queue.Queue()</h3><p>가장 일반적인 큐, FIFO(First-In, First-Out)</p>
</li>
</ul>
<pre><code class="python">import queue

data_queue = queue.Queue()

data_queue.put(&quot;funcoding&quot;)
data_queue.put(1)

data_queue.qsize()
</code></pre>
<pre><code class="python">data_queue.get()

data_queue.qsize()
</code></pre>
<pre><code class="python">data_queue.get()

data_queue.qsize()
</code></pre>
<h3 id="3-2-LifoQueue-로-큐-만들기-LIFO-Last-In-First-Out"><a href="#3-2-LifoQueue-로-큐-만들기-LIFO-Last-In-First-Out" class="headerlink" title="3.2. LifoQueue()로 큐 만들기 (LIFO(Last-In, First-Out))"></a>3.2. LifoQueue()로 큐 만들기 (LIFO(Last-In, First-Out))</h3><pre><code class="python">import queue
data_queue = queue.LifoQueue()

data_queue.put(&quot;funcoding&quot;)
data_queue.put(1)

data_queue.qsize()
</code></pre>
<pre><code class="python">data_queue.get()
</code></pre>
<h3 id="3-3-PriorityQueue-로-큐-만들기"><a href="#3-3-PriorityQueue-로-큐-만들기" class="headerlink" title="3.3. PriorityQueue()로 큐 만들기"></a>3.3. PriorityQueue()로 큐 만들기</h3><pre><code class="python">import queue

data_queue = queue.PriorityQueue()

data_queue.put((10, &quot;korea&quot;))
data_queue.put((5, 1))
data_queue.put((15, &quot;china&quot;))

data_queue.qsize()
</code></pre>
<pre><code class="python">data_queue.get()
</code></pre>
<pre><code class="python">data_queue.get()
</code></pre>
<h2 id="참고-어디에-큐가-많이-쓰일까"><a href="#참고-어디에-큐가-많이-쓰일까" class="headerlink" title="참고: 어디에 큐가 많이 쓰일까?"></a>참고: 어디에 큐가 많이 쓰일까?</h2><p>멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨 (운영체제 참조)<br>큐의 경우에는 장단점 보다는 (특별히 언급되는 장단점이 없음), 큐의 활용 예로 프로세스 스케쥴링 방식을 함께 이해해두는 것이 좋음</p>
<h2 id="4-큐-연습문제"><a href="#4-큐-연습문제" class="headerlink" title="4. 큐 연습문제"></a>4. 큐 연습문제</h2><p>연습1: 리스트 변수로 큐를 다루는 enqueue, dequeue 기능 구현해보기</p>
<pre><code class="python">queue_list = list()

def enqueue(data):
    queue_list.append(data)
    
def dequeue():
    data = queue_list[0]
    del queue_list[0]
    return data
</code></pre>
<pre><code class="python">for index in range(10):
    enqueue(index)

len(queue_list)
</code></pre>
<pre><code class="python">dequeue()
</code></pre>
<h1 id="스택-Stack"><a href="#스택-Stack" class="headerlink" title="스택 (Stack)"></a>스택 (Stack)</h1><p><strong>LIFO</strong></p>
<ul>
<li><p>데이터를 제한적으로 접근할 수 있는 구조</p>
</li>
<li><p>한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조</p>
</li>
<li><p>가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조</p>
</li>
<li><p>대표적인 스택의 활용</p>
<ul>
<li>컴퓨터 내부의 프로세스 구조의 함수 동작 방식<h2 id="1-스택-처리방식"><a href="#1-스택-처리방식" class="headerlink" title="1. 스택 처리방식"></a>1. 스택 처리방식</h2>스택은 LIFO(Last In, Fisrt Out) 또는 FILO(First In, Last Out) 데이터 관리 방식을 따름</li>
</ul>
</li>
<li><p>LIFO: 마지막에 넣은 데이터를 가장 먼저 추출하는 데이터 관리 정책</p>
</li>
<li><p>FILO: 처음에 넣은 데이터를 가장 마지막에 추출하는 데이터 관리 정책</p>
</li>
</ul>
<h2 id="2-주요-기능"><a href="#2-주요-기능" class="headerlink" title="2. 주요 기능"></a>2. 주요 기능</h2><ul>
<li><p>push(): 데이터를 스택에 넣기</p>
</li>
<li><p>pop(): 데이터를 스택에서 꺼내기</p>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/stack.png" alt="stack"></p>
</li>
</ul>
<h2 id="3-스택의-장단점"><a href="#3-스택의-장단점" class="headerlink" title="3. 스택의 장단점"></a>3. 스택의 장단점</h2><ul>
<li>장점<ul>
<li>구조가 단순해서, 구현이 쉽다.</li>
<li>데이터 저장/읽기 속도가 빠르다.</li>
</ul>
</li>
<li>단점 (일반적인 스택 구현시)<ul>
<li>데이터 최대 갯수를 미리 정해야 한다.</li>
<li>파이썬의 경우 재귀 함수는 <strong>1000번</strong>까지만 호출이 가능함</li>
<li>저장 공간의 낭비가 발생할 수 있음</li>
<li>미리 최대 갯수만큼 저장 공간을 확보해야 함</li>
<li>스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적임. 이 경우, 위에서 열거한 단점이 있을 수 있음</li>
</ul>
</li>
</ul>
<h2 id="4-파이썬-리스트-기능에서-제공하는-메서드로-스택-사용해보기"><a href="#4-파이썬-리스트-기능에서-제공하는-메서드로-스택-사용해보기" class="headerlink" title="4. 파이썬 리스트 기능에서 제공하는 메서드로 스택 사용해보기"></a>4. 파이썬 리스트 기능에서 제공하는 메서드로 스택 사용해보기</h2><p>append(push), pop 메서드</p>
<pre><code class="python">data_stack = list()
data_stack.append(1)
data_stack.append(2)
data_stack
</code></pre>
<pre><code class="python">
data_stack.pop()
</code></pre>
<h2 id="5-연습문제"><a href="#5-연습문제" class="headerlink" title="5. 연습문제"></a>5. 연습문제</h2><h3 id="5-1-재귀함수"><a href="#5-1-재귀함수" class="headerlink" title="5.1. 재귀함수"></a>5.1. 재귀함수</h3><p>스택 구조와 프로세스 스택<br>스택 구조는 프로세스 실행 구조의 가장 기본<br>함수 호출시 프로세스 실행 구조를 스택과 비교해서 이해 필요</p>
<pre><code class="python"># 재귀 함수
def recursive(data):
    if data &lt; 0:
        print (&quot;ended&quot;)
    else:
        print(data)
        recursive(data - 1)
        print(&quot;returned&quot;, data)        
</code></pre>
<pre><code class="python">recursive(4)
</code></pre>
<h3 id="5-2-list로-스택-다루기-구현"><a href="#5-2-list로-스택-다루기-구현" class="headerlink" title="5.2. list로 스택 다루기 구현"></a>5.2. list로 스택 다루기 구현</h3><p>리스트 변수로 스택을 다루는 pop, push 기능 구현해보기 (pop, push 함수 사용하지 않고 직접 구현해보기)</p>
<pre><code class="python">stack_list = list()

def push(data):
    stack_list.append(data)

def pop():
    data = stack_list[-1]
    del stack_list[-1]
    return data
</code></pre>
<pre><code class="python">for index in range(10):
    push(index)
pop()
</code></pre>
<p>쉬어가기: stacks are everywhere</p>
<h1 id="링크드-리스트-Linked-List"><a href="#링크드-리스트-Linked-List" class="headerlink" title="링크드 리스트 (Linked List)"></a>링크드 리스트 (Linked List)</h1><h2 id="1-링크드-리스트-Linked-List-처리방식"><a href="#1-링크드-리스트-Linked-List-처리방식" class="headerlink" title="1. 링크드 리스트 (Linked List) 처리방식"></a>1. 링크드 리스트 (Linked List) 처리방식</h2><ul>
<li>연결 리스트라고도 함</li>
<li>C언어의 주요한 데이터 구조, 파이썬에선 리스트 타입이 링크드 리스트의 기능을 모두 지원</li>
<li>링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조<ul>
<li>이것이 갖는 의의 : 배열 단점 보완<ul>
<li>배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조</li>
<li>배열은 <strong>미리</strong> 공간을 예약할 필요가 있지만, 링크드 리스트는 <strong>필요할 때 마다</strong> 공간을 연결함</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-링크드-리스트-기본-구조와-용어"><a href="#2-링크드-리스트-기본-구조와-용어" class="headerlink" title="2. 링크드 리스트 기본 구조와 용어"></a>2. 링크드 리스트 기본 구조와 용어</h2><ul>
<li>노드(Node): 데이터 저장 단위 (데이터값, 포인터) 로 구성</li>
<li>포인터(pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간<ul>
<li>파이썬으로 치면 레퍼런스를 갖고 있나?</li>
</ul>
</li>
</ul>
<ul>
<li>일반적인 링크드 리스트 형태<img src="https://www.fun-coding.org/00_Images/linkedlist.png" />
(출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)


</li>
</ul>
<h2 id="3-간단한-링크드-리스트-구현"><a href="#3-간단한-링크드-리스트-구현" class="headerlink" title="3. 간단한 링크드 리스트 구현"></a>3. 간단한 링크드 리스트 구현</h2><p>아래 사진을 참고하여 파이썬에서 클래스와 레퍼런스를 활용해 링크드 리스트를 구현해보자!<br><img src="https://www.w3schools.in/wp-content/uploads/2016/09/Singly-Linked-List.png" /></p>
<p>(출처: <a target="_blank" rel="noopener" href="https://www.w3schools.in/data-structures-tutorial/linked-list/">https://www.w3schools.in/data-structures-tutorial/linked-list/</a>)</p>
<h3 id="3-1-Singly-linked-list"><a href="#3-1-Singly-linked-list" class="headerlink" title="3.1 Singly linked list"></a>3.1 Singly linked list</h3><p>위 그림의 Singly linked list 를 클래스로 나타내면 다음과 같다.</p>
<blockquote>
<p>data(그림에선 10)가 담기는 칸을 인스턴스변수 data,</p>
<p>$\emptyset$를 가르키는 칸을 인스턴스변수 next로 표현했다.</p>
</blockquote>
<pre><code class="python">class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
node = Node(10)
print(node.data, node.next)
</code></pre>
<h3 id="3-2-1-연결-함수-구현"><a href="#3-2-1-연결-함수-구현" class="headerlink" title="3.2.1 연결 함수 구현"></a>3.2.1 연결 함수 구현</h3><p>위 사진의 A Singly linked list populated with integeres 를 구현하기 위해선,<br><strong>인스턴스 변수 next가 다음에 이어질 데이터를 가르켜야한다</strong>.<br>즉, 인스턴스 변수 next에 다른 객체의 레퍼런스를 넣어줘야한다.</p>
<p>사진을 예로들면 Node(1).next 에 Node(45), Node(45).next엔 Node(60), Node(60).next엔 Node(12)가 들어가는 것과 같다.</p>
<p>마지막 노드에 새로운 노드를 연결하는 함수 add 를 구현하면 다음과 같다.</p>
<pre><code class="python">def add(head, data):
    node = head
    while node.next:
        node = node.next
    node.next = Node(data) 

node1 = Node(1)
head = node1 # 맨앞에 있는 head 주소를 유지하기 위함
print(node1.data, node1.next)
add(head, 45)

node = head
print(node.data, node.next)
print(node.next.data, node.next.next)
</code></pre>
<ul>
<li>while node.next 해석<ul>
<li>node.next == None, 즉, Tail에 다다를 때 까지 node를 넘긴다.</li>
</ul>
</li>
<li>node.next = Node(data)<ul>
<li>Tail의 인스턴스 변수 next가 이어주고자 하는 객체를 가르키게 한다.</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-연결하고-확인하기"><a href="#3-2-2-연결하고-확인하기" class="headerlink" title="3.2.2 연결하고 확인하기"></a>3.2.2 연결하고 확인하기</h3><pre><code class="python"># 객체 선언 (head 부위)
node1 = Node(1)
head = node1
for data in [45,60,12]:
    # 연결
    add(head, data)
# 링크드 리스트 데이터 출력
node = head
while node.next:
    print(node.data)
    node = node.next
print (node.data)
</code></pre>
<h3 id="이해를-위해-구간구간-찍어보기"><a href="#이해를-위해-구간구간-찍어보기" class="headerlink" title="이해를 위해 구간구간 찍어보기"></a>이해를 위해 구간구간 찍어보기</h3><p>1~9 링크드 리스트 만들기 (3.1, 3.2 를 다 이해했으면 그냥 넘기기)</p>
<pre><code class="python"># class Node:
#     def __init__(self, data, next=None):
#         self.data = data
#         self.next = next

# def add(head, data):
#     node = head
#     print(&quot;Before Add : node = node.next&quot;)
#     if node.next==None:
#         print(&quot;     node : &quot;, node.data, node.next)
#     else:
#         while node.next:
#             print(&quot;     node      : &quot;, node.data, node.next)
#             print(&quot;     node.next : &quot;, node.next.data, node.next.next)
#             node = node.next
#     node.next = Node(data) 
#     print(&#39;\nAfter Add : node.next = Node(data)&#39;)
#     print(&quot;     new node  : &quot;, node.data, node.next)
#     print(&quot;     node.next : &quot;, node.next.data, node.next.next)
#     print(&#39;\n&#39;+&#39;-&#39;*55+&#39;\n&#39;)

# node1 = Node(1)
# head = node1
# for data in range(2, 10):
#     add(head, data)
</code></pre>
<h2 id="4-링크드-리스트의-장단점"><a href="#4-링크드-리스트의-장단점" class="headerlink" title="4. 링크드 리스트의 장단점"></a>4. 링크드 리스트의 장단점</h2><p>전통적인 C언어에서본 링크드 리스트의 장단점은 다음과 같다.</p>
<ul>
<li>장점<ul>
<li>미리 데이터 공간을 미리 할당하지 않아도 됨<ul>
<li>배열은 <strong>미리 데이터 공간을 할당</strong> 해야 함</li>
</ul>
</li>
</ul>
</li>
<li>단점<ul>
<li><strong>연결을 위한 별도 데이터 공간이 필요</strong>하므로, 저장공간 효율이 높지 않음</li>
<li>연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림</li>
<li>중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요</li>
</ul>
</li>
</ul>
<h2 id="5-링크드-리스트의-복잡한-기능1-링크드-리스트-데이터-사이에-데이터를-추가"><a href="#5-링크드-리스트의-복잡한-기능1-링크드-리스트-데이터-사이에-데이터를-추가" class="headerlink" title="5. 링크드 리스트의 복잡한 기능1 (링크드 리스트 데이터 사이에 데이터를 추가)"></a>5. 링크드 리스트의 복잡한 기능1 (링크드 리스트 데이터 사이에 데이터를 추가)</h2><ul>
<li>링크드 리스트는 유지 관리에 부가적인 구현이 필요함</li>
</ul>
<img src="https://www.fun-coding.org/00_Images/linkedlistadd.png" />
(출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)

<pre><code class="python">node = head
while node.next:
    print(node.data)
    node = node.next
print (node.data)
</code></pre>
<p>4, 5사이에 4.5를 넣어보자!</p>
<pre><code class="python"># data 4.5를 가진 node 만들기
node3 = Node(4.5)
</code></pre>
<pre><code class="python">search = True
while search:
    if node.data == 4:
        # node.data 4 가 되면, search 를 중지
        search = False
    else:
        node = node.next
# node.next 갈아껴주기
temp_next = node.next
node.next = node3
node3.next = temp_next
</code></pre>
<pre><code class="python">node = head
while node.next:
    print(node.data)
    node = node.next
print (node.data)
</code></pre>
<h2 id="6-파이썬-객체지향-프로그래밍으로-링크드-리스트-구현하기"><a href="#6-파이썬-객체지향-프로그래밍으로-링크드-리스트-구현하기" class="headerlink" title="6. 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기"></a>6. 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기</h2><p>가장 앞단을 head를 인스턴스변수로 갖는 NodeMgmt</p>
<pre><code class="python">class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
    
class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        
    def add(self, data):
        if self.head == &#39;&#39;:
            self.head = Node(data)
        else:
            node = self.head
            while node.next:
                node = node.next
            node.next = Node(data)
        
    def desc(self):
        node = self.head
        while node:
            print (node.data)
            node = node.next
</code></pre>
<pre><code class="python">linkedlist1 = NodeMgmt(0)
linkedlist1.desc()
</code></pre>
<pre><code class="python">for data in range(1, 10):
    linkedlist1.add(data)
linkedlist1.desc()
</code></pre>
<h2 id="7-링크드-리스트의-복잡한-기능2-특정-노드를-삭제"><a href="#7-링크드-리스트의-복잡한-기능2-특정-노드를-삭제" class="headerlink" title="7. 링크드 리스트의 복잡한 기능2 (특정 노드를 삭제)"></a>7. 링크드 리스트의 복잡한 기능2 (특정 노드를 삭제)</h2><ul>
<li>다음 코드는 위의 코드에서 delete 메서드만 추가한 것이므로 해당 메서드만 확인하면 됨</li>
</ul>
<pre><code class="python">class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
    
class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        
    def add(self, data):
        if self.head == &#39;&#39;:
            self.head = Node(data)
        else:
            node = self.head
            while node.next:
                node = node.next
            node.next = Node(data)
        
    def desc(self):
        node = self.head
        while node:
            print (node.data)
            node = node.next
    
    def delete(self, data):
        if self.head == &#39;&#39;:
            print (&quot;해당 값을 가진 노드가 없습니다.&quot;)
            return
        
        # head 삭제시
        if self.head.data == data:
            temp = self.head
            self.head = self.head.next
            del temp
        else:
            node = self.head
            while node.next:
                # 중간, 마지막 노드 삭제시
                if node.next.data == data:
                    temp = node.next
                    node.next = node.next.next
                    del temp
                    return
                # 찾는 노드가 아닐 시 다음노드 살피기
                else:
                    node = node.next
</code></pre>
<h3 id="7-1-head-삭제"><a href="#7-1-head-삭제" class="headerlink" title="7.1. head 삭제"></a>7.1. head 삭제</h3><p>테스트를 위해 1개 노드를 만들어 봄</p>
<pre><code class="python">linkedlist1 = NodeMgmt(0)
linkedlist1.desc()
</code></pre>
<p>head 가 살아있음을 확인</p>
<pre><code class="python">linkedlist1.head
</code></pre>
<p>head 를 지워봄(위에서 언급한 경우의 수1)</p>
<pre><code class="python">linkedlist1.delete(0)
</code></pre>
<blockquote>
<p>다음 코드 실행시 아무것도 안나온다는 것은 linkedlist1.head 가 정상적으로 삭제되었음을 의미</p>
</blockquote>
<pre><code class="python">linkedlist1.head
</code></pre>
<h3 id="7-2-중간-노드-끝노드-삭제"><a href="#7-2-중간-노드-끝노드-삭제" class="headerlink" title="7.2. 중간 노드, 끝노드 삭제"></a>7.2. 중간 노드, 끝노드 삭제</h3><p>테스트를 위해 하나의 노드를 만들어보기</p>
<pre><code class="python">linkedlist1 = NodeMgmt(0)
linkedlist1.desc()
</code></pre>
<p>여러 노드를 더 추가</p>
<pre><code class="python">for data in range(1, 10):
    linkedlist1.add(data)
linkedlist1.desc()
</code></pre>
<p>노드 중에 한 개를 삭제함 (위에서 언급한 경우의 수2)</p>
<pre><code class="python">linkedlist1.delete(4)
</code></pre>
<p>특정 노드가 삭제되었음을 확인</p>
<pre><code class="python">linkedlist1.desc()
</code></pre>
<p>노드 중 한 개 삭제</p>
<pre><code class="python">linkedlist1.delete(9)
</code></pre>
<p>확인</p>
<pre><code class="python">linkedlist1.desc()
</code></pre>
<h3 id="7-3-연습문제"><a href="#7-3-연습문제" class="headerlink" title="7.3 연습문제"></a>7.3 연습문제</h3><h3 id="연습1-노드-삭제"><a href="#연습1-노드-삭제" class="headerlink" title="연습1 노드 삭제"></a>연습1 노드 삭제</h3><p><strong>위 코드에서 노드 데이터가 2인 노드 삭제해보기</strong></p>
<pre><code class="python">node_mgmt.delete(2)
node_mgmt.desc()
</code></pre>
<h3 id="연습2-데이터-찾기"><a href="#연습2-데이터-찾기" class="headerlink" title="연습2 데이터 찾기"></a>연습2 데이터 찾기</h3><p><strong>위 코드에서 노드 데이터가 특정 숫자인 노드를 찾는 함수를 만들고, 테스트해보기</strong><br>테스트: 임의로 1 ~ 9까지 데이터를 링크드 리스트에 넣어보고, 데이터 값이 4인 노드의 데이터 값 출력해보기</p>
<pre><code class="python">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
    
    def add(self, data):
        if self.head == &#39;&#39;:
            self.head = Node(data)
        else:
            node = self.head
            while node.next:
                node = node.next
            node.next = Node(data)

    def desc(self):
        node = self.head
        while node:
            print (node.data)
            node = node.next

    def delete(self, data):
        if self.head == &#39;&#39;:
            print (&#39;해당 값을 가진 노드가 없습니다.&#39;)
            return
        if self.head.data == data: # 경우의 수1: self.head를 삭제해야할 경우 - self.head를 바꿔줘야 함
            temp = self.head # self.head 객체를 삭제하기 위해, 임시로 temp에 담아서 객체를 삭제했음
            self.head = self.head.next # 만약 self.head 객체를 삭제하면, 이 코드가 실행이 안되기 때문!
            del temp
        else:
            node = self.head
            while node.next: # 경우의 수2: self.head가 아닌 노드를 삭제해야할 경우
                if node.next.data == data:
                    temp = node.next
                    node.next = node.next.next       
                    del temp                         
                    pass                             
                else:
                    node = node.next
                    
    def search_node(self, data):
        node = self.head
        while node:
            if node.data == data:
                return node
            else:
                node = node.next
</code></pre>
<pre><code class="python"># 테스트
node_mgmt = NodeMgmt(0)
for data in range(1, 10):
    node_mgmt.add(data)

node = node_mgmt.search_node(4)
print (node.data)
</code></pre>
<h2 id="8-다양한-링크드-리스트-구조"><a href="#8-다양한-링크드-리스트-구조" class="headerlink" title="8. 다양한 링크드 리스트 구조"></a>8. 다양한 링크드 리스트 구조</h2><ul>
<li>더블 링크드 리스트(Doubly linked list)</li>
</ul>
<ul>
<li>이중 연결 리스트라고도 함</li>
<li>필요성 : <strong>검색속도 향상</strong> (내가 원하는 데이터가 뒤쪽에 있을 경우 뒤에서 부터 찾으면 효율적일 것이기 때문!)</li>
<li>장점: 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능<img src="https://www.fun-coding.org/00_Images/doublelinkedlist.png" />
(출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)

</li>
</ul>
<p><strong>싱글 링크드 리스타와 차이점</strong></p>
<blockquote>
<p>Node : 인스턴스 변수 <strong>prev</strong>가 추가 됨, tail의 next는 head를 가르켜야함<br>NodeMgmt : 인스턴스 변수 <strong>tail</strong>이 추가 됨, tail은 head을 가르켜야 한다.</p>
</blockquote>
<pre><code class="python">class Node:
    def __init__(self, data, prev=None, next=None):
        self.prev = prev
        self.data = data
        self.next = next

class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        self.tail = self.head

    def insert(self, data):
        if self.head == None:
            self.head = Node(data)
            self.tail = self.head
        else:
            node = self.head
            while node.next:
                node = node.next
            new = Node(data)
            node.next = new
            new.prev = node
            self.tail = new

    def desc(self):
        node = self.head
        while node:
            print (node.data)
            node = node.next
</code></pre>
<pre><code class="python">double_linked_list = NodeMgmt(0)
for data in range(1, 10):
    double_linked_list.insert(data)
double_linked_list.desc()
</code></pre>
<h3 id="연습문제"><a href="#연습문제" class="headerlink" title="연습문제"></a>연습문제</h3><h3 id="연습3-특정-데이터-앞-데이터-추가"><a href="#연습3-특정-데이터-앞-데이터-추가" class="headerlink" title="연습3 특정 데이터 앞 데이터 추가"></a>연습3 특정 데이터 앞 데이터 추가</h3><p><strong>위 코드에서 노드 데이터가 특정 숫자인 노드 앞에 데이터를 추가하는 함수를 만들고, 테스트해보기</strong></p>
<ul>
<li>더블 링크드 리스트의 tail 에서부터 뒤로 이동하며, 특정 숫자인 노드를 찾는 방식으로 함수를 구현하기</li>
<li>테스트: 임의로 0 ~ 9까지 데이터를 링크드 리스트에 넣어보고, 데이터 값이 2인 노드 앞에 1.5 데이터 값을 가진 노드를 추가해보기</li>
</ul>
<pre><code class="python">class Node:
    def __init__(self, data, prev=None, next=None):
        self.prev = prev
        self.data = data
        self.next = next

class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        self.tail = self.head

    def insert(self, data):
        if self.head == None:
            self.head = Node(data)
            self.tail = self.head
        else:
            node = self.head
            while node.next:
                node = node.next
            new = Node(data)
            node.next = new
            new.prev = node
            self.tail = new

    def desc(self):
        node = self.head
        while node:
            print (node.data)
            node = node.next
    # 앞에서부터 검색
    def search_from_head(self, data):
        if self.head == None:
            return False
    
        node = self.head
        while node:
            if node.data == data:
                return node
            else:
                node = node.next
        return False
    # 뒤에서부터 검색
    def search_from_tail(self, data):
        if self.head == None:
            return False
    
        node = self.tail
        while node:
            if node.data == data:
                return node
            else:
                node = node.prev
        return False
    
    def insert_before(self, data, before_data):
        if self.head == None:
            self.head = Node(data)
            return True
        else:
            node = self.tail
            while node.data != before_data:
                node = node.prev
                if node == None:
                    return False
            new = Node(data)
            before_new = node.prev
            before_new.next = new
            new.prev = before_new
            new.next = node
            node.prev = new
            return True
</code></pre>
<pre><code class="python">double_linked_list = NodeMgmt(0)
for data in range(1, 10):
    double_linked_list.insert(data)
double_linked_list.desc()
</code></pre>
<pre><code class="python">node_3 = double_linked_list.search_from_tail(3)
node_3.data
</code></pre>
<pre><code class="python">double_linked_list.insert_before(1.5, 2)
double_linked_list.desc()
</code></pre>
<pre><code class="python">node_3 = double_linked_list.search_from_tail(1.5)
node_3.data
</code></pre>
<h3 id="연습4-특정-데이터-뒤-데이터-추가"><a href="#연습4-특정-데이터-뒤-데이터-추가" class="headerlink" title="연습4 특정 데이터 뒤 데이터 추가"></a>연습4 특정 데이터 뒤 데이터 추가</h3><p><strong>위 코드에서 노드 데이터가 특정 숫자인 노드 뒤에 데이터를 추가하는 함수를 만들고, 테스트해보기</strong></p>
<ul>
<li>더블 링크드 리스트의 head 에서부터 다음으로 이동하며, 특정 숫자인 노드를 찾는 방식으로 함수를 구현하기</li>
<li>테스트: 임의로 0 ~ 9까지 데이터를 링크드 리스트에 넣어보고, 데이터 값이 1인 노드 다음에 1.7 데이터 값을 가진 노드를 추가해보기</li>
</ul>
<pre><code class="python">class Node:
    def __init__(self, data, prev=None, next=None):
        self.prev = prev
        self.data = data
        self.next = next

class NodeMgmt:
    def __init__(self, data):
        self.head = Node(data)
        self.tail = self.head
    
    def insert_before(self, data, before_data):
        if self.head == None:
            self.head = Node(data)
            return True            
        else:
            node = self.tail
            while node.data != before_data:
                node = node.prev
                if node == None:
                    return False
            new = Node(data)
            before_new = node.prev
            before_new.next = new
            new.next = node
            return True

    def insert_after(self, data, after_data):
        if self.head == None:
            self.head = Node(data)
            return True            
        else:
            node = self.head
            while node.data != after_data:
                node = node.next
                if node == None:
                    return False
            new = Node(data)
            after_new = node.next
            new.next = after_new
            new.prev = node
            node.next = new
            if new.next == None:
                self.tail = new
            return True

    def insert(self, data):
        if self.head == None:
            self.head = Node(data)
        else:
            node = self.head
            while node.next:
                node = node.next
            new = Node(data)
            node.next = new
            new.prev = node
            self.tail = new

    def desc(self):
        node = self.head
        while node:
            print (node.data)
            node = node.next
</code></pre>
<pre><code class="python">node_mgmt = NodeMgmt(0)
for data in range(1, 10):
    node_mgmt.insert(data)

node_mgmt.desc()

node_mgmt.insert_after(1.5, 1)
node_mgmt.desc()
</code></pre>
<h1 id="해쉬-테이블-Hash-Table"><a href="#해쉬-테이블-Hash-Table" class="headerlink" title="해쉬 테이블 (Hash Table)"></a>해쉬 테이블 (Hash Table)</h1><p>블록체인의 바탕</p>
<h2 id="1-해쉬-구조"><a href="#1-해쉬-구조" class="headerlink" title="1. 해쉬 구조"></a>1. 해쉬 구조</h2><ul>
<li>Hash Table: 키(Key)에 데이터(Value)를 저장하는 데이터 구조<ul>
<li>Key를 통해 바로 데이터를 받아올 수 있으므로, 속도가 획기적으로 빨라짐</li>
<li>파이썬 딕셔너리(Dictionary) 타입이 해쉬 테이블의 예: Key를 가지고 바로 데이터(Value)를 꺼냄</li>
<li>보통 배열로 미리 Hash Table 사이즈만큼 생성 후에 사용 (공간과 탐색 시간을 맞바꾸는 기법)</li>
<li>단, 파이썬에서는 해쉬를 별도 구현할 이유가 없음 - 딕셔너리 타입을 사용하면 됨</li>
</ul>
</li>
</ul>
<h2 id="2-알아둘-용어-1"><a href="#2-알아둘-용어-1" class="headerlink" title="2. 알아둘 용어"></a>2. 알아둘 용어</h2><ul>
<li>해쉬(Hash): 임의 값을 고정 길이로 변환하는 것</li>
<li>해쉬 테이블(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조</li>
<li>해싱 함수(Hashing Function): Key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수</li>
<li>해쉬 값(Hash Value) 또는 해쉬 주소(Hash Address): Key를 해싱 함수로 연산해서, 해쉬 값을 알아내고, 이를 기반으로 해쉬 테이블에서 해당 Key에 대한 데이터 위치를 일관성있게 찾을 수 있음</li>
<li>슬롯(Slot): 한 개의 데이터를 저장할 수 있는 공간</li>
<li>저장할 데이터에 대해 Key를 추출할 수 있는 별도 함수도 존재할 수 있음<img src="https://www.fun-coding.org/00_Images/hash.png" width=400 />

</li>
</ul>
<h2 id="3-간단한-해쉬-예"><a href="#3-간단한-해쉬-예" class="headerlink" title="3. 간단한 해쉬 예"></a>3. 간단한 해쉬 예</h2><h3 id="3-1-hash-table-만들기"><a href="#3-1-hash-table-만들기" class="headerlink" title="3.1. hash table 만들기"></a>3.1. hash table 만들기</h3><ul>
<li>참고: 파이썬 list comprehension - <a target="_blank" rel="noopener" href="https://www.fun-coding.org/PL&amp;OOP5-2.html">https://www.fun-coding.org/PL&amp;OOP5-2.html</a></li>
</ul>
<pre><code class="python">hash_table = list([i for i in range(10)])
hash_table
</code></pre>
<pre><code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<h3 id="3-2-해쉬함수-키추출"><a href="#3-2-해쉬함수-키추출" class="headerlink" title="3.2. 해쉬함수(키추출)"></a>3.2. 해쉬함수(키추출)</h3><ul>
<li>다양한 해쉬 함수 고안 기법이 있으며, 가장 간단한 방식은 Division (나누기를 통한 나머지 값을 사용하는 기법)</li>
</ul>
<pre><code class="python">def hash_func(key):
    return key % 5
</code></pre>
<h3 id="3-3-해쉬-테이블-저장함수"><a href="#3-3-해쉬-테이블-저장함수" class="headerlink" title="3.3. 해쉬 테이블 저장함수"></a>3.3. 해쉬 테이블 저장함수</h3><ul>
<li><p>데이터에 따라 필요시 key 생성 방법 정의가 필요함</p>
</li>
<li><p>3.3.1. 저장할 데이터</p>
<pre><code class="python">data1 = &#39;Andy&#39;
data2 = &#39;Dave&#39;
data3 = &#39;Trump&#39;
## ord(): 문자의 ASCII(아스키)코드 리턴
print (ord(data1[0]), ord(data2[0]), ord(data3[0]))
print (ord(data1[0]), hash_func(ord(data1[0])))
</code></pre>
<pre><code>  65 68 84
  65 0 
</code></pre>
</li>
<li><p>3.3.2. 저장 함수</p>
<ul>
<li><p>data:value 와 같이 data 와 value를 넣으면, 해당 data에 대한 key를 찾아서, 해당 key에 대응하는 해쉬주소에 value를 저장하는 예</p>
<pre><code class="python">def storage_data(data, value):
    key = ord(data[0])
    hash_address = hash_func(key)
    hash_table[hash_address] = value
</code></pre>
</li>
</ul>
</li>
<li><p>3.3.3. 함수사용</p>
<pre><code class="python">storage_data(&#39;Andy&#39;, &#39;01055553333&#39;)
storage_data(&#39;Dave&#39;, &#39;01044443333&#39;)
storage_data(&#39;Trump&#39;, &#39;01022223333&#39;)
</code></pre>
</li>
</ul>
<h3 id="3-4-해쉬-테이블-값-추출-함수"><a href="#3-4-해쉬-테이블-값-추출-함수" class="headerlink" title="3.4. 해쉬 테이블 값 추출 함수"></a>3.4. 해쉬 테이블 값 추출 함수</h3><ul>
<li><p>3.4.2. 추출함수</p>
<pre><code class="python">def get_data(data):
    key = ord(data[0])
    hash_address = hash_func(key)
    return hash_table[hash_address]
</code></pre>
</li>
<li><p>3.4.2. 함수사용</p>
<pre><code class="python">get_data(&#39;Andy&#39;)
</code></pre>
<p>  ‘01055553333’</p>
</li>
</ul>
<h2 id="4-자료-구조-해쉬-테이블의-장단점과-주요-용도"><a href="#4-자료-구조-해쉬-테이블의-장단점과-주요-용도" class="headerlink" title="4. 자료 구조 해쉬 테이블의 장단점과 주요 용도"></a>4. 자료 구조 해쉬 테이블의 장단점과 주요 용도</h2><ul>
<li><p>장점</p>
<ul>
<li>데이터 저장/읽기 속도가 빠르다. (검색 속도가 빠르다.)</li>
<li>해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉬움</li>
</ul>
</li>
<li><p>단점 </p>
<ul>
<li><p>일반적으로 저장공간이 좀더 많이 필요하다.</p>
</li>
<li><p><strong>여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요함</strong></p>
<pre><code class="python">data1 = &#39;Andy&#39;
data2 = &#39;Dave&#39;
data3 = &#39;Trump&#39;
data4 = &#39;Anthor&#39;
## ord(): 문자의 ASCII(아스키)코드 리턴
print (ord(data1[0]), ord(data2[0]), ord(data3[0]))
print (ord(data1[0]), hash_func(ord(data1[0])))
print (ord(data1[0]), ord(data4[0])) # 이렇게 겹치는 경우
</code></pre>
<pre><code>65 68 84
65 0
65 65       
</code></pre>
</li>
</ul>
</li>
<li><p>주요 용도</p>
<ul>
<li>검색이 많이 필요한 경우</li>
<li>저장, 삭제, 읽기가 빈번한 경우</li>
<li>캐쉬 구현시 (중복 확인이 쉽기 때문)</li>
</ul>
</li>
</ul>
<h2 id="5-연습문제-1"><a href="#5-연습문제-1" class="headerlink" title="5. 연습문제"></a>5. 연습문제</h2><p><strong>연습1: 리스트 변수를 활용해서 해쉬 테이블 구현해보기</strong></p>
<ol>
<li>해쉬 함수: key % 8</li>
<li>해쉬 키 생성: hash(data)</li>
</ol>
<pre><code class="python">hash_table = list([0 for i in range(8)])

def get_key(data):
    return hash(data)

def hash_function(key):
    return key % 8

def save_data(data, value):
    hash_address = hash_function(get_key(data))
    hash_table[hash_address] = value
    
def read_data(data):
    hash_address = hash_function(get_key(data))
    return hash_table[hash_address]
</code></pre>
<pre><code class="python">save_data(&#39;Dave&#39;, &#39;0102030200&#39;)
save_data(&#39;Andy&#39;, &#39;01033232200&#39;)
read_data(&#39;Dave&#39;)
</code></pre>
<pre><code>&#39;0102030200&#39;
</code></pre>
<pre><code class="python">hash_table
</code></pre>
<pre><code>[&#39;0102030200&#39;, 0, 0, 0, 0, 0, 0, &#39;01033232200&#39;]
</code></pre>
<h2 id="6-충돌-Collision-해결-알고리즘"><a href="#6-충돌-Collision-해결-알고리즘" class="headerlink" title="6. 충돌(Collision) 해결 알고리즘"></a>6. 충돌(Collision) 해결 알고리즘</h2><p><strong>좋은 해쉬 함수 사용하기</strong></p>
<blockquote>
<p>해쉬 테이블의 가장 큰 문제는 충돌(Collision)의 경우입니다.<br>이 문제를 충돌(Collision) 또는 해쉬 충돌(Hash Collision)이라고 부릅니다.</p>
</blockquote>
<h3 id="6-1-Chaining-기법"><a href="#6-1-Chaining-기법" class="headerlink" title="6.1. Chaining 기법"></a>6.1. Chaining 기법</h3><ul>
<li><strong>개방 해슁 또는 Open Hashing 기법</strong> 중 하나: 해쉬 테이블 저장공간 외의 공간을 활용하는 기법</li>
<li>충돌이 일어나면, <strong>링크드 리스트</strong> 자료 구조를 뒤에 연결시켜서 저장하는 기법</li>
</ul>
<p><strong>연습2: 연습1의 해쉬 테이블 코드에 Chaining 기법으로 충돌해결 코드를 추가해보기</strong></p>
<ol>
<li>해쉬 함수: key % 8</li>
<li>해쉬 키 생성: hash(data)</li>
</ol>
<pre><code class="python">hash_table = list([0 for i in range(8)])

def get_key(data):
    return hash(data)

def hash_function(key):
    return key % 8

def save_data(data, value):
    index_key = get_key(data) # 충돌해결을 위한 변수
    hash_address = hash_function(index_key)
    # 이미 hash_address에 값이 있으면 아래를 실행
    if hash_table[hash_address] != 0:
        for index in range(len(hash_table[hash_address])):
            # key가 같으면 value를 덮어쓰기
            if hash_table[hash_address][index][0] == index_key:
                hash_table[hash_address][index][1] = value
                return
        # 키가 다르면 append
        hash_table[hash_address].append([index_key, value])
    # 해당 address가 비어있으면, 리스트안에 리스트로 넣어줌
    else:
        hash_table[hash_address] = [[index_key, value]]
    
def read_data(data):
    index_key = get_key(data)
    hash_address = hash_function(index_key)

    if hash_table[hash_address] != 0:
        for index in range(len(hash_table[hash_address])):
            if hash_table[hash_address][index][0] == index_key:
                return hash_table[hash_address][index][1]
        return None
    else:
        return None
</code></pre>
<p>내장함수 hash는 노트 커널 다시킬때마다 달라짐 (겹치는 애가 나오도록 데이터값 바꿔가며 해보기)</p>
<pre><code class="python">print (hash(&#39;David&#39;) % 8)
print (hash(&#39;Daae&#39;) % 8)
print (hash(&#39;Data&#39;) % 8)
</code></pre>
<pre><code>6
6
2
</code></pre>
<pre><code class="python">save_data(&#39;David&#39;, &#39;1201023010&#39;)
save_data(&#39;Daae&#39;, &#39;33333333&#39;)
read_data(&#39;Daae&#39;)
</code></pre>
<pre><code>&#39;33333333&#39;
</code></pre>
<pre><code class="python">hash_table
</code></pre>
<pre><code>[0,
 0,
 0,
 0,
 0,
 0,
 [[2868151959563694846, &#39;1201023010&#39;], [-8256921930930858338, &#39;33333333&#39;]],
 0]
</code></pre>
<h3 id="6-2-Linear-Probing-기법"><a href="#6-2-Linear-Probing-기법" class="headerlink" title="6.2. Linear Probing 기법"></a>6.2. Linear Probing 기법</h3><ul>
<li><strong>폐쇄 해슁 또는 Close Hashing 기법</strong> 중 하나: 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법</li>
<li>충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈공간에 저장하는 기법<ul>
<li>저장공간 활용도를 높이기 위한 기법</li>
</ul>
</li>
</ul>
<p><strong>연습3: 연습1의 해쉬 테이블 코드에 Linear Probling 기법으로 충돌해결 코드를 추가해보기</strong></p>
<ol>
<li>해쉬 함수: key % 8</li>
<li>해쉬 키 생성: hash(data)</li>
</ol>
<pre><code class="python">hash_table = list([0 for i in range(8)])

def get_key(data):
    return hash(data)

def hash_function(key):
    return key % 8

def save_data(data, value):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    # 충돌이나면
    if hash_table[hash_address] != 0:
        # 이미 해당 hash_address에 값이 존재하면 그 다음 빈 곳을 찾아 넣음
        for index in range(hash_address, len(hash_table)):
            if hash_table[index] == 0:
                hash_table[index] = [index_key, value]
                return
            # 동일한 키를 가진 데이터가 있으면 값을 업데이트
            elif hash_table[index][0] == index_key:
                hash_table[index][1] = value
                return
    else:
        hash_table[hash_address] = [index_key, value]

def read_data(data):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    
    if hash_table[hash_address] != 0:
        # 충돌이나서 다른 곳에 저장되었을 것 까지 고려
        for index in range(hash_address, len(hash_table)):
            if hash_table[index] == 0:
                return None
            elif hash_table[index][0] == index_key:
                return hash_table[index][1]
    else:
        return None
</code></pre>
<pre><code class="python">print (hash(&#39;David&#39;) % 8)
print (hash(&#39;Daae&#39;) % 8)
print (hash(&#39;davi&#39;) % 8)
</code></pre>
<pre><code>6
6
6
</code></pre>
<p>인덱스가 같아도 key가 같지 않아서 안나옴을 확인</p>
<pre><code class="python">save_data(&#39;David&#39;, &#39;1201023010&#39;)
save_data(&#39;Daae&#39;, &#39;33333333&#39;)
read_data(&#39;davi&#39;)
</code></pre>
<h3 id="6-3-빈번한-충돌을-개선하는-기법"><a href="#6-3-빈번한-충돌을-개선하는-기법" class="headerlink" title="6.3. 빈번한 충돌을 개선하는 기법"></a>6.3. 빈번한 충돌을 개선하는 기법</h3><ul>
<li>해쉬 함수을 재정의 및 해쉬 테이블 저장공간을 확대</li>
<li>예:</li>
</ul>
<pre><code class="python">hash_table = list([None for i in range(16)])

def hash_function(key):
    return key % 16
</code></pre>
<h3 id="참고-해쉬-함수와-키-생성-함수"><a href="#참고-해쉬-함수와-키-생성-함수" class="headerlink" title="참고: 해쉬 함수와 키 생성 함수"></a>참고: 해쉬 함수와 키 생성 함수</h3><ul>
<li>파이썬의 hash() 함수는 실행할 때마다, 값이 달라질 수 있음</li>
<li>유명한 해쉬 함수들이 있음: SHA(Secure Hash Algorithm, 안전한 해시 알고리즘)<ul>
<li>어떤 데이터도 유일한 고정된 크기의 고정값을 리턴해주므로, 해쉬 함수로 유용하게 활용 가능</li>
</ul>
</li>
</ul>
<h3 id="참고1-SHA-1"><a href="#참고1-SHA-1" class="headerlink" title="참고1 : SHA-1"></a>참고1 : SHA-1</h3><ul>
<li><p>encode : byte로 변환</p>
</li>
<li><p>hashlib.sha1()에서 만든 hash값은 문자열이 동일하면 항상 같은 값 나옴 : 고정된 길이의 다른 값</p>
<pre><code class="python">import hashlib

data = &#39;test&#39;.encode()
hash_object = hashlib.sha1()
hash_object.update(data)
hex_dig = hash_object.hexdigest()
print (hex_dig)
</code></pre>
<pre><code>  a94a8fe5ccb19ba61c4c0873d391e987982fbbd3
</code></pre>
</li>
</ul>
<h3 id="참고2-SHA-256"><a href="#참고2-SHA-256" class="headerlink" title="참고2 : SHA-256"></a>참고2 : SHA-256</h3><ul>
<li><p>블록체인에서도 쓰임 (보안이 더 강화됨)</p>
<pre><code class="python">import hashlib

data = &#39;test&#39;.encode()
hash_object = hashlib.sha256()
hash_object.update(data)
hex_dig = hash_object.hexdigest()
print (hex_dig)
</code></pre>
<pre><code>  9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08
</code></pre>
</li>
</ul>
<h3 id="6-4-동일한-데이터에-대해-동일한-hash-address로-개선"><a href="#6-4-동일한-데이터에-대해-동일한-hash-address로-개선" class="headerlink" title="6.4. 동일한 데이터에 대해 동일한 hash address로 개선"></a>6.4. 동일한 데이터에 대해 동일한 hash address로 개선</h3><p><strong>연습4: 연습2의 Chaining 기법을 적용한 해쉬 테이블 코드에 키 생성 함수를 sha256 해쉬 알고리즘을 사용하도록 변경해보기</strong></p>
<ol>
<li>해쉬 함수: key % 8</li>
<li>해쉬 키 생성: hash(data)</li>
</ol>
<pre><code class="python">import hashlib

hash_table = list([0 for i in range(8)])

def get_key(data):
        hash_object = hashlib.sha256()
        hash_object.update(data.encode())
        hex_dig = hash_object.hexdigest()
        return int(hex_dig, 16)

def hash_function(key):
    return key % 8

def save_data(data, value):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    if hash_table[hash_address] != 0:
        for index in range(hash_address, len(hash_table)):
            if hash_table[index] == 0:
                hash_table[index] = [index_key, value]
                return
            elif hash_table[index][0] == index_key:
                hash_table[index][1] = value
                return
    else:
        hash_table[hash_address] = [index_key, value]

def read_data(data):
    index_key = get_key(data)
    hash_address = hash_function(index_key)
    
    if hash_table[hash_address] != 0:
        for index in range(hash_address, len(hash_table)):
            if hash_table[index] == 0:
                return None
            elif hash_table[index][0] == index_key:
                return hash_table[index][1]
    else:
        return None
</code></pre>
<pre><code class="python">print (get_key(&#39;db&#39;) % 8)
print (get_key(&#39;da&#39;) % 8)
print (get_key(&#39;dh&#39;) % 8)
</code></pre>
<pre><code>1
2
2
</code></pre>
<pre><code class="python">save_data(&#39;da&#39;, &#39;01200123123&#39;)
save_data(&#39;dh&#39;, &#39;3333333333&#39;)
read_data(&#39;dh&#39;)
</code></pre>
<pre><code>&#39;3333333333&#39;
</code></pre>
<h2 id="7-시간-복잡도"><a href="#7-시간-복잡도" class="headerlink" title="7. 시간 복잡도"></a>7. 시간 복잡도</h2><ul>
<li>일반적인 경우(Collision이 없는 경우)는 O(1)</li>
<li>최악의 경우(Collision이 모두 발생하는 경우)는 O(n)</li>
</ul>
<blockquote>
<p>해쉬 테이블의 경우, 일반적인 경우를 기대하고 만들기 때문에, 시간 복잡도는 O(1) 이라고 말할 수 있음</p>
</blockquote>
<h2 id="검색에서-해쉬-테이블의-사용-예"><a href="#검색에서-해쉬-테이블의-사용-예" class="headerlink" title="검색에서 해쉬 테이블의 사용 예"></a>검색에서 해쉬 테이블의 사용 예</h2><ul>
<li>16개의 배열에 데이터를 저장하고, 검색할 때 O(n)</li>
<li>16개의 데이터 저장공간을 가진 위의 해쉬 테이블에 데이터를 저장하고, 검색할 때 O(1)</li>
</ul>
<h1 id="트리"><a href="#트리" class="headerlink" title="트리"></a>트리</h1><h2 id="1-트리-Tree-구조"><a href="#1-트리-Tree-구조" class="headerlink" title="1. 트리 (Tree) 구조"></a>1. 트리 (Tree) 구조</h2><ul>
<li>트리: Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조</li>
<li>실제로 어디에 많이 사용되나? <ul>
<li>트리 중 이진 트리 (Binary Tree) 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용됨</li>
</ul>
</li>
</ul>
<h2 id="2-알아둘-용어-2"><a href="#2-알아둘-용어-2" class="headerlink" title="2. 알아둘 용어"></a>2. 알아둘 용어</h2><ul>
<li>Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)</li>
<li>Root Node: 트리 맨 위에 있는 노드</li>
<li>Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄</li>
<li>Parent Node: 어떤 노드의 다음 레벨에 연결된 노드</li>
<li>Child Node: 어떤 노드의 상위 레벨에 연결된 노드</li>
<li>Leaf Node (Terminal Node): Child Node가 하나도 없는 노드</li>
<li>Sibling (Brother Node): 동일한 Parent Node를 가진 노드</li>
<li>Depth: 트리에서 Node가 가질 수 있는 최대 Level<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/tree.png" alt="tree"></li>
</ul>
<h2 id="3-이진-트리와-이진-탐색-트리-Binary-Search-Tree"><a href="#3-이진-트리와-이진-탐색-트리-Binary-Search-Tree" class="headerlink" title="3. 이진 트리와 이진 탐색 트리 (Binary Search Tree)"></a>3. 이진 트리와 이진 탐색 트리 (Binary Search Tree)</h2><ul>
<li><p>이진 트리: 노드의 최대 Branch가 2인 트리</p>
</li>
<li><p>이진 탐색 트리 (Binary Search Tree, BST): 이진 트리에 다음과 같은 추가적인 조건이 있는 트리</p>
<ul>
<li>왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지고 있음!</li>
</ul>
<img src="https://www.mathwarehouse.com/programming/images/binary-search-tree/binary-search-tree-insertion-animation.gif" />

</li>
</ul>
<p>(출처: <a target="_blank" rel="noopener" href="https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node">https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node</a>)  </p>
<h2 id="4-자료-구조-이진-탐색-트리의-장점과-주요-용도"><a href="#4-자료-구조-이진-탐색-트리의-장점과-주요-용도" class="headerlink" title="4. 자료 구조 이진 탐색 트리의 장점과 주요 용도"></a>4. 자료 구조 이진 탐색 트리의 장점과 주요 용도</h2><ul>
<li>주요 용도: 데이터 검색(탐색) </li>
<li>장점: <strong>탐색 속도를 개선</strong>할 수 있음</li>
</ul>
<blockquote>
<p>단점은 이진 탐색 트리 알고리즘 이해 후에 살펴보기로 함</p>
</blockquote>
<h2 id="이진트리와-정렬된-배열간의-탐색-비교"><a href="#이진트리와-정렬된-배열간의-탐색-비교" class="headerlink" title="이진트리와 정렬된 배열간의 탐색 비교"></a>이진트리와 정렬된 배열간의 탐색 비교</h2><img src="https://www.mathwarehouse.com/programming/images/binary-search-tree/binary-search-tree-sorted-array-animation.gif" />

<p>(출처: <a target="_blank" rel="noopener" href="https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node">https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node</a>)</p>
<h2 id="5-파이썬-객체지향-프로그래밍으로-링크드-리스트-구현하기"><a href="#5-파이썬-객체지향-프로그래밍으로-링크드-리스트-구현하기" class="headerlink" title="5. 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기"></a>5. 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기</h2><h3 id="5-1-노드-클래스-만들기"><a href="#5-1-노드-클래스-만들기" class="headerlink" title="5.1. 노드 클래스 만들기"></a>5.1. 노드 클래스 만들기</h3><pre><code class="python">class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
</code></pre>
<h3 id="5-2-이진-탐색-트리에-데이터-넣기"><a href="#5-2-이진-탐색-트리에-데이터-넣기" class="headerlink" title="5.2. 이진 탐색 트리에 데이터 넣기"></a>5.2. 이진 탐색 트리에 데이터 넣기</h3><ul>
<li>이진 탐색 트리 조건에 부합하게 데이터를 넣어야 함</li>
</ul>
<pre><code class="python">class NodeMgmt:
    def __init__(self, node):
        self.head = node
    
    def insert(self, value):
        self.current_node = self.head
        while True:
            if value &lt; self.current_node.value:
                if self.current_node.left != None:
                    self.current_node = self.current_node.left
                else:
                    self.current_node.left = Node(value)
                    break
            else:
                if self.current_node.right != None:
                    self.current_node = self.current_node.right
                else:
                    self.current_node.right = Node(value)
                    break
</code></pre>
<pre><code class="python">head = Node(1)
BST = NodeMgmt(head)
BST.insert(2)
</code></pre>
<h3 id="5-3-이진-탐색-트리-탐색"><a href="#5-3-이진-탐색-트리-탐색" class="headerlink" title="5.3. 이진 탐색 트리 탐색"></a>5.3. 이진 탐색 트리 탐색</h3><pre><code class="python">class NodeMgmt:
    def __init__(self, head):
        self.head = head
    
    def insert(self, value):
        self.current_node = self.head
        while True:
            if value &lt; self.current_node.value:
                if self.current_node.left != None:
                    self.current_node = self.current_node.left
                else:
                    self.current_node.left = Node(value)
                    break
            else:
                if self.current_node.right != None:
                    self.current_node = self.current_node.right
                else:
                    self.current_node.right = Node(value)
                    break
    
    def search(self, value):
        self.current_node = self.head
        while self.current_node:
            if self.current_node.value == value:
                return True
            elif value &lt; self.current_node.value:
                self.current_node = self.current_node.left
            else:
                self.current_node = self.current_node.right
        return False        
</code></pre>
<pre><code class="python">head = Node(1)
BST = NodeMgmt(head)
BST.insert(2)
BST.insert(3)
BST.insert(0)
BST.insert(4)
BST.insert(8)
</code></pre>
<pre><code class="python">BST.search(-1)
</code></pre>
<h3 id="5-4-이진-탐색-트리-삭제"><a href="#5-4-이진-탐색-트리-삭제" class="headerlink" title="5.4. 이진 탐색 트리 삭제"></a>5.4. 이진 탐색 트리 삭제</h3><ul>
<li>매우 복잡함. <strong>경우를 나누어서 이해하는 것이 좋음</strong></li>
</ul>
<h4 id="5-4-1-Leaf-Node-삭제"><a href="#5-4-1-Leaf-Node-삭제" class="headerlink" title="5.4.1. Leaf Node 삭제"></a>5.4.1. Leaf Node 삭제</h4><ul>
<li>Leaf Node: Child Node 가 없는 Node</li>
<li>삭제할 Node의 Parent Node가 삭제할 Node를 가리키지 않도록 한다.</li>
</ul>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/leafnodeDel1.png" alt="leafnodeDel1"></p>
<h4 id="5-4-2-Child-Node-가-하나인-Node-삭제"><a href="#5-4-2-Child-Node-가-하나인-Node-삭제" class="headerlink" title="5.4.2. Child Node 가 하나인 Node 삭제"></a>5.4.2. Child Node 가 하나인 Node 삭제</h4><ul>
<li>삭제할 Node의 Parent Node가 삭제할 Node의 Child Node를 가리키도록 한다.<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/leafnodeDel2.png" alt="leafnodeDel1"></li>
</ul>
<h4 id="5-4-3-Child-Node-가-두-개인-Node-삭제"><a href="#5-4-3-Child-Node-가-두-개인-Node-삭제" class="headerlink" title="5.4.3. Child Node 가 두 개인 Node 삭제"></a>5.4.3. Child Node 가 두 개인 Node 삭제</h4><ol>
<li><strong>삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 한다.</strong></li>
<li>삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 한다.<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/leafnodeDel3.png" alt="leafnodeDel1"></li>
</ol>
<h5 id="5-4-3-1-삭제할-Node의-오른쪽-자식중-가장-작은-값을-삭제할-Node의-Parent-Node가-가리키게-할-경우"><a href="#5-4-3-1-삭제할-Node의-오른쪽-자식중-가장-작은-값을-삭제할-Node의-Parent-Node가-가리키게-할-경우" class="headerlink" title="5.4.3.1. 삭제할 Node의 오른쪽 자식중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키게 할 경우"></a>5.4.3.1. 삭제할 Node의 오른쪽 자식중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키게 할 경우</h5><ul>
<li>삭제할 Node의 오른쪽 자식 선택</li>
<li>오른쪽 자식의 가장 왼쪽에 있는 Node를 선택</li>
<li>해당 Node를 삭제할 Node의 Parent Node의 왼쪽 Branch가 가리키게 함</li>
<li>해당 Node의 왼쪽 Branch가 삭제할 Node의 왼쪽 Child Node를 가리키게 함</li>
<li>해당 Node의 오른쪽 Branch가 삭제할 Node의 오른쪽 Child Node를 가리키게 함</li>
<li>만약 해당 Node가 오른쪽 Child Node를 가지고 있었을 경우에는, 해당 Node의 본래 Parent Node의 왼쪽 Branch가 해당 오른쪽 Child Node를 가리키게 함</li>
</ul>
<h3 id="5-5-이진-탐색-트리-삭제-코드-구현과-분석"><a href="#5-5-이진-탐색-트리-삭제-코드-구현과-분석" class="headerlink" title="5.5. 이진 탐색 트리 삭제 코드 구현과 분석"></a>5.5. 이진 탐색 트리 삭제 코드 구현과 분석</h3><h4 id="5-5-1-삭제할-Node-탐색"><a href="#5-5-1-삭제할-Node-탐색" class="headerlink" title="5.5.1 삭제할 Node 탐색"></a>5.5.1 삭제할 Node 탐색</h4><ul>
<li>삭제할 Node가 없는 경우도 처리해야 함<ul>
<li>이를 위해 삭제할 Node가 없는 경우는 False를 리턴하고, 함수를 종료 시킴</li>
</ul>
</li>
</ul>
<pre><code class="python"># def delete(self, value):
    searched = False
    self.current_node = self.head
    self.parent = self.head
    while self.current_node:
        if self.current_node.value == value:
            searched = True
            break
        elif value &lt; self.current_node.value:
            self.parent = self.current_node
            self.current_node = self.current_node.left
        else:
            self.parent = self.current_node
            self.current_node = self.current_node.right
    
    if searched == False:
        return False
    
    ### 이후부터 Case들을 분리해서, 코드 작성
</code></pre>
<h4 id="5-5-2-Case1-삭제할-Node가-Leaf-Node인-경우"><a href="#5-5-2-Case1-삭제할-Node가-Leaf-Node인-경우" class="headerlink" title="5.5.2. Case1: 삭제할 Node가 Leaf Node인 경우"></a>5.5.2. Case1: 삭제할 Node가 Leaf Node인 경우</h4><p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/tree_remove_leaf_code.png" alt="tree_remove_leaf_code"></p>
<pre><code class="python"># self.current_node 가 삭제할 Node, self.parent는 삭제할 Node의 Parent Node인 상태
    if  self.current_node.left == None and self.current_node.right == None:
        if value &lt; self.parent.value:
            self.parent.left = None
        else:
            self.parent.right = None
        del self.current_node
</code></pre>
<h4 id="5-5-2-Case2-삭제할-Node가-Child-Node를-한-개-가지고-있을-경우"><a href="#5-5-2-Case2-삭제할-Node가-Child-Node를-한-개-가지고-있을-경우" class="headerlink" title="5.5.2. Case2: 삭제할 Node가 Child Node를 한 개 가지고 있을 경우"></a>5.5.2. Case2: 삭제할 Node가 Child Node를 한 개 가지고 있을 경우</h4><p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/tree_remove_1child_code.png" alt="tree_remove_leaf_code"></p>
<pre><code class="python">    if self.current_node.left != None and self.current_node.right == None:
        if value &lt; self.parent.value:
            self.parent.left = self.current_node.left
        else:
            self.parent.right = self.current_node.left
    elif self.current_node.left == None and self.current_node.right != None:
        if value &lt; self.parent.value:
            self.parent.left = self.current_node.right
        else:
            self.parent.right = self.current_node.right
</code></pre>
<h4 id="5-5-3-Case3-1-삭제할-Node가-Child-Node를-두-개-가지고-있을-경우-삭제할-Node가-Parent-Node-왼쪽에-있을-때"><a href="#5-5-3-Case3-1-삭제할-Node가-Child-Node를-두-개-가지고-있을-경우-삭제할-Node가-Parent-Node-왼쪽에-있을-때" class="headerlink" title="5.5.3. Case3-1: 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 왼쪽에 있을 때)"></a>5.5.3. Case3-1: 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 왼쪽에 있을 때)</h4><ul>
<li>기본 사용 가능 전략<ol>
<li><strong>삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 한다.</strong></li>
<li>삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 한다.</li>
</ol>
</li>
<li>기본 사용 가능 전략 중, 1번 전략을 사용하여 코드를 구현하기로 함<ul>
<li>경우의 수가 또다시 두가지가 있음<ul>
<li><strong>Case3-1-1:</strong> 삭제할 Node가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 Child Node가 없을 때</li>
<li><strong>Case3-1-2:</strong> 삭제할 Node가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 오른쪽에 Child Node가 있을 때<ul>
<li>가장 작은 값을 가진 Node의 Child Node가 왼쪽에 있을 경우는 없음, 왜냐하면 왼쪽 Node가 있다는 것은 해당 Node보다 더 작은 값을 가진 Node가 있다는 뜻이기 때문임</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/tree_remove_2child_code_left.png" alt="tree_remove_2child_code_left.png"></p>
<pre><code class="python">    if self.current_node.left != None and self.current_node.right != None: # case3
        if value &lt; self.parent.value: # case3-1
            self.change_node = self.current_node.right
            self.change_node_parent = self.current_node.right
            while self.change_node.left != None:
                self.change_node_parent = self.change_node
                self.change_node = self.change_node.left
            if self.change_node.right != None:
                self.change_node_parent.left = self.change_node.right
            else:
                self.change_node_parent.left = None
            self.parent.left = self.change_node
            self.change_node.right = self.current_node.right
            self.change_node.left = self.change_node.left
</code></pre>
<h4 id="5-5-4-Case3-2-삭제할-Node가-Child-Node를-두-개-가지고-있을-경우-삭제할-Node가-Parent-Node-오른쪽에-있을-때"><a href="#5-5-4-Case3-2-삭제할-Node가-Child-Node를-두-개-가지고-있을-경우-삭제할-Node가-Parent-Node-오른쪽에-있을-때" class="headerlink" title="5.5.4. Case3-2: 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 오른쪽에 있을 때)"></a>5.5.4. Case3-2: 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 오른쪽에 있을 때)</h4><ul>
<li>기본 사용 가능 전략<ol>
<li><strong>삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 한다.</strong></li>
<li>삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 한다.</li>
</ol>
</li>
<li>기본 사용 가능 전략 중, 1번 전략을 사용하여 코드를 구현하기로 함<ul>
<li>경우의 수가 또다시 두가지가 있음<ul>
<li><strong>Case3-2-1:</strong> 삭제할 Node가 Parent Node의 오른쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 Child Node가 없을 때</li>
<li><strong>Case3-2-2:</strong> 삭제할 Node가 Parent Node의 오른쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 오른쪽에 Child Node가 있을 때<ul>
<li>가장 작은 값을 가진 Node의 Child Node가 왼쪽에 있을 경우는 없음, 왜냐하면 왼쪽 Node가 있다는 것은 해당 Node보다 더 작은 값을 가진 Node가 있다는 뜻이기 때문임</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/tree_remove_2child_code_right.png" alt="tree_remove_2child_code_right"></p>
<pre><code class="python">        else:
            self.change_node = self.current_node.right
            self.change_node_parent = self.current_node.right
            while self.change_node.left != None:
                self.change_node_parent = self.change_node
                self.change_node = self.change_node.left
            if self.change_node.right != None:
                self.change_node_parent.left = self.change_node.right
            else:
                self.change_node_parent.left = None
            self.parent.right = self.change_node
            self.change_node.left = self.current_node.left
            self.change_node.right = self.current_node.right
</code></pre>
<h4 id="5-5-5-파이썬-전체-코드-구현"><a href="#5-5-5-파이썬-전체-코드-구현" class="headerlink" title="5.5.5. 파이썬 전체 코드 구현"></a>5.5.5. 파이썬 전체 코드 구현</h4><pre><code class="python">class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

        
class NodeMgmt:
    def __init__(self, head):
        self.head = head
    
    def insert(self, value):
        self.current_node = self.head
        while True:
            if value &lt; self.current_node.value:
                if self.current_node.left != None:
                    self.current_node = self.current_node.left
                else:
                    self.current_node.left = Node(value)
                    break
            else:
                if self.current_node.right != None:
                    self.current_node = self.current_node.right
                else:
                    self.current_node.right = Node(value)
                    break
    
    def search(self, value):
        self.current_node = self.head
        while self.current_node:
            if self.current_node.value == value:
                return True
            elif value &lt; self.current_node.value:
                self.current_node = self.current_node.left
            else:
                self.current_node = self.current_node.right
        return False        
    
    def delete(self, value):
        # 삭제할 노드 탐색
        searched = False
        self.current_node = self.head
        self.parent = self.head
        while self.current_node:
            if self.current_node.value == value:
                searched = True
                break
            elif value &lt; self.current_node.value:
                self.parent = self.current_node
                self.current_node = self.current_node.left
            else:
                self.parent = self.current_node
                self.current_node = self.current_node.right

        if searched == False:
            return False    

        # case1
        if  self.current_node.left == None and self.current_node.right == None:
            if value &lt; self.parent.value:
                self.parent.left = None
            else:
                self.parent.right = None
        
        # case2
        elif self.current_node.left != None and self.current_node.right == None:
            if value &lt; self.parent.value:
                self.parent.left = self.current_node.left
            else:
                self.parent.right = self.current_node.left
        elif self.current_node.left == None and self.current_node.right != None:
            if value &lt; self.parent.value:
                self.parent.left = self.current_node.right
            else:
                self.parent.right = self.current_node.right        
        
        # case 3
        elif self.current_node.left != None and self.current_node.right != None:
            # case3-1
            if value &lt; self.parent.value:
                self.change_node = self.current_node.right
                self.change_node_parent = self.current_node.right
                while self.change_node.left != None:
                    self.change_node_parent = self.change_node
                    self.change_node = self.change_node.left
                if self.change_node.right != None:
                    self.change_node_parent.left = self.change_node.right
                else:
                    self.change_node_parent.left = None
                self.parent.left = self.change_node
                self.change_node.right = self.current_node.right
                self.change_node.left = self.change_node.left
            # case 3-2
            else:
                self.change_node = self.current_node.right
                self.change_node_parent = self.current_node.right
                while self.change_node.left != None:
                    self.change_node_parent = self.change_node
                    self.change_node = self.change_node.left
                if self.change_node.right != None:
                    self.change_node_parent.left = self.change_node.right
                else:
                    self.change_node_parent.left = None
                self.parent.right = self.change_node
                self.change_node.right = self.current_node.right
                self.change_node.left = self.current_node.left

        return True
</code></pre>
<p>참고: <a target="_blank" rel="noopener" href="http://ejklike.github.io/2018/01/09/traversing-a-binary-tree-1.html">http://ejklike.github.io/2018/01/09/traversing-a-binary-tree-1.html</a></p>
<h4 id="5-5-6-파이썬-전체-코드-테스트"><a href="#5-5-6-파이썬-전체-코드-테스트" class="headerlink" title="5.5.6. 파이썬 전체 코드 테스트"></a>5.5.6. 파이썬 전체 코드 테스트</h4><ul>
<li>random 라이브러리 활용<ul>
<li>random.randint(첫번째 숫자, 마지막 숫자): 첫번째 숫자부터 마지막 숫자 사이에 있는 숫자를 랜덤하게 선택해서 리턴<ul>
<li>예: random.randint(0, 99): 0에서 99까지 숫자중 특정 숫자를 랜덤하게 선택해서 리턴해줌</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="python"># 0 ~ 999 숫자 중에서 임의로 100개를 추출해서, 이진 탐색 트리에 입력, 검색, 삭제
import random

# 0 ~ 999 중, 100 개의 숫자 랜덤 선택
bst_nums = set()
while len(bst_nums) != 100:
    bst_nums.add(random.randint(0, 999))
# print (bst_nums)

# 이게 위에보다 훨신 느림
# bst_nums = random.sample(range(0,1000),100)

# 선택된 100개의 숫자를 이진 탐색 트리에 입력, 임의로 루트노드는 500을 넣기로 함
head = Node(500)
binary_tree = NodeMgmt(head)
for num in bst_nums:
    binary_tree.insert(num)
    
# 입력한 100개의 숫자 검색 (검색 기능 확인)
for num in bst_nums:
    if binary_tree.search(num) == False:
        print (&#39;search failed&#39;, num)

# 입력한 100개의 숫자 중 10개의 숫자를 랜덤 선택
delete_nums = set()
bst_nums = list(bst_nums)
while len(delete_nums) != 10:
    delete_nums.add(bst_nums[random.randint(0, 99)])

# 선택한 10개의 숫자를 삭제 (삭제 기능 확인)
for del_num in delete_nums:
    if binary_tree.delete(del_num) == False:
        print(&#39;delete failed&#39;, del_num)
</code></pre>
<h2 id="6-이진-탐색-트리의-시간-복잡도와-단점"><a href="#6-이진-탐색-트리의-시간-복잡도와-단점" class="headerlink" title="6. 이진 탐색 트리의 시간 복잡도와 단점"></a>6. 이진 탐색 트리의 시간 복잡도와 단점</h2><h3 id="6-1-시간-복잡도-탐색시"><a href="#6-1-시간-복잡도-탐색시" class="headerlink" title="6.1. 시간 복잡도 (탐색시)"></a>6.1. 시간 복잡도 (탐색시)</h3><ul>
<li>depth (트리의 높이) 를 h라고 표기한다면, O(h)</li>
<li>n개의 노드를 가진다면, $h = log_2{n}$ 에 가까우므로, 시간 복잡도는 $O(log{n})$ <ul>
<li>참고: 빅오 표기법에서 $log{n}$ 에서의 log의 밑은 10이 아니라, 2입니다.<ul>
<li>한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미함<img src="https://www.mathwarehouse.com/programming/images/binary-search-tree/binary-search-tree-sorted-array-animation.gif" />

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>(출처: <a target="_blank" rel="noopener" href="https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node">https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node</a>)</p>
<h3 id="6-2-이진-탐색-트리-단점"><a href="#6-2-이진-탐색-트리-단점" class="headerlink" title="6.2. 이진 탐색 트리 단점"></a>6.2. 이진 탐색 트리 단점</h3><ul>
<li>평균 시간 복잡도는 $O(log{n})$ 이지만, <ul>
<li>이는 트리가 균형잡혀 있을 때의 평균 시간복잡도이며,</li>
</ul>
</li>
<li>다음 예와 같이 구성되어 있을 경우, <strong>최악의 경우는 링크드 리스트등과 동일한 성능</strong>을 보여줌 ( $O(n)$ )<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/worstcase_bst.png" alt="worstcase_bst.png"></li>
</ul>
<h1 id="힙"><a href="#힙" class="headerlink" title="힙"></a>힙</h1><h2 id="1-힙-Heap-이란"><a href="#1-힙-Heap-이란" class="headerlink" title="1. 힙 (Heap) 이란?"></a>1. 힙 (Heap) 이란?</h2><ul>
<li><p>힙: 데이터에서 <strong>최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree)</strong></p>
<ul>
<li>완전 이진 트리: 노드를 삽입할 때 <strong>최하단 왼쪽 노드부터 차례대로 삽입</strong>하는 트리<ul>
<li>이렇게하면<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/completebinarytree.png" alt="completebinarytree"></li>
</ul>
</li>
</ul>
</li>
<li><p>힙을 사용하는 이유</p>
<blockquote>
<p>배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 <strong>O(n)</strong> 이 걸림</p>
<p>힙에 데이터를 넣고, 최대값과 최소값을 찾으면, <strong>$O(log n)$</strong> 이 걸림</p>
</blockquote>
<ul>
<li>우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됨</li>
</ul>
</li>
</ul>
<h2 id="2-힙-Heap-종류-조건"><a href="#2-힙-Heap-종류-조건" class="headerlink" title="2. 힙 (Heap) 종류, 조건"></a>2. 힙 (Heap) 종류, 조건</h2><ul>
<li>분류 (종류)<ol>
<li>힙은 최대값을 구하기 위한 구조 (최대 힙, Max Heap)</li>
<li>최소값을 구하기 위한 구조 (최소 힙, Min Heap)</li>
</ol>
</li>
<li>힙의 조건<ol>
<li>(최대 힙의 경우) 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같다.<ul>
<li>최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작음</li>
</ul>
</li>
<li>완전 이진 트리 형태를 가짐</li>
</ol>
<ul>
<li>노르를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리</li>
</ul>
</li>
</ul>
<h3 id="힙과-이진-탐색-트리의-공통점과-차이점"><a href="#힙과-이진-탐색-트리의-공통점과-차이점" class="headerlink" title="힙과 이진 탐색 트리의 공통점과 차이점"></a>힙과 이진 탐색 트리의 공통점과 차이점</h3><ul>
<li>공통점: 힙과 이진 탐색 트리는 모두 이진 트리임 (자식 노드가 최대 두개)</li>
<li>차이점: <ul>
<li>힙은 각 노드의 값이 자식 노드보다 크거나 같음(Max Heap의 경우)</li>
<li>이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼</li>
<li>힙은 이진 탐색 트리의 조건인 자식 노드에서 작은 값은 왼쪽, 큰 값은 오른쪽이라는 조건은 없음<ul>
<li>힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있음</li>
</ul>
</li>
</ul>
</li>
<li>이진 탐색 트리는 탐색을 위한 구조, 힙은 최대/최소값 검색을 위한 구조 중 하나로 이해하면 됨<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/completebinarytree_bst.png" alt="completebinarytree_bst"></li>
</ul>
<h2 id="3-힙-Heap-동작"><a href="#3-힙-Heap-동작" class="headerlink" title="3. 힙 (Heap) 동작"></a>3. 힙 (Heap) 동작</h2><ul>
<li>데이터를 힙 구조에 삽입, 삭제하는 과정을 그림을 통해 선명하게 이해하기</li>
</ul>
<h3 id="힙에-데이터-삽입하기-기본-동작"><a href="#힙에-데이터-삽입하기-기본-동작" class="headerlink" title="힙에 데이터 삽입하기 - 기본 동작"></a>힙에 데이터 삽입하기 - 기본 동작</h3><ul>
<li>힙은 완전 이진 트리이므로, 삽입할 노드는 기본적으로 왼쪽 최하단부 노드부터 채워지는 형태로 삽입<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_ordinary%20(1).png" alt="heap_ordinary (1)"></li>
</ul>
<h3 id="힙에-데이터-삽입하기-삽입할-데이터가-힙의-데이터보다-클-경우-Max-Heap-의-예"><a href="#힙에-데이터-삽입하기-삽입할-데이터가-힙의-데이터보다-클-경우-Max-Heap-의-예" class="headerlink" title="힙에 데이터 삽입하기 - 삽입할 데이터가 힙의 데이터보다 클 경우 (Max Heap 의 예)"></a>힙에 데이터 삽입하기 - 삽입할 데이터가 힙의 데이터보다 클 경우 (Max Heap 의 예)</h3><ul>
<li>먼저 삽입된 데이터는 완전 이진 트리 구조에 맞추어, 최하단부 왼쪽 노드부터 채워짐</li>
<li>채워진 노드 위치에서, 부모 노드보다 값이 클 경우, 부모 노드와 위치를 바꿔주는 작업을 반복함 (swap)<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_insert(1).png" alt="heap_insert(1).png"></li>
</ul>
<h3 id="힙의-데이터-삭제하기-Max-Heap-의-예"><a href="#힙의-데이터-삭제하기-Max-Heap-의-예" class="headerlink" title="힙의 데이터 삭제하기 (Max Heap 의 예)"></a>힙의 데이터 삭제하기 (Max Heap 의 예)</h3><ul>
<li>보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적임<ul>
<li>힙의 용도는 최대값 또는 최소값을 root 노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는 것임</li>
</ul>
</li>
<li>상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드 (일반적으로 가장 마지막에 추가한 노드) 를 root 노드로 이동</li>
<li>root 노드의 값이 child node 보다 작을 경우, root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복함 (swap)</li>
<li><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_remove%20(1).png" alt="heap_remove (1).png"></li>
</ul>
<h2 id="4-힙-구현"><a href="#4-힙-구현" class="headerlink" title="4. 힙 구현"></a>4. 힙 구현</h2><h3 id="힙과-배열"><a href="#힙과-배열" class="headerlink" title="힙과 배열"></a>힙과 배열</h3><ul>
<li>일반적으로 힙 구현시 배열 자료구조를 활용함</li>
<li>배열은 인덱스가 0번부터 시작하지만, 힙 구현의 편의를 위해, root 노드 인덱스 번호를 1로 지정하면, 구현이 좀더 수월함<ul>
<li>부모 노드 인덱스 번호 (parent node’s index) = 자식 노드 인덱스 번호 (child node’s index) // 2</li>
<li>왼쪽 자식 노드 인덱스 번호 (left child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2</li>
<li>오른쪽 자식 노드 인덱스 번호 (right child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2 + 1<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_array.png" alt="heap_array"></li>
</ul>
</li>
</ul>
<pre><code class="python"># 예1 - 10 노드의 부모 노드 인덱스
2 // 2
</code></pre>
<pre><code>1
</code></pre>
<pre><code class="python"># 예1 - 15 노드의 왼쪽 자식 노드 인덱스 번호
1 * 2
</code></pre>
<pre><code>2
</code></pre>
<pre><code class="python"># 예1 - 15 노드의 오른쪽 자식 노드 인덱스 번호
2 * 2 + 1
</code></pre>
<pre><code>5
</code></pre>
<h3 id="Max-Heap-데이터-삽입-구현"><a href="#Max-Heap-데이터-삽입-구현" class="headerlink" title="Max Heap 데이터 삽입 구현"></a>Max Heap 데이터 삽입 구현</h3><ul>
<li>힙 클래스 구현1 </li>
</ul>
<pre><code class="python">class Heap:
    def __init__(self, data):
        self.heap_array = list()
        self.heap_array.append(None)
        self.heap_array.append(data)
</code></pre>
<pre><code class="python">heap = Heap(1)
heap.heap_array
</code></pre>
<pre><code>[None, 1]
</code></pre>
<ul>
<li>힙 클래스 구현2 - insert1<ul>
<li>인덱스 번호는 1번부터 시작하도록 변경<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_ordinary.png" alt="heap_ordinary"></li>
</ul>
</li>
</ul>
<pre><code class="python">class Heap:
    def __init__(self, data):
        self.heap_array = list()
        self.heap_array.append(None)
        self.heap_array.append(data)
        
    def insert(self, data):
        if len(self.heap_array) == 0:
            self.heap_array.append(None)
            self.heap_array.append(data)
            return True
        
        self.heap_array.append(data)
        return True           
</code></pre>
<ul>
<li>힙 클래스 구현3 - insert2<ul>
<li>삽입한 노드가 부모 노드의 값보다 클 경우, 부모 노드와 삽입한 노드 위치를 바꿈</li>
<li>삽입한 노드가 루트 노드가 되거나, 부모 노드보다 값이 작거나 같을 경우까지 반복</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>특정 노드의 관련 노드 위치 알아내기<ul>
<li>부모 노드 인덱스 번호 (parent node’s index) = 자식 노드 인덱스 번호 (child node’s index) // 2</li>
<li>왼쪽 자식 노드 인덱스 번호 (left child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2</li>
<li>오른쪽 자식 노드 인덱스 번호 (right child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2 + 1<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_insert.png" alt="heap_insert.png"></li>
</ul>
</li>
</ul>
<pre><code class="python">heap = Heap(15)
heap.insert(10)
heap.insert(8)
heap.insert(5)
heap.insert(4)
heap.insert(20)
heap.heap_array
</code></pre>
<pre><code>[None, 20, 10, 15, 5, 4, 8]
</code></pre>
<pre><code class="python">class Heap:
    def __init__(self, data):
        self.heap_array = list()
        self.heap_array.append(None)
        self.heap_array.append(data)
        
    def move_up(self, inserted_idx):
        if inserted_idx &lt;= 1:
            return False
        
        parent_idx = inserted_idx // 2
        # 자식노드가 부모노드보다 작거나 같으면 False 반환하여 self.insert 에서 while문 탈출
        if self.heap_array[inserted_idx] &gt; self.heap_array[parent_idx]:
            return True
        else:
            return False
        
    def insert(self, data):
        if len(self.heap_array) == 0:
            self.heap_array.append(None)
            self.heap_array.append(data)
            return True
        
        self.heap_array.append(data)
        
        inserted_idx = len(self.heap_array) - 1
        
        while self.move_up(inserted_idx):
            parent_idx = inserted_idx // 2
            # 부모노드 자식노드 바꿈
            self.heap_array[inserted_idx], self.heap_array[parent_idx] = self.heap_array[parent_idx], self.heap_array[inserted_idx]
            # inserted_idx 위치가 부모노드로 바뀌었고, 다시 비교필요
            inserted_idx = parent_idx
        
        return True
</code></pre>
<h3 id="Max-Heap-데이터-삭제-구현"><a href="#Max-Heap-데이터-삭제-구현" class="headerlink" title="Max Heap 데이터 삭제 구현"></a>Max Heap 데이터 삭제 구현</h3><ul>
<li>힙 클래스 구현4 - delete1</li>
<li>보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적임<ul>
<li>힙의 용도는 최대값 또는 최소값을 root 노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는 것임<blockquote>
<p>오직 root 만 꺼냄</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<pre><code class="python">class Heap:
    def __init__(self, data):
        self.heap_array = list()
        self.heap_array.append(None)
        self.heap_array.append(data)
    
    def pop(self):
        if len(self.heap_array) &lt;= 1:
            return None
        
        returned_data = self.heap_array[1]
        return returned_data
</code></pre>
<ul>
<li>힙 클래스 구현4 - delete2<ul>
<li>상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드 (일반적으로 가장 마지막에 추가한 노드) 를 root 노드로 이동</li>
<li>root 노드의 값이 child node 보다 작을 경우, root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복함 (swap)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>특정 노드의 관련 노드 위치 알아내기<ul>
<li>부모 노드 인덱스 번호 (parent node’s index) = 자식 노드 인덱스 번호 (child node’s index) // 2</li>
<li>왼쪽 자식 노드 인덱스 번호 (left child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2</li>
<li>오른쪽 자식 노드 인덱스 번호 (right child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2 + 1<br><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/heap_remove.png" alt="heap_remove"></li>
</ul>
</li>
</ul>
<pre><code class="python">heap = Heap(15)
heap.insert(10)
heap.insert(8)
heap.insert(5)
heap.insert(4)
heap.insert(20)
heap.heap_array
</code></pre>
<pre><code>[None, 20, 10, 15, 5, 4, 8]
</code></pre>
<pre><code class="python">heap.pop()
</code></pre>
<pre><code>20
</code></pre>
<pre><code class="python">heap.heap_array
</code></pre>
<pre><code>[None, 15, 10, 8, 5, 4]
</code></pre>
<ul>
<li>move_down 3가지 case</li>
</ul>
<ol>
<li>pop 노드의 자식노드가 자식노드가 없을 때       (left_child_popped_idx &gt;= len(self.heap_array) )</li>
<li>pop 노드의 자식노드가 자식노드를 1개 가졌을 때 (right_child_popped_idx &gt;= len(self.heap_array))</li>
<li>pop 노드의 자식노드의 자시노드가 모두 존재할 때 ()<ol>
<li>자식노드끼리 비교</li>
<li>max heap이니까 더 큰 자식이 root로 올라감</li>
</ol>
</li>
</ol>
<p><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/maxhip_pop_case1-3.png" alt="maxhip_pop_case1-3"></p>
<pre><code class="python">class Heap:
    def __init__(self, data):
        self.heap_array = list()
        self.heap_array.append(None)
        self.heap_array.append(data)
    
    def move_down(self, popped_idx):
        left_child_popped_idx = popped_idx * 2 
        right_child_popped_idx = popped_idx * 2 + 1
        
        # case1: 왼쪽 자식 노드도 없을 때
        if left_child_popped_idx &gt;= len(self.heap_array):
            return False
        # case2: 오른쪽 자식 노드만 없을 때
        elif right_child_popped_idx &gt;= len(self.heap_array):
            if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]:
                return True
            else:
                return False
        # case3: 왼쪽, 오른쪽 자식 노드 모두 있을 때
        else:
            if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx]:
                if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]:
                    return True
                else:
                    return False
            else:
                if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx]:
                    return True
                else:
                    return False
    
    def pop(self):
        if len(self.heap_array) &lt;= 1:
            return None
        
        returned_data = self.heap_array[1]
        self.heap_array[1] = self.heap_array[-1]
        del self.heap_array[-1]
        # 올라간 인덱스이니까 1임
        popped_idx = 1
        
        while self.move_down(popped_idx):
            left_child_popped_idx = popped_idx * 2
            right_child_popped_idx = popped_idx * 2 + 1

            # case2: 오른쪽 자식 노드만 없을 때
            if right_child_popped_idx &gt;= len(self.heap_array):
                if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]:
                    self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]
                    popped_idx = left_child_popped_idx
            # case3: 왼쪽, 오른쪽 자식 노드 모두 있을 때
            else:
                if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx]:
                    if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]:
                        self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]
                        popped_idx = left_child_popped_idx
                else:
                    if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx]:
                        self.heap_array[popped_idx], self.heap_array[right_child_popped_idx] = self.heap_array[right_child_popped_idx], self.heap_array[popped_idx]
                        popped_idx = right_child_popped_idx
        
        return returned_data
    
    def move_up(self, inserted_idx):
        if inserted_idx &lt;= 1:
            return False
        parent_idx = inserted_idx // 2
        if self.heap_array[inserted_idx] &gt; self.heap_array[parent_idx]:
            return True
        else:
            return False

    def insert(self, data):
        if len(self.heap_array) == 1:
            self.heap_array.append(data)
            return True
        
        self.heap_array.append(data)
        inserted_idx = len(self.heap_array) - 1
        
        while self.move_up(inserted_idx):
            parent_idx = inserted_idx // 2
            self.heap_array[inserted_idx], self.heap_array[parent_idx] = self.heap_array[parent_idx], self.heap_array[inserted_idx]
            inserted_idx = parent_idx
        return True    
</code></pre>
<pre><code class="python">
</code></pre>
<h2 id="5-힙-Heap-시간-복잡도"><a href="#5-힙-Heap-시간-복잡도" class="headerlink" title="5. 힙 (Heap) 시간 복잡도"></a>5. 힙 (Heap) 시간 복잡도</h2><ul>
<li>depth (트리의 높이) 를 h라고 표기한다면,</li>
<li>n개의 노드를 가지는 heap 에 데이터 삽입 또는 삭제시, 최악의 경우 root 노드에서 leaf 노드까지 비교해야 하므로 $h = log_2{n} $ 에 가까우므로, 시간 복잡도는 $ O(log{n}) $ <ul>
<li>참고: 빅오 표기법에서 $log{n}$ 에서의 log의 밑은 10이 아니라, 2입니다.</li>
<li>한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 <strong>50%($2^{-1}$)의 실행시간을 단축시킬 수 있다는 것을 의미</strong>함</li>
</ul>
</li>
</ul>
<h1 id="강의에-대해-더-알아보려면"><a href="#강의에-대해-더-알아보려면" class="headerlink" title="강의에 대해 더 알아보려면"></a>강의에 대해 더 알아보려면</h1><p><a target="_blank" rel="noopener" href="https://www.fun-coding.org/">잔재미코딩</a><br><a target="_blank" rel="noopener" href="http://fastcampus.co.kr/">패스트캠퍼스 코딩+알고리즘 완주반</a> </p>
<p>출처 : <a target="_blank" rel="noopener" href="https://www.fun-coding.org/">Dave Lee</a> - Fastcampus 코딩 + 알고리즘 온라인 완주반 </p>

      
       <hr><span style="font-style: italic;color: gray;"> Thanks for reading my post. </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">Title:</span>자료구조</p>
    
    <p><span class="copy-title">Author:</span><a  title="Chaejin Kim">Chaejin Kim</a></p>
    <p><span class="copy-title">Created At:</span>2021-03-08, 19:24:00</p>
    <p><span class="copy-title">Updated At:</span>2021-04-14, 14:27:09</p>
    <span class="copy-title">Url:</span><a class="post-url" href="/2021/03/08/CodeAlgorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" title="자료구조">https://chaejin-jen.github.io/2021/03/08/CodeAlgorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/</a>
    <p>
        <span class="copy-title">Copyright:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#39;Attribution-non-commercial-shared in the same way 4.0&#39;</a> Reprint please keep the original link and author.
    </p>
</div>





    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021 Chaejin Kim
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="전체 화면 전환 단축키 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 572px;
    }
    .nav.fullscreen {
        margin-right: -572px;
    }
    .nav-left {
        width: 150px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 542px;
        }
        .nav.fullscreen {
            margin-right: -542px;
        }
        .nav-left {
            width: 150px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 542px;
            margin-right: -542px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #3390FF;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
