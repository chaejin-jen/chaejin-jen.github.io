<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>운영체제 | Chaejin&#39;s Blog</title>
  <meta name="keywords" content=" Computer Science OS ">
  <meta name="description" content="운영체제 | Chaejin&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="패스트캠퍼스 데이터 사이언스 완주반, 수학 학습목표선형대수1234567선형대수를 이용하여 기하학적 관점에서 데이터를 분해데이터를 바라보는 여러가지 방법고유값 분해, 특잇값 분해 등 행렬을 분석하는 여러 방법선형대수 데이터 분석에 필요한 도구   벡터와 행렬의 연산이 기하학적으로 어떤 의미인지 이해 벡터를 투영분해 투영분해 결과, 직선의 방정식을 벡터 연산으">
<meta property="og:type" content="website">
<meta property="og:title" content="Chaejin&#39;s Blog">
<meta property="og:url" content="https://chaejin-jen.github.io/inging/%EC%88%98%ED%95%99%EB%AA%A9%EC%B0%A8.html">
<meta property="og:site_name" content="Chaejin&#39;s Blog">
<meta property="og:description" content="패스트캠퍼스 데이터 사이언스 완주반, 수학 학습목표선형대수1234567선형대수를 이용하여 기하학적 관점에서 데이터를 분해데이터를 바라보는 여러가지 방법고유값 분해, 특잇값 분해 등 행렬을 분석하는 여러 방법선형대수 데이터 분석에 필요한 도구   벡터와 행렬의 연산이 기하학적으로 어떤 의미인지 이해 벡터를 투영분해 투영분해 결과, 직선의 방정식을 벡터 연산으">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-05T04:51:06.821Z">
<meta property="article:modified_time" content="2021-03-04T07:51:44.000Z">
<meta property="article:author" content="Chaejin Kim">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="hide-list">
        <div class="semicircle" data-title=" close">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>Chaejin Kim</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <i class="iconfont icon-rss"></i>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/chaejin-jen"
               target="_blank">
                
                    <i class="iconfont icon-github"></i>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(10)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="DeepLearning">
                        <i class="fold iconfont icon-right"></i>
                        
                        DeepLearning
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="DeepLearning<--->Bagic3">
                                        
                                        Bagic3
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Algorithm">
                        <i class="fold iconfont icon-right"></i>
                        
                        Algorithm
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Algorithm<--->Basic">
                                        
                                        Basic
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="ComputerScience">
                        <i class="fold iconfont icon-right"></i>
                        
                        ComputerScience
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="ComputerScience<--->Bagic">
                                        
                                        Bagic
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="DataScience">
                        <i class="fold iconfont icon-right"></i>
                        
                        DataScience
                        <small>(5)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="DataScience<--->Math">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Math
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="DataScience<--->MathBagic">
                                                        
                                                        Bagic
                                                        
                                                            <small>(5)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
</ul>
<div class="right-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="10">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="outline-panel" style="display: none">
            <div class="right-title">Outline</div>
            <i class="iconfont icon-list" data-title="카테고리"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="이전"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="대소 문자 구분"></i>
            <i class="iconfont icon-tag" data-title="태그검색"></i>
        </div>
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="검색 "></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="개요보기 "></i>
        </div>        
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm Basic</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Computer Science OS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DeepLearning Framework</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Math Basic</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/08/DataScience/Math/Bagic/%ED%96%89%EB%A0%AC/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="행렬">행렬</span>
            <span class="post-date" title="2021-03-08 20:38:35">2021/03/08</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/08/DataScience/Math/Bagic/%EC%84%A0%ED%98%95%EB%8F%85%EB%A6%BD,%EC%84%A0%ED%98%95%EC%A2%85%EC%86%8D,%EB%9E%AD%ED%81%AC/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="선형독립,선형종속,랭크">선형독립,선형종속,랭크</span>
            <span class="post-date" title="2021-03-08 20:35:48">2021/03/08</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/08/DataScience/Math/Bagic/%EB%B2%A1%ED%84%B0/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="벡터">벡터</span>
            <span class="post-date" title="2021-03-08 20:33:17">2021/03/08</span>
        </a>
        
        <a  class="All ComputerScience Bagic "
           href="/2021/03/07/ComputerScience/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"
           data-tag="Computer Science OS"
           data-author="" >
            <span class="post-title" title="운영체제">운영체제</span>
            <span class="post-date" title="2021-03-07 16:26:55">2021/03/07</span>
        </a>
        
        <a  class="All DeepLearning Bagic3 "
           href="/2021/03/06/DeepLearning/Mit3/mitdeep1/"
           data-tag="DeepLearning Framework"
           data-author="" >
            <span class="post-title" title="밑바닥 부터 시작하는 딥러닝 3 (1탄!)">밑바닥 부터 시작하는 딥러닝 3 (1탄!)</span>
            <span class="post-date" title="2021-03-06 07:26:32">2021/03/06</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/06/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
           data-tag="Algorithm Basic"
           data-author="" >
            <span class="post-title" title="기본 핵심 알고리즘 (정렬, 탐색)">기본 핵심 알고리즘 (정렬, 탐색)</span>
            <span class="post-date" title="2021-03-06 07:26:31">2021/03/06</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/06/DataScience/Math/Bagic/%EC%88%98%ED%95%99%EA%B8%B0%ED%98%B8/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="수학 기호">수학 기호</span>
            <span class="post-date" title="2021-03-06 07:25:54">2021/03/06</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/06/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%B3%B5%EC%9E%A1%EB%8F%84/"
           data-tag="Algorithm Basic"
           data-author="" >
            <span class="post-title" title="알고리즘 복잡도">알고리즘 복잡도</span>
            <span class="post-date" title="2021-03-06 07:25:54">2021/03/06</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/06/CodeAlgorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"
           data-tag="Algorithm Basic"
           data-author="" >
            <span class="post-title" title="자료구조">자료구조</span>
            <span class="post-date" title="2021-03-06 07:25:53">2021/03/06</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/05/DataScience/Math/Bagic/%EC%88%98%EC%97%B4%EC%A7%91%ED%95%A9%EC%9D%98_%ED%95%A9%EA%B3%BC%EA%B3%B1/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="수열 집합의 합과 곱">수열 집합의 합과 곱</span>
            <span class="post-date" title="2021-03-05 14:29:56">2021/03/05</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-ComputerScience/운영체제" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">운영체제</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="ComputerScience">ComputerScience</a> > 
            
            <a  data-rel="ComputerScience&lt;---&gt;Bagic">Bagic</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">Computer Science OS</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2021-03-10 23:52:48'>2021-03-07 16:26</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%AA%A9%EC%B0%A8"><span class="toc-text">목차</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%ED%95%A0"><span class="toc-text">운영체제 역할</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A5%BC-%EC%99%9C-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%A0%EA%B9%8C"><span class="toc-text">운영체제를 왜 배워야 할까?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%ED%95%A0-1"><span class="toc-text">운영체제 역할</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C"><span class="toc-text">대표적인 운영체제</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%89%AC%EC%96%B4%EA%B0%80%EA%B8%B0-OS%EB%8A%94-%EB%A7%8C%EB%93%A4%EA%B8%B0%EA%B0%80-%EC%89%BD%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4"><span class="toc-text">쉬어가기: OS는 만들기가 쉽지 않습니다.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%ED%95%A0-2"><span class="toc-text">운영체제 역할</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%ED%95%A01-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%90%EC%9B%90-System-Resource-%EA%B4%80%EB%A6%AC%EC%9E%90"><span class="toc-text">운영체제 역할1: 시스템 자원(System Resource) 관리자</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%ED%95%A02-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%99%80-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%84%EC%9D%98-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98-%EC%A7%80%EC%9B%90"><span class="toc-text">운영체제 역할2: 사용자와 컴퓨터간의 커뮤니케이션 지원</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%97%AD%ED%95%A03-%EC%BB%B4%ED%93%A8%ED%84%B0-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%99%80-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EC%A0%9C%EC%96%B4"><span class="toc-text">운영체제 역할3: 컴퓨터 하드웨어와 프로그램을 제어</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8"><span class="toc-text">운영체제와 응용 프로그램</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4%EB%9E%80"><span class="toc-text">응용 프로그램이란?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B0%84%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%A0%95%EB%A6%AC"><span class="toc-text">운영체제와 응용 프로그램간의 관계 정리</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B0%84%EC%9D%98-%EA%B4%80%EA%B3%84-1"><span class="toc-text">운영체제와 응용 프로그램간의 관계(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B0%84%EC%9D%98-%EA%B4%80%EA%B3%84-2"><span class="toc-text">운영체제와 응용 프로그램간의 관계(2)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%89%AC%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94"><span class="toc-text">쉬어가기: 운영체제는 어디에 있을까요?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EB%B3%B5%EC%8A%B5"><span class="toc-text">컴퓨터 구조 복습</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%ED%8F%B0%EB%85%B8%EC%9D%B4%EB%A7%8C-%EA%B5%AC%EC%A1%B0"><span class="toc-text">참고: 폰노이만 구조</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#History%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C"><span class="toc-text">History로 보는 운영체제</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1950-%EB%85%84%EB%8C%80-1960-%EB%85%84%EB%8C%80"><span class="toc-text">1950 년대 ~ 1960 년대</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1950-%EB%85%84%EB%8C%80"><span class="toc-text">1950 년대</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1960-%EB%85%84%EB%8C%80-%EC%B4%88%EA%B8%B0"><span class="toc-text">1960 년대 초기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">배치 처리 시스템</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%8B%A8%EC%A0%90"><span class="toc-text">배치 처리 시스템의 단점</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1960-%EB%85%84%EB%8C%80-%ED%9B%84%EB%B0%98"><span class="toc-text">1960 년대 후반</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%9C%EB%B6%84%ED%95%A0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%A9%80%ED%8B%B0-%ED%83%9C%EC%8A%A4%ED%82%B9"><span class="toc-text">시분할 시스템과 멀티 태스킹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%9C%EB%B6%84%ED%95%A0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">시분할 시스템과 배치 처리 시스템</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1970-1980-%EB%85%84%EB%8C%80"><span class="toc-text">1970 ~ 1980 년대</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1970-%EB%85%84%EB%8C%80"><span class="toc-text">1970 년대</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%89%AC%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EB%B0%9C%EC%97%90-C-%EC%96%B8%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%96%88%EB%8D%98-%EC%9D%B4%EC%9C%A0"><span class="toc-text">쉬어가기: 운영체제 개발에 C 언어가 필요했던 이유</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UNIX-%ED%8A%B9%EC%A7%95"><span class="toc-text">UNIX 특징</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1980-%EB%85%84%EB%8C%80-%E2%80%91-%EA%B0%9C%EC%9D%B8%EC%9A%A9-%EC%BB%B4%ED%93%A8%ED%84%B0"><span class="toc-text">1980 년대 ‑ 개인용 컴퓨터</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1980-%EB%85%84%EB%8C%80-CLI-%E2%80%91%E2%80%91-gt-GUI"><span class="toc-text">1980 년대 (CLI ‑‑&gt; GUI)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLI-vs-GUI"><span class="toc-text">CLI vs GUI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1990-%EC%B5%9C%EA%B7%BC"><span class="toc-text">1990 ~ 최근</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1990-%EB%85%84%EB%8C%80"><span class="toc-text">1990 년대</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%89%AC%EC%96%B4%EA%B0%80%EA%B8%B0-%E2%84%AAiller-Application"><span class="toc-text">쉬어가기: Killer Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1990-%EB%85%84%EB%8C%80-1"><span class="toc-text">1990 년대</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2000-%EB%85%84%EB%8C%80-%EC%9D%B4%ED%9B%84"><span class="toc-text">2000 년대 이후</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-1"><span class="toc-text">정리 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-2"><span class="toc-text">정리 2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C"><span class="toc-text">운영체제 구조 - 시스템 콜</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%89%98-Shell"><span class="toc-text">쉘 (Shell)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%A4%EB%84%90%EA%B3%BC-%EC%89%98"><span class="toc-text">커널과 쉘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API-C-Library"><span class="toc-text">API, C Library</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C"><span class="toc-text">시스템 콜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-Protection-Rings"><span class="toc-text">CPU Protection Rings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%91%90-%EA%B0%80%EC%A7%80-%EB%AA%A8%EB%93%9C"><span class="toc-text">두 가지 모드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C"><span class="toc-text">응용 프로그램과 운영체제</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%EC%9D%80-%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9C%EB%A1%9C-%EC%8B%A4%ED%96%89"><span class="toc-text">시스템콜은 커널 모드로 실행</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%AA%A8%EB%93%9C%EC%99%80-%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9C"><span class="toc-text">사용자 모드와 커널 모드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-example-1"><span class="toc-text">Code example 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-example-2"><span class="toc-text">Code example 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%89%AC%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8"><span class="toc-text">[쉬어가기] 응용 프로그래머와 시스템 프로그래머</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-1"><span class="toc-text">프로세스 스케쥴링 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C-1"><span class="toc-text">배치 처리 시스템</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%B4-%EC%95%88%EC%93%B0%EC%9D%B4%EB%8A%94-%EC%9D%B4%EC%9C%A0"><span class="toc-text">배치 처리 시스템이 안쓰이는 이유</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EB%B6%84%ED%95%A0-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">시분할 시스템</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%80%ED%8B%B0-%ED%83%9C%EC%8A%A4%ED%82%B9"><span class="toc-text">멀티 태스킹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%A4%EC%A0%9C-%EB%A9%80%ED%8B%B0-%ED%83%9C%EC%8A%A4%ED%82%B9"><span class="toc-text">실제 멀티 태스킹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%80%ED%8B%B0-%ED%83%9C%EC%8A%A4%ED%82%B9%EA%B3%BC-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1"><span class="toc-text">멀티 태스킹과 멀티 프로세싱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-1"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-2"><span class="toc-text">프로세스 스케쥴링 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><span class="toc-text">멀티 프로그래밍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-example"><span class="toc-text">Code example</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%E2%80%91-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EB%B3%B5%EC%8A%B5"><span class="toc-text">메모리 계층 ‑ 컴퓨터 구조 복습</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Bus-%E2%80%91-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EB%B3%B5%EC%8A%B5"><span class="toc-text">System Bus ‑ 컴퓨터 구조 복습</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-2"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-1"><span class="toc-text">스케쥴링 알고리즘 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-process-%EB%9E%80"><span class="toc-text">프로세스 (process) 란?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%97%AC%EA%B8%B0%EC%84%9C-%EC%9E%A0%EA%B9%90"><span class="toc-text">여기서 잠깐!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"><span class="toc-text">스케쥴러와 프로세스</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8C%80%ED%91%9C-4-%EA%B0%80%EC%A7%80"><span class="toc-text">스케쥴링 알고리즘 대표 4 가지</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC"><span class="toc-text">FIFO 스케쥴러</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO-%EB%8A%94-%EC%96%B4%EB%94%94%EC%84%9C-%EB%B0%B0%EC%9B%A0%EC%9D%84%EA%B9%8C"><span class="toc-text">FIFO 는 어디서 배웠을까?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B5%9C%EB%8B%A8-%EC%9E%91%EC%97%85-%EC%9A%B0%EC%84%A0-SJF-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC"><span class="toc-text">최단 작업 우선(SJF) 스케쥴러</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%AC%EA%B8%B0%EC%84%9C-%EC%9E%A0%EA%B9%90-RTOS-GPOS"><span class="toc-text">여기서 잠깐! RTOS, GPOS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EA%B8%B0%EB%B0%98-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC"><span class="toc-text">우선순위 기반 스케쥴러</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Round-Robin-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC"><span class="toc-text">Round Robin 스케쥴러</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-3"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-2"><span class="toc-text">스케쥴링 알고리즘 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-Wait"><span class="toc-text">멀티 프로그래밍과 Wait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C"><span class="toc-text">프로세스 상태</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C%EA%B0%84-%EA%B4%80%EA%B3%84"><span class="toc-text">프로세스 상태간 관계</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-3%EA%B0%80%EC%A7%80%EC%9D%B8-%EA%B2%BD%EC%9A%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC-%EB%8F%99%EC%9E%91"><span class="toc-text">프로세스가 3가지인 경우 스케줄러 동작</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-3"><span class="toc-text">스케쥴링 알고리즘 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%84%A0%EC%A0%90%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC"><span class="toc-text">선점형과 비선점형 스케쥴러</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%84%A0%EC%A0%90%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-%EC%B0%A8%EC%9D%B4"><span class="toc-text">선점형과 비선점형 스케쥴러 차이</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-%EA%B5%AC%EB%B6%84"><span class="toc-text">스케쥴러 구분</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%9E%99"><span class="toc-text">랙?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">인터럽트</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EB%9E%80"><span class="toc-text">인터럽트란?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B4%EB%B2%A4%ED%8A%B8%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">이벤트와 인터럽트</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%84%EC%9A%94-%EC%9D%B4%EC%9C%A0"><span class="toc-text">인터럽트 필요 이유</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%B2%98%EB%A6%AC-%EC%98%88"><span class="toc-text">인터럽트 처리 예</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A3%BC%EC%9A%94-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-Interrupt"><span class="toc-text">주요 인터럽트(Interrupt)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%A2%85%EB%A5%98"><span class="toc-text">인터럽트 종류</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">시스템 콜 인터럽트</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C-%EA%B3%A0%EA%B8%89"><span class="toc-text">인터럽트와 시스템 콜 (고급)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%9D%B4%EA%B1%B0-%EB%82%98%EC%A4%91%EC%97%90-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0"><span class="toc-text">이거 나중에 다시보기</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9C%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">사용자&#x2F;커널 모드와 프로세스, 인터럽트</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-IDT"><span class="toc-text">인터럽트와 IDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"><span class="toc-text">인터럽트와 프로세스</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC"><span class="toc-text">인터럽트와 스케쥴러</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD"><span class="toc-text">프로세스 구조와 컨텍스트 스위칭</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD%EC%9D%B4%EB%9E%80"><span class="toc-text">컨텍스트 스위칭이란?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD%EA%B3%BC-%ED%95%A8%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91"><span class="toc-text">메모리 영역과 함수의 동작</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD"><span class="toc-text">메모리 영역</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%95%A8%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91"><span class="toc-text">함수의 동작</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-4"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-%EB%8F%99%EC%9E%91"><span class="toc-text">파이썬에서 동작</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B5%AC%EC%A1%B0"><span class="toc-text">프로세스 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8A%A4%ED%83%9D-%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C%EC%9A%B0"><span class="toc-text">스택 오버플로우</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EC%9B%90%EB%A6%AC"><span class="toc-text">컨텍스트 스위칭 원리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB"><span class="toc-text">PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%98%88"><span class="toc-text">PCB: 리눅스 예</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-5"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EC%A0%95%EB%A6%AC"><span class="toc-text">컨텍스트 스위칭 정리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90"><span class="toc-text">레지스터는 어디에?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EB%8F%99%EC%9E%91"><span class="toc-text">컨텍스트 스위칭 동작</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD-%EC%84%B1%EB%8A%A5"><span class="toc-text">컨텍스트 스위칭 성능</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%97%AC%EA%B8%B0%EC%84%9C-%EC%9E%A0%EA%B9%90-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC"><span class="toc-text">[여기서 잠깐] 컴파일러</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-6"><span class="toc-text">정리</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95-IPC"><span class="toc-text">프로세스간 커뮤니케이션 기법 (IPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC-InterProcess-Communication"><span class="toc-text">IPC(InterProcess Communication)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84-%ED%86%B5%EC%8B%A0%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80"><span class="toc-text">프로세스간 통신이 필요한가?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0"><span class="toc-text">가볍게 생각해보기</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C-%EB%B3%91%EB%A0%AC-%EC%B2%98%EB%A6%AC"><span class="toc-text">fork() 시스템콜 (병렬 처리)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%98%88%EC%8B%9C-1"><span class="toc-text">예시 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%98%88%EC%8B%9C-2-%EC%9B%B9%EC%84%9C%EB%B2%84"><span class="toc-text">예시 2 : 웹서버</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98"><span class="toc-text">파일을 사용한 커뮤니케이션</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file-%EC%82%AC%EC%9A%A9%EC%9D%98-%ED%95%9C%EA%B3%84%EC%A0%90"><span class="toc-text">file 사용의 한계점</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%A4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%98%88"><span class="toc-text">실제 프로세스: 리눅스 예</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%8B%A4%EC%96%91%ED%95%9C-IPC-%EA%B8%B0%EB%B2%95"><span class="toc-text">다양한 IPC 기법</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-7"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%8B%A4%EC%96%91%ED%95%9C-IPC-%EA%B8%B0%EB%B2%95-1"><span class="toc-text">다양한 IPC 기법</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8C%8C%EC%9D%B4%ED%94%84-Pipe"><span class="toc-text">파이프 (Pipe)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8C%8C%EC%9D%B4%ED%94%84-%EC%BD%94%EB%93%9C-%EC%98%88%EC%A0%9C"><span class="toc-text">파이프 코드 예제</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90-message-queue"><span class="toc-text">메시지 큐(message queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90-%EC%BD%94%EB%93%9C-%EC%98%88%EC%A0%9C"><span class="toc-text">메시지 큐 코드 예제</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8C%8C%EC%9D%B4%ED%94%84%EC%99%80-%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%81%90"><span class="toc-text">파이프와 메시지 큐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-VS-message-queue"><span class="toc-text">pipe VS message queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9C"><span class="toc-text">IPC 기법과 커널 모드</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-shared-memory"><span class="toc-text">공유 메모리 (shared memory)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%BD%94%EB%93%9C-%EC%98%88%EC%A0%9C"><span class="toc-text">공유 메모리 코드 예제</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EA%B7%B8%EB%84%90%EA%B3%BC-%EC%86%8C%EC%BC%93-Signal-amp-Socket"><span class="toc-text">시그널과 소켓 (Signal &amp; Socket)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%9C%EA%B7%B8%EB%84%90-signal"><span class="toc-text">시그널 (signal)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A3%BC%EC%9A%94-%EC%8B%9C%EA%B7%B8%EB%84%90"><span class="toc-text">주요 시그널</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%9C%EA%B7%B8%EB%84%90-%EB%8F%99%EC%9E%91"><span class="toc-text">시그널 동작</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%9C%EA%B7%B8%EB%84%90-%EA%B4%80%EB%A0%A8-%EC%BD%94%EB%93%9C-%EC%98%88%EC%A0%9C"><span class="toc-text">시그널 관련 코드 예제</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EC%8B%9C%EA%B7%B8%EB%84%90%EA%B3%BC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"><span class="toc-text">[참고] 시그널과 프로세스</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%86%8C%EC%BC%93-socket"><span class="toc-text">소켓(socket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%86%8C%EC%BC%93-socket-%EA%B3%BC-IPC"><span class="toc-text">소켓(socket)과 IPC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-8"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%BD%94%EB%93%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EA%B1%B0-%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80-%ED%95%9C%EA%B1%B0-%EC%A0%95%EB%A6%AC"><span class="toc-text">코드 돌아가는 거 (지금까지 한거 정리)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread-%EC%8A%A4%EB%A0%88%EB%93%9C"><span class="toc-text">Thread (스레드)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%EB%8A%94-%EA%B0%81%EA%B8%B0-%EC%8B%A4%ED%96%89%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-stack-%EC%A1%B4%EC%9E%AC"><span class="toc-text">Thread는 각기 실행이 가능한 stack 존재</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multi-Thread-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C"><span class="toc-text">Multi Thread (멀티 스레드)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%ED%83%9C%EC%8A%A4%ED%82%B9"><span class="toc-text">멀티 프로세스와 멀티 태스킹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-%EC%9E%A5%EB%8B%A8%EC%A0%90"><span class="toc-text">Thread 장단점</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-%EC%9E%A5%EC%A0%90"><span class="toc-text">Thread 장점</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-%EB%8B%A8%EC%A0%90"><span class="toc-text">Thread 단점</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-vs-Process"><span class="toc-text">Thread vs Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PThread"><span class="toc-text">PThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC-9"><span class="toc-text">정리</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%8F%99%EA%B8%B0%ED%99%94-Synchronization"><span class="toc-text">동기화(Synchronization)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%AC%EA%B8%B0%EC%84%9C-%EC%9E%A0%EA%B9%90-1"><span class="toc-text">여기서 잠깐!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8F%99%EA%B8%B0%ED%99%94-Synchronization-%EC%9D%B4%EC%8A%88"><span class="toc-text">동기화(Synchronization) 이슈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8F%99%EA%B8%B0%ED%99%94-Synchronization-%EC%9D%B4%EC%8A%88-%EC%98%88%EC%A0%9C"><span class="toc-text">동기화(Synchronization) 이슈 예제</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8F%99%EA%B8%B0%ED%99%94-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88"><span class="toc-text">동기화 이슈 해결 방안</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutual-exclusion-%EC%83%81%ED%98%B8-%EB%B0%B0%EC%A0%9C"><span class="toc-text">Mutual exclusion (상호 배제)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8F%99%EA%B8%B0%ED%99%94-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0-%EC%98%88%EC%A0%9C"><span class="toc-text">동기화 이슈 해결 예제</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-Semaphore"><span class="toc-text">세마포어(Semaphore)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"><span class="toc-text">Mutex와 세마포어</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-Semaphore-1"><span class="toc-text">세마포어 (Semaphore)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-Semaphore-%EB%B0%94%EC%81%9C-%EB%8C%80%EA%B8%B0"><span class="toc-text">세마포어 (Semaphore) - 바쁜 대기</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%97%AC%EA%B8%B0%EC%84%9C-%EC%9E%A0%EA%B9%90-2"><span class="toc-text">여기서 잠깐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-Semaphore-%EB%8C%80%EA%B8%B0%ED%81%90"><span class="toc-text">세마포어 (Semaphore) - 대기큐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EC%A3%BC%EC%9A%94-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-%ED%95%A8%EC%88%98-POSIX-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4"><span class="toc-text">참고: 주요 세마포어 함수 (POSIX 세마포어)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-Deadlock-%EC%99%80-%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C-Starvation"><span class="toc-text">교착상태(Deadlock)와 기아상태(Starvation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80"><span class="toc-text">교착상태(deadlock)란?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EB%B0%9C%EC%83%9D-%EC%A1%B0%EA%B1%B4"><span class="toc-text">참고: 교착상태 발생 조건</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95"><span class="toc-text">참고: 교착상태 해결 방법</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%98%88%EB%B0%A9-deadlock-prevention"><span class="toc-text">참고: 교착상태 예방(deadlock prevention)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%ED%94%BC-deadlock-avoidance"><span class="toc-text">참고: 교착상태 회피(deadlock avoidance)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EB%B0%9C%EA%B2%AC-deadlock-detection-%EA%B3%BC-%ED%9A%8C%EB%B3%B5"><span class="toc-text">참고: 교착상태 발견(deadlock detection)과 회복</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C-starvation"><span class="toc-text">기아상태(starvation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EC%95%88"><span class="toc-text">기아상태 해결 방안</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%97%AC%EA%B8%B0%EC%84%9C-%EC%9E%A0%EA%B9%90-3"><span class="toc-text">여기서 잠깐!</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-Virtual-Memory-System"><span class="toc-text">가상 메모리 (Virtual Memory System)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0"><span class="toc-text">가상 메모리가 필요한 이유</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-Virtual-Memory-System-1"><span class="toc-text">가상 메모리 (Virtual Memory System)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-Virtual-Memory-System-%EC%99%80-MMU"><span class="toc-text">가상 메모리 (Virtual Memory System) 와 MMU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98"><span class="toc-text">가상 메모리 메커니즘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-paging-system"><span class="toc-text">페이징 시스템(paging system)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-paging-system-%EC%9D%98-%EC%98%88"><span class="toc-text">페이징 시스템(paging system)의 예</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%A1%B0"><span class="toc-text">페이징 시스템 구조</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%89%AC%EC%97%88%EB%8B%A4-%EA%B0%80%EA%B8%B0-%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%80-%EA%B2%B0%EA%B5%AD-bit%EC%99%80-%EC%97%B0%EA%B2%B0"><span class="toc-text">쉬었다 가기 - 모든 것은 결국 bit와 연결</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-page-table"><span class="toc-text">페이지 테이블(page table)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-MMU-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0"><span class="toc-text">페이징 시스템과 MMU(컴퓨터 구조)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8B%A4%EC%A4%91-%EB%8B%A8%EA%B3%84-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">다중 단계 페이징 시스템</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMU%EC%99%80-TLB-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0"><span class="toc-text">MMU와 TLB(컴퓨터 구조)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EB%B3%B5%EC%8A%B5"><span class="toc-text">메모리 계층 - 컴퓨터 구조 복습</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MMU%EC%99%80-TLB-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-1"><span class="toc-text">MMU와 TLB(컴퓨터 구조)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC"><span class="toc-text">페이징 시스템과 공유 메모리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-Demand-Paging-%EB%98%90%EB%8A%94-Demanded-Paging"><span class="toc-text">요구 페이징 (Demand Paging 또는 Demanded Paging)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%8F%B4%ED%8A%B8-page-fault"><span class="toc-text">페이지 폴트 (page fault)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0"><span class="toc-text">생각해보기</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%A0%95%EC%B1%85-page-replacement-policy"><span class="toc-text">페이지 교체 정책 (page replacement policy)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-FIFO"><span class="toc-text">페이지 교체 알고리즘 (FIFO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-OPT"><span class="toc-text">페이지 교체 알고리즘 (OPT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-LRU"><span class="toc-text">페이지 교체 알고리즘 (LRU)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A7%80%EC%97%AD%EC%84%B1"><span class="toc-text">참고: 메모리 지역성</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%8A%A4%EC%99%91-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-LFU"><span class="toc-text">페이지 스왑 알고리즘 (LFU)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%8A%A4%EC%99%91-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-NUR"><span class="toc-text">페이지 스왑 알고리즘 (NUR)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8A%A4%EB%A0%88%EC%8B%B1-Thrashing"><span class="toc-text">스레싱(Thrashing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-Segmentation"><span class="toc-text">[참고] 세그멘테이션 (Segmentation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95"><span class="toc-text">세그멘테이션 기법</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%B2%95-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95-%EB%B9%84%EA%B5%90"><span class="toc-text">세그멘테이션 기법, 페이징 기법 비교</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%B4%9D%EC%A0%95%EB%A6%AC-%EC%8B%A4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EB%B0%8F-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D"><span class="toc-text">총정리 : 실제 프로세스의 메모리 사용 및 동작 방식</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8B%A4%EC%8B%9C%EC%A0%95%EB%A6%AC"><span class="toc-text">다시정리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A7%88%EC%A7%80%EB%A7%89%EC%A0%95%EB%A6%AC"><span class="toc-text">마지막정리</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">파일 시스템</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%B4-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84-%EC%9D%B4%EC%9C%A0"><span class="toc-text">파일 시스템이 만들어진 이유</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%8B%A4%EC%96%91%ED%95%9C-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">다양한 파일 시스템</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C"><span class="toc-text">파일 시스템과 시스템 콜</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode-%EB%B0%A9%EC%8B%9D-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">inode 방식 파일 시스템</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inode-%EB%B0%A9%EC%8B%9D-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B8%B0%EB%B3%B8%EA%B5%AC%EC%A1%B0"><span class="toc-text">inode 방식 파일 시스템 기본구조</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%8C%8C%EC%9D%BC"><span class="toc-text">inode 구조와 파일</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode-%EA%B5%AC%EC%A1%B0%EC%99%80-%ED%8C%8C%EC%9D%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0"><span class="toc-text">inode 구조와 파일 데이터</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC-%EC%97%94%ED%8A%B8%EB%A6%AC"><span class="toc-text">디렉토리 엔트리</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-Virtual-File-System"><span class="toc-text">가상 파일 시스템(Virtual File System)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9C%A0%EB%8B%89%EC%8A%A4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%99%80-%EA%B0%80%EC%83%81-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">참고: 리눅스(유닉스) 운영체제와 가상 파일 시스템</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0-%ED%8A%B9%EC%88%98-%ED%8C%8C%EC%9D%BC"><span class="toc-text">참고: 특수 파일</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boot"><span class="toc-text">Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B6%80%ED%8C%85-%EA%B3%BC%EC%A0%95"><span class="toc-text">부팅 과정</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Virtual-Machine-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0"><span class="toc-text">Virtual Machine (가상 머신)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Machine-%EA%B5%AC%EB%B6%84"><span class="toc-text">Virtual Machine 구분</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Machine-Type1-native-%EB%98%90%EB%8A%94-bare-metal"><span class="toc-text">Virtual Machine Type1 (native 또는 bare metal)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Machine-Type2"><span class="toc-text">Virtual Machine Type2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-Virtualization-%EC%A0%84%EA%B0%80%EC%83%81%ED%99%94"><span class="toc-text">Full Virtualization(전가상화)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Half-Virtualization-%EB%B0%98%EA%B0%80%EC%83%81%ED%99%94"><span class="toc-text">Half Virtualization(반가상화)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%B5%9C%EA%B7%BC-HW-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%EC%9C%BC%EB%A1%9C-%EC%A0%84%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%84-%EC%84%A0%ED%98%B8"><span class="toc-text">최근 HW 성능 개선으로 전가상화 기술을 선호</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VMWare"><span class="toc-text">VMWare</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVM"><span class="toc-text">KVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%98%90-%EB%8B%A4%EB%A5%B8-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0-Docker-%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0-vs-Docker"><span class="toc-text">또 다른 가상 머신: Docker (가상 머신 vs Docker)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%EC%98%88-%EC%B0%B8%EA%B3%A0"><span class="toc-text">Docker 예 (참고)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EC%83%81-%EB%A8%B8%EC%8B%A0-%EC%A0%95%EB%A6%AC"><span class="toc-text">가상 머신 정리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Virtual-Machine"><span class="toc-text">Java Virtual Machine</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%B4%9D%EC%A0%95%EB%A6%AC"><span class="toc-text">운영체제 총정리</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%A4%EC%A0%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%9D%B4%ED%95%B4"><span class="toc-text">실제 운영체제의 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%89%98-%EC%A2%85%EB%A5%98"><span class="toc-text">쉘 종류</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%A4%EC%A0%9C-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%9D%B4%ED%95%B4-%EB%8B%A4%EC%8B%9C-%EC%A0%95%EB%A6%AC"><span class="toc-text">실제 운영체제의 이해 다시 정리</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%8F%B0-Android"><span class="toc-text">안드로이드 스마트폰 (Android)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B0%80%EB%B3%8D%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-IoT"><span class="toc-text">가볍게 이해하기: IoT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoT-%EC%98%88-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%98%A8%EB%8F%84%EA%B3%84"><span class="toc-text">IoT 예 (스마트 온도계)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoT-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EC%98%88"><span class="toc-text">IoT 하드웨어 예</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoT%EC%99%80-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C"><span class="toc-text">IoT와 운영체제</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- |키|기능|
|-|-|
|`w/W`|**글 목차 확인** 또는 글 목록 보기|
|`s/S`|**디렉토리 숨기기** 또는 열기| -->

<!-- |`j/J`   : 화면을 아래로 내리기|
|`k/K`   : 화면을 위로 올리기|
|`gg/GG` : 글의 맨 위로 올리기|
|`Shift + G/g`|맨 아래로| -->

<hr>
<p>이 글은 패스트캠퍼스의 컴퓨터 공학자 따라잡기 온라인 완주반의 강의를 들으면서 작성되었습니다. 본 자료의 모든 출처는 <strong>Dave Lee 선생님</strong>께 있습니다. </p>
<p>출처 :<br><a target="_blank" rel="noopener" href="https://www.fastcampus.co.kr/">패스트캠퍼스 컴퓨터 공학 전공자 따라잡기 온라인 완주반</a><br><a target="_blank" rel="noopener" href="https://www.fun-coding.org/">잔재미코딩</a></p>
<hr>
<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><p><code>w/W</code> : <strong>글 목차 확인</strong> 또는 글 목록 보기<br><code>s/S</code> : <strong>디렉토리 숨기기</strong> 또는 열기</p>
<!-- # 프로그래밍 분류

![프로그래머종류](/운영체제/프로그래머종류.png) -->

<h1 id="운영체제-역할"><a href="#운영체제-역할" class="headerlink" title="운영체제 역할"></a>운영체제 역할</h1><p>시스템 자원, 응용 프로그램 관리, 효율적 분배</p>
<h2 id="운영체제를-왜-배워야-할까"><a href="#운영체제를-왜-배워야-할까" class="headerlink" title="운영체제를 왜 배워야 할까?"></a>운영체제를 왜 배워야 할까?</h2><p>컴퓨터 사어인스(전공) 필수 과목<br>컴퓨터 구조가 컴퓨터 하드웨어 원리 이해<br>운영체제는 컴퓨터 하드웨어/소프트웨어 전반적인 동작 이해(특히 컴퓨터 소프트웨어 관련 전반적인 동<br>작 기술 이해)<br>효율적인 소프트웨어 동작을 지원하기 위해 자료구조(큐, 스택등) 및 알고리즘이 사용됨</p>
<h2 id="운영체제-역할-1"><a href="#운영체제-역할-1" class="headerlink" title="운영체제 역할"></a>운영체제 역할</h2><h3 id="대표적인-운영체제"><a href="#대표적인-운영체제" class="headerlink" title="대표적인 운영체제"></a>대표적인 운영체제</h3><blockquote>
<p>Windows OS, Mac OS, 그리고 UNIX(유닉스)</p>
</blockquote>
<ul>
<li>UNIX OS<ul>
<li>UNIX 계열 OS<ul>
<li>UNIX와 사용법이나, OS 구조가 유사</li>
</ul>
</li>
<li>LINUX (리눅스) OS<ul>
<li>프로그래머, 전공자</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="쉬어가기-OS는-만들기가-쉽지-않습니다"><a href="#쉬어가기-OS는-만들기가-쉽지-않습니다" class="headerlink" title="쉬어가기: OS는 만들기가 쉽지 않습니다."></a>쉬어가기: OS는 만들기가 쉽지 않습니다.</h4><p>TmaxOS 시연 : 우리나라도 OS를 만들기위해 시도를 함<br>출처: <a target="_blank" rel="noopener" href="https://youtu.be/OylmhpqptkY">https://youtu.be/OylmhpqptkY</a><br>Windows 시연<br>출처: <a target="_blank" rel="noopener" href="https://youtu.be/nA2SQcaB0ok">https://youtu.be/nA2SQcaB0ok</a></p>
<h3 id="운영체제-역할-2"><a href="#운영체제-역할-2" class="headerlink" title="운영체제 역할"></a>운영체제 역할</h3><ul>
<li>운영체제 역할1: 시스템 자원(System Resource) 관리자</li>
<li>운영체제 역할2: 사용자와 컴퓨터간의 커뮤니케이션 지원</li>
<li>운영체제 역할3: 컴퓨터 하드웨어와 응용 프로그램을 제어</li>
</ul>
<h4 id="운영체제-역할1-시스템-자원-System-Resource-관리자"><a href="#운영체제-역할1-시스템-자원-System-Resource-관리자" class="headerlink" title="운영체제 역할1: 시스템 자원(System Resource) 관리자"></a>운영체제 역할1: 시스템 자원(System Resource) 관리자</h4><ul>
<li>Operating System(OS, 운영체제)</li>
<li>시스템 자원(System Resource) = 컴퓨터 하드웨어</li>
<li>CPU (중앙처리장치), Memory (DRAM, RAM)</li>
<li>I/O Devices (입출력장치)<ul>
<li>Monitor, Mouse, Keyboard, Network</li>
</ul>
</li>
<li>저장매체: SSD, HDD (하드디스크)</li>
</ul>
<p><strong>컴퓨터 하드웨어는 스스로 할 수 있는 것이 없습니다.</strong></p>
<ol>
<li><p>CPU: 각 프로그램이 얼마나 CPU를 사용할지를 결정할 수는 없습니다.</p>
</li>
<li><p>Memory: 각 프로그램이 어느 주소에 저장되어야 하는지, 어느 정도의 메모리 공간을 확보해줘야 하는지<br>를 결정할 수는 없습니다.</p>
</li>
<li><p>저장매체(HDD, SSD): 어떻게, 어디에 저장할지는 결정할 수 없습니다.</p>
</li>
<li><p>키보드/마우스: 스스로 표시할 수는 없음<br>그래서 운영체제가 필요합니다.</p>
</li>
</ol>
<p>How did we ever run Computer wihtout OS? (OS 미설치된 노트북) [유튜브링크](<a target="_blank" rel="noopener" href="https://youtu.be/e">https://youtu.be/e</a> 9 FrlIvlN38?t=29s)</p>
<h4 id="운영체제-역할2-사용자와-컴퓨터간의-커뮤니케이션-지원"><a href="#운영체제-역할2-사용자와-컴퓨터간의-커뮤니케이션-지원" class="headerlink" title="운영체제 역할2: 사용자와 컴퓨터간의 커뮤니케이션 지원"></a>운영체제 역할2: 사용자와 컴퓨터간의 커뮤니케이션 지원</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Operating_system_placement_kor.png/180px-Operating_system_placement_kor.png" alt="운영체제 역할2"></p>
<h4 id="운영체제-역할3-컴퓨터-하드웨어와-프로그램을-제어"><a href="#운영체제-역할3-컴퓨터-하드웨어와-프로그램을-제어" class="headerlink" title="운영체제 역할3: 컴퓨터 하드웨어와 프로그램을 제어"></a>운영체제 역할3: 컴퓨터 하드웨어와 프로그램을 제어</h4><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%AD%ED%95%A0.png" alt="운영체제 역할3"></p>
<h2 id="운영체제와-응용-프로그램"><a href="#운영체제와-응용-프로그램" class="headerlink" title="운영체제와 응용 프로그램"></a>운영체제와 응용 프로그램</h2><p>응용프로그램이란? ‑ 소프트웨어 (운영체제, 응용 프로그램), 보통 여러개의 프로세스로 구성</p>
<h3 id="응용-프로그램이란"><a href="#응용-프로그램이란" class="headerlink" title="응용 프로그램이란?"></a>응용 프로그램이란?</h3><ul>
<li><p>프로그램 = 소프트웨어</p>
</li>
<li><p>소프트웨어 = 운영체제, 응용 프로그램(엑셀, 파워포인트, 여러분들이 맏는 프로그램)</p>
</li>
<li><p>응용 프로그램 = Application (일반 PC에서의 프로그램) = App (스마트<br>폰에서 응용 프로그램)</p>
</li>
</ul>
<h3 id="운영체제와-응용-프로그램간의-관계-정리"><a href="#운영체제와-응용-프로그램간의-관계-정리" class="headerlink" title="운영체제와 응용 프로그램간의 관계 정리"></a>운영체제와 응용 프로그램간의 관계 정리</h3><ol>
<li>응용 프로그램을 관리한다.</li>
<li>시스템 자원(System Resource)를 관리한다.</li>
<li>사용자와 컴퓨터간의 커뮤니케이션을 지원</li>
</ol>
<p>-운영체제의 정리<br>    - 사용자가 사용하는 응용 프로그램이 효율적으로 적절하게 동작하도록 지원<br>    - 즉, 응용 프로그램이 요청하는 시스템 리소스를 효율적으로 분배-지원하는 소프트웨어</p>
<h4 id="운영체제와-응용-프로그램간의-관계-1"><a href="#운영체제와-응용-프로그램간의-관계-1" class="headerlink" title="운영체제와 응용 프로그램간의 관계(1)"></a>운영체제와 응용 프로그램간의 관계(1)</h4><ul>
<li><p>운영체제는 응용 프로그램을 관리</p>
</li>
<li><p>응용 프로그램을 실행시킨다.</p>
</li>
<li><p>응용 프로그램간의 권한을 관리해준다.</p>
<ul>
<li>관리자 권한으로 실행</li>
</ul>
</li>
<li><p>응용 프로그램을 사용하는 사용자도 관리</p>
<ul>
<li>로그인</li>
</ul>
</li>
</ul>
<h4 id="운영체제와-응용-프로그램간의-관계-2"><a href="#운영체제와-응용-프로그램간의-관계-2" class="headerlink" title="운영체제와 응용 프로그램간의 관계(2)"></a>운영체제와 응용 프로그램간의 관계(2)</h4><ul>
<li><p>응용 프로그램은 누구나 만들 수 있다.</p>
<ul>
<li><p>응용 프로그램에 무한 반복문을 넣었다.</p>
</li>
<li><p>응용 프로그램을 잘못 작성해서, 프로그램이 다운</p>
</li>
<li><p>모든 파일 삭제 막기 (권한/사용자 관리)</p>
</li>
<li><p>응용 프로그램이 욕심이 많아서, CPU를 자기만 쓰겠다 &lt;‑‑ 운영체제가 막는다.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>그래서 운영체제는 응용 프로그램을 관리</p>
</blockquote>
<h4 id="쉬어가기-운영체제는-어디에-있을까요"><a href="#쉬어가기-운영체제는-어디에-있을까요" class="headerlink" title="쉬어가기: 운영체제는 어디에 있을까요?"></a>쉬어가기: 운영체제는 어디에 있을까요?</h4><p>운영체제는 저장매체(SSD/HDD)에 저장(설치) 됩니다.</p>
<h3 id="컴퓨터-구조-복습"><a href="#컴퓨터-구조-복습" class="headerlink" title="컴퓨터 구조 복습"></a>컴퓨터 구조 복습</h3><p>컴퓨터를 키면? ‑‑&gt; 운영체제는 Memory에 올라게게 됩니다.</p>
<h4 id="참고-폰노이만-구조"><a href="#참고-폰노이만-구조" class="headerlink" title="참고: 폰노이만 구조"></a>참고: 폰노이만 구조</h4><p>현대컴퓨터구조<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8F%B0%EB%85%B8%EC%9D%B4%EB%A7%8C%EA%B5%AC%EC%A1%B0.png" alt="폰노이만구조"></p>
<p>운영체제도 하나의 소프트웨어이기 때문에, 메모리에 올라감</p>
<h1 id="History로-보는-운영체제"><a href="#History로-보는-운영체제" class="headerlink" title="History로 보는 운영체제"></a>History로 보는 운영체제</h1><h2 id="1950-년대-1960-년대"><a href="#1950-년대-1960-년대" class="headerlink" title="1950 년대 ~ 1960 년대"></a>1950 년대 ~ 1960 년대</h2><ul>
<li><p>1950 년대</p>
<ul>
<li>운영체제가 없었음</li>
<li>응용 프로그램이 직접 시스템 자원을 제어하며 실행</li>
</ul>
</li>
<li><p>1960 년대 초반</p>
<ul>
<li>배치 처리 시스템 출현, 운영체제가 출현</li>
</ul>
</li>
<li><p>1960 년대 후반부 정리</p>
<ul>
<li>시분할 시스템/멀티 태스킹/멀티 프로그래밍<ul>
<li>기술: CPU 시간을 잘개 쪼개기</li>
<li>결과: 다중 사용자 지원, 응용 프로그램 동시 실행</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>결과: 다중 사용자 지원, 응용 프로그램 동시 실행</p>
</blockquote>
<h3 id="1950-년대"><a href="#1950-년대" class="headerlink" title="1950 년대"></a>1950 년대</h3><ul>
<li>ENIAC: 첫 번째 컴퓨터</li>
<li>운영체제가 없었습니다.<ul>
<li>1 개의 응용 프로그램을 실행시키기도 바빴습니다.</li>
<li>응용 프로그램이 시스템 자원을 제어</li>
</ul>
</li>
</ul>
<h3 id="1960-년대-초기"><a href="#1960-년대-초기" class="headerlink" title="1960 년대 초기"></a>1960 년대 초기</h3><ul>
<li>프로그램 종류도 많아지고, 사용자도 슬슬 많아지기 시작<ul>
<li>철수: 프로그램 1 ‑ 예상 실행 시간 12 시간</li>
<li>영희: 프로그램 2 ‑ 예상 실행 시작 1 분</li>
<li>프로그램 1 ‑‑&gt; 프로그램 2</li>
<li>프로그램 2 ‑‑&gt; 프로그램 1</li>
</ul>
</li>
<li>배치 처리 시스템(batch processing system) 출현<ul>
<li>여러 응용 프로그램을 등록시켜놓으면, 순차적으로 실행하는 시스템</li>
<li>배치 처리 시스템을 기반으로 운영체제가 출현</li>
</ul>
</li>
</ul>
<h3 id="배치-처리-시스템"><a href="#배치-처리-시스템" class="headerlink" title="배치 처리 시스템"></a>배치 처리 시스템</h3><p>컴퓨터 학과에 컴퓨터 1 대 (배치 처리 시스템을 지원)</p>
<p>컴퓨터 학과에서 프로그램 과제를 내줍니다.</p>
<p>후배님들은 프로그램 실행(테스트)이 어려웠던적이 있습니다.</p>
<h4 id="배치-처리-시스템의-단점"><a href="#배치-처리-시스템의-단점" class="headerlink" title="배치 처리 시스템의 단점"></a>배치 처리 시스템의 단점</h4><ol>
<li><p>컴퓨터 응답 시간 (response time)이 오래 걸릴 수 있다. (앞단에 실행시간이 많이 필요로 하는 응용 프로그램이 실행될 경우)</p>
</li>
<li><p>실행 시간도 오래걸릴 수 있습니다. (CPU가 필요없음에도 응용 프로그램이 CPU를 점유할 수 있기 때문입니다.)</p>
</li>
</ol>
<h3 id="1960-년대-후반"><a href="#1960-년대-후반" class="headerlink" title="1960 년대 후반"></a>1960 년대 후반</h3><ul>
<li>새로운 개념이 제안됨<ul>
<li>시분할 시스템 (Time Sharing System)</li>
<li>멀티 태스킹 (Multi Tasking)</li>
</ul>
</li>
<li>운영체제로 구현되지는 않았음</li>
</ul>
<h3 id="시분할-시스템과-멀티-태스킹"><a href="#시분할-시스템과-멀티-태스킹" class="headerlink" title="시분할 시스템과 멀티 태스킹"></a>시분할 시스템과 멀티 태스킹</h3><p>응용 프로그램이 CPU를 사용하는 시간을 잘개 쪼개서, 여러 개의 응용 프로그램을 동시에 실행하는 기법</p>
<ul>
<li><p><strong>시분할 시스템</strong>: 다중 사용자를 지원하고, 컴퓨터 응답 시간을 최소화하는 시스템</p>
</li>
<li><p><strong>멀티 태스킹</strong>: 단일 CPU에서, 여러 응용 프로그램의 병렬 실행을 가능케 하는 시스템</p>
</li>
<li><p><strong>보통은 시분할 시스템 = 멀티 태스킹</strong></p>
</li>
<li><p><strong>멀티 프로그래밍</strong>: 최대한 CPU를 많이 활용하도록 하는 시스템 (시간대비 CPU 활용도를 높이자)</p>
</li>
</ul>
<h4 id="시분할-시스템과-배치-처리-시스템"><a href="#시분할-시스템과-배치-처리-시스템" class="headerlink" title="시분할 시스템과 배치 처리 시스템"></a>시분할 시스템과 배치 처리 시스템</h4><ul>
<li><p>시분할 시스템/멀티 태스킹</p>
<ul>
<li><p>핵심 기술: 시간을 잘게 쪼개서, 여러 응용 프로그램을 실행</p>
<ul>
<li><p>컴퓨터 응답 시간을 줄일 수 있음 (시분할 시스템, 다중 사용자를 지원)</p>
</li>
<li><p>전체 응용 프로그램의 실행 시간도 줄일 수 있음 (멀티 프로그래밍)</p>
</li>
<li><p>결과적으로, 사용자가 느낄 때에는, 여러 응용 프로그램이 동시에 실행되는 것처럼 보인다. (멀티 태스킹)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1970-1980-년대"><a href="#1970-1980-년대" class="headerlink" title="1970 ~ 1980 년대"></a>1970 ~ 1980 년대</h2><ul>
<li><p>1970 년대</p>
<ul>
<li>본격적으로 운영체제 중요성 부각</li>
<li>현대 운영체제 기술 확립, UNUX OS에 최초 구현</li>
<li>UNIX: 멀티 태스킹, 시분할 시스템, 멀티 프로그래밍 구현</li>
</ul>
</li>
<li><p>1980 년대</p>
<ul>
<li>개인용 컴퓨터</li>
<li>GUI 환경</li>
</ul>
</li>
</ul>
<h3 id="1970-년대"><a href="#1970-년대" class="headerlink" title="1970 년대"></a>1970 년대</h3><ul>
<li>제대로된 운영체제가 나왔다</li>
<li><strong>UNIX (유닉스) OS</strong><ul>
<li>미국 AT&amp;T 사의 벨 연구소</li>
<li>켄톰슨, 데니스 리치</li>
<li>데니스 리치: C언어를 개발</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://youtu.be/H4YRPdRX%E2%84%AAFs">데니스 리치</a></p>
<h3 id="쉬어가기-운영체제-개발에-C-언어가-필요했던-이유"><a href="#쉬어가기-운영체제-개발에-C-언어가-필요했던-이유" class="headerlink" title="쉬어가기: 운영체제 개발에 C 언어가 필요했던 이유"></a>쉬어가기: 운영체제 개발에 C 언어가 필요했던 이유</h3><ul>
<li>1970 년대 이전: Assembly 언어로 소프트웨어 개발<ul>
<li>CPU(명령어), Memory(주소)</li>
<li>컴퓨터마다 각각 다시 개발해줘야 하는 단점</li>
<li>프로그래밍 복잡도가 높음</li>
</ul>
</li>
<li>1970 년대 C언어가 개발된 후:<ul>
<li>컴파일러: 다시 작성할 필요가 없음</li>
<li>프로그래밍 복잡도는 낮음<blockquote>
<p>C 언어를 기반으로 운영체제를 개발했다</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="UNIX-특징"><a href="#UNIX-특징" class="headerlink" title="UNIX 특징"></a>UNIX 특징</h4><ul>
<li>현대 운영체제의 기본 기술을 모두 포함한 최초의 운영체제<ul>
<li>멀티 태스킹, 시분할 시스템, 멀티 프로그래밍<ul>
<li>다중 사용자 지원<br><a target="_blank" rel="noopener" href="https://youtu.be/Aj1n2_qEq5k">UNIX는 어떻게 생겼나?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1980-년대-‑-개인용-컴퓨터"><a href="#1980-년대-‑-개인용-컴퓨터" class="headerlink" title="1980 년대 ‑ 개인용 컴퓨터"></a>1980 년대 ‑ 개인용 컴퓨터</h3><ul>
<li>개인용 컴퓨터 시대<ul>
<li>1980 년대 이전: 대형 컴퓨터를 여러 명이 접속해서 사용 (UNIX)</li>
<li>1980 년대 ~: Personal Computer (PC)</li>
</ul>
</li>
</ul>
<h3 id="1980-년대-CLI-‑‑-gt-GUI"><a href="#1980-년대-CLI-‑‑-gt-GUI" class="headerlink" title="1980 년대 (CLI ‑‑&gt; GUI)"></a>1980 년대 (CLI ‑‑&gt; GUI)</h3><ul>
<li><p>용어 이해: CLI와 GUI</p>
<ul>
<li>CLI (Command Line Interface): 터미널 환경</li>
<li>GUI (Graphical User Interface): GUI 환경</li>
</ul>
</li>
<li><p>1980 년대 초반: 아직 터미널 환경</p>
</li>
<li><p>1980 년대 중후반: GUI 환경 (마우스)<br><a target="_blank" rel="noopener" href="https://youtu.be/f_Q0XPher3o">Apple VS Microsoft OS</a></p>
</li>
</ul>
<h3 id="CLI-vs-GUI"><a href="#CLI-vs-GUI" class="headerlink" title="CLI vs GUI"></a>CLI vs GUI</h3><ul>
<li>CLI: 키보드, 검은 화면</li>
<li>GUI: 마우스</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=cvjLc24VbI8">Macintosh: 마우스를 사용한 OS</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=I1YTahnDy1Y">Apple Macintosh Commercials</a></p>
<h2 id="1990-최근"><a href="#1990-최근" class="headerlink" title="1990 ~ 최근"></a>1990 ~ 최근</h2><h3 id="1990-년대"><a href="#1990-년대" class="headerlink" title="1990 년대"></a>1990 년대</h3><ol>
<li>응용 프로그램 시대 by GUI 환경, 개인용 컴퓨터 (사용자 증대)<ul>
<li>엑셀, 워드 프로세서 등등</li>
<li>Windows OS 대중화<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=lAkuJXGldrM">Windows 95 Commercials</a></li>
</ul>
</li>
</ol>
<h3 id="쉬어가기-Killer-Application"><a href="#쉬어가기-Killer-Application" class="headerlink" title="쉬어가기: Killer Application"></a>쉬어가기: Killer Application</h3><ol>
<li>위닝(축구 게임) 게임 프로그램을 위해 플레이스테이션 기기를 구매했습니다.</li>
<li>엑셀 프로그램을 사용하기 위해서, Windows 컴퓨터를 구매했습니다.</li>
</ol>
<h3 id="1990-년대-1"><a href="#1990-년대-1" class="headerlink" title="1990 년대"></a>1990 년대</h3><ol start="2">
<li>네트워크 기술 발전 ‑ 월드와이드웹(WWW) 인터넷 대중화</li>
<li>오픈 소스 운동 활성화 시작<ul>
<li>UNIX 계열 OS + 응용 프로그램 자체 개발, 소스 오픈</li>
<li>LINUX (리눅스) 운영체제, 소스 오픈, 무료</li>
</ul>
</li>
</ol>
<h3 id="2000-년대-이후"><a href="#2000-년대-이후" class="headerlink" title="2000 년대 이후"></a>2000 년대 이후</h3><ol>
<li>오픈 소스 활성화<ul>
<li>LINUX (리눅스) 운영체제</li>
<li>Apache (아파치, 웹서버)</li>
<li>MySQL (데이터베이스)</li>
<li>요즘… 안드로이드, 딥러닝, 데이터사이언스, IoT 관련</li>
</ul>
</li>
<li>가상 머신, 대용량 병렬 처리 등 활성화</li>
</ol>
<h2 id="정리-1"><a href="#정리-1" class="headerlink" title="정리 1"></a>정리 1</h2><ol>
<li><p>1950 년대: 운영체제 없음 (프로그램이 시스템 자원 직접 제어)</p>
</li>
<li><p>1960 년대: 배치 처리 시스템</p>
</li>
<li><p>1970 년대: 시분할 시스템/멀티 태스킹 시스템 ‑ UNIX OS (C 언어)</p>
</li>
<li><p>1980 년대: GUI, 개인용 컴퓨터</p>
</li>
<li><p>1990 년대: 다양한 응용 프로그램, 인터넷 발달, 오픈 소스 운동 활성화</p>
</li>
<li><p>2000 년대: 오픈 소스 활성화, 가상 머신, 대용량 병렬 처리 등</p>
</li>
</ol>
<h2 id="정리-2"><a href="#정리-2" class="headerlink" title="정리 2"></a>정리 2</h2><ol>
<li>운영체제는 응용 프로그램과 시스템 자원을 제어하고, 관리한다.</li>
<li>응용 프로그램(Application) 용어 이해</li>
<li>배치 처리 시스템, 시분할 시스템, 멀티 태스킹 개념</li>
<li>CLI(터미널) vs GUI 환경 용어 이해</li>
<li>History 전반은 가볍게만 알아두기</li>
</ol>
<h1 id="운영체제-구조-시스템-콜"><a href="#운영체제-구조-시스템-콜" class="headerlink" title="운영체제 구조 - 시스템 콜"></a>운영체제 구조 - 시스템 콜</h1><p><strong>응용 프로그램, 운영체제, 컴퓨터 하드웨어(시스템 리소스) 관계</strong></p>
<p>도서관으로 비유한다면, </p>
<ul>
<li><p>운영체제는 도서관</p>
</li>
<li><p>응용 프로그램을 시민</p>
</li>
<li><p>컴퓨터 하드웨어는 책</p>
</li>
</ul>
<p><strong>운영체제의 역할</strong></p>
<ul>
<li>시민은 도서관에 원하는 책(자원)을 요청함</li>
</ul>
<ul>
<li><p>도서관은 적절한 책(자원)을 찾아서, 시민에게 빌려줌</p>
</li>
<li><p>시민이 기한이 다 되면, 도서관이 해당 책(자원)을 회수함</p>
</li>
</ul>
<p><strong>응용 프로그램, 운영체제, 컴퓨터 하드웨어 관계</strong></p>
<ul>
<li><p>운영체제는 응용 프로그램이 요청하는 메모리를 허가하고, 분배한다.</p>
</li>
<li><p>운영체제는 응용 프로그램이 요청하는 CPU 시간을 제공한다.</p>
</li>
<li><p>운영체제는 응용 프로그래밍 요청하는 IO Devices 사용을 허가/제어한다.</p>
</li>
</ul>
<p><strong>사용자, 응용 프로그램, 운영체제, 컴퓨터 하드웨어와 관계</strong></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/Operating_system_placement_kor.png/180px-Operating_system_placement_kor.png" alt="운영체제 역할2"></p>
<p>출처: 위키피디아</p>
<h2 id="쉘-Shell"><a href="#쉘-Shell" class="headerlink" title="쉘 (Shell)"></a>쉘 (Shell)</h2><p>운영체제는 <strong>사용자 인터페이스</strong> 제공</p>
<blockquote>
<p>사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램 쉘은 터미널 환경(CLI)과, GUI 환경 두 종류로 분류</p>
</blockquote>
<h3 id="커널과-쉘"><a href="#커널과-쉘" class="headerlink" title="커널과 쉘"></a>커널과 쉘</h3><blockquote>
<p>kernel 이란? - OS kernel</p>
</blockquote>
<ol>
<li>(견과류·씨앗의) 알맹이</li>
<li>(사상·주제의) 핵심</li>
</ol>
<blockquote>
<p>shell 이란?</p>
</blockquote>
<ol>
<li>(달걀견과류 등의 딱딱한) 껍데기</li>
<li>고둥 껍데기 모양의 것</li>
</ol>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/kernel%EA%B3%BCshell2.png" alt="kernel과shell"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/kernel%EA%B3%BCshell.png" alt="kernel과shell"></p>
<h2 id="API-C-Library"><a href="#API-C-Library" class="headerlink" title="API, C Library"></a>API, C Library</h2><p>운영체제는 <strong>응용 프로그램을 위한 인터페이스</strong>도 제공</p>
<ul>
<li><p>API (Application Programming Interface)</p>
<ul>
<li>함수로 제공, open()</li>
</ul>
</li>
<li><p>보통은 라이브러리(library) 형태로 제공</p>
<ul>
<li>예시) C library <a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/">https://www.gnu.org/software/libc/</a></li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%A0%84%EB%8B%AC%EA%B5%AC%EC%A1%B0.png" alt="운영체제전달구조"></p>
<h2 id="시스템-콜"><a href="#시스템-콜" class="headerlink" title="시스템 콜"></a>시스템 콜</h2><p><strong>시스템 콜</strong> 또는 <strong>시스템 호출 인터페이스</strong></p>
<p>운영체제가 운영체제 각 기능을 사용할 수 있도록 하는 <strong>명령</strong> 또는 <strong>함수</strong>를 제공</p>
<p>API 내부에는 시스템콜을 호출하는 형태로 만들어지는 경우가 대부분</p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C.png" alt="시스템콜"><br>출처: <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a></p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%A0%84%EB%8B%AC%EA%B5%AC%EC%A1%B02.png" alt="운영체제전달구조2"></p>
<h3 id="CPU-Protection-Rings"><a href="#CPU-Protection-Rings" class="headerlink" title="CPU Protection Rings"></a>CPU Protection Rings</h3><h3 id="두-가지-모드"><a href="#두-가지-모드" class="headerlink" title="두 가지 모드"></a>두 가지 모드</h3><p>대부분은 Ring 3, Ring 0 두가지 모드를 사용 (각각 사용자 모드, 커널 모드)</p>
<ul>
<li>사용자 모드 (user mode): 응용 프로그램이 사용</li>
<li>커널 모드 (kernel mode): OS가 사용, 특권 명령어 실행과 원하는 작업 수행을 위한 자원 접근을 가능케 하는 모드</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/CPU_ProtectionRings.png" alt="CPU_ProtectionRings"></p>
<h3 id="응용-프로그램과-운영체제"><a href="#응용-프로그램과-운영체제" class="headerlink" title="응용 프로그램과 운영체제"></a>응용 프로그램과 운영체제</h3><p>우리가 만드는 프로그램은 맨위에서 놀고 있습니다.</p>
<blockquote>
<p>어떤 명령은 사용자 영역에서 시행되고<br>어떤 명령은 시스템 호출 인터페이스를 통해서 커널영역에서 시행됨</p>
</blockquote>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%91%EC%9A%A9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.png" alt="응용프로그램과운영체제"></p>
<h3 id="시스템콜은-커널-모드로-실행"><a href="#시스템콜은-커널-모드로-실행" class="headerlink" title="시스템콜은 커널 모드로 실행"></a>시스템콜은 커널 모드로 실행</h3><ul>
<li>커널 모드에서만 실행 가능한 기능들이 있음</li>
<li><strong>커널 모드로 실행하려면, 반드시 시스템 콜을 사용해야 함</strong>(거쳐야 함)</li>
<li>시스템 콜은 운영체제 제공</li>
</ul>
<h3 id="사용자-모드와-커널-모드"><a href="#사용자-모드와-커널-모드" class="headerlink" title="사용자 모드와 커널 모드"></a>사용자 모드와 커널 모드</h3><ul>
<li>함부로 응용 프로그램이 전체 컴퓨터 시스템을 헤치지 못함</li>
<li>사용자모드(등본발급 시스템), 시스템콜(특별한신청서), 커널모드(직원 등본 출력)<ul>
<li>주민등록등본은 꼭 동사무소 또는 민원 24 시(정부 사이트)에서 특별한 신청서를 써야만, 발급</li>
<li>동사무소 직원분들은 특별한 권한을 가지고, 주민등록등본 출력 명령을 실행</li>
</ul>
</li>
</ul>
<h3 id="Code-example-1"><a href="#Code-example-1" class="headerlink" title="Code example 1"></a>Code example 1</h3><p>응용프로그램 시행중에도 사용자모드, 커널모드 왔다갔다 거림<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/code1_2.png" alt="code1"></p>
<h3 id="Code-example-2"><a href="#Code-example-2" class="headerlink" title="Code example 2"></a>Code example 2</h3><pre><code class="structure">user    - API
------- - System call-------------------
kernel  - system call을 처리하는 운영체제 함수
</code></pre>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/code2_2.png" alt="code2_2"></p>
<h3 id="쉬어가기-응용-프로그래머와-시스템-프로그래머"><a href="#쉬어가기-응용-프로그래머와-시스템-프로그래머" class="headerlink" title="[쉬어가기] 응용 프로그래머와 시스템 프로그래머"></a>[쉬어가기] 응용 프로그래머와 시스템 프로그래머</h3><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%91%EC%9A%A9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8,%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8.png" alt="응용프로그래머,시스템프로그래머"></p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>운영체제는 <strong>시스템 콜</strong> 제공</li>
<li>프로그래밍 언어별로 운영체제 기능을 활용하기 위해, 시스템 콜을 기반으로 <strong>API</strong> 제공</li>
<li>응용 프로그램은 운영체제 기능 필요시, 해당 <strong>API</strong> 를 사용해서 프로그램을 작성</li>
<li>응용 프로그램이 실행되서, 운영체제 기능이 필요한 <strong>API</strong> 를 호출하면, 시스템 콜이 호출되서, 커널 모드로 변경되어 OS 내부에서 해당 명령이 실행되고, 다시 응용 프로그램으로 돌아간다.<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%91%EC%9A%A9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%A0%95%EB%A6%AC.png" alt="응용프로그램과운영체제정리"></li>
</ul>
<h1 id="프로세스-스케쥴링-1"><a href="#프로세스-스케쥴링-1" class="headerlink" title="프로세스 스케쥴링 1"></a>프로세스 스케쥴링 1</h1><p>배치 처리 시스템, 시분할 시스템, 멀티 태스킹</p>
<h2 id="배치-처리-시스템-1"><a href="#배치-처리-시스템-1" class="headerlink" title="배치 처리 시스템"></a>배치 처리 시스템</h2><ul>
<li>일괄 처리, 배치 처리, batch processing 이라고 부름</li>
<li>컴퓨터 프로그램 실행 요청 순서에 따라 순차적으로 프로그램을 실행하는 방식</li>
<li>한번에 등록된 여러 프로그램을 순차적으로 실행 가능</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%B0%B0%EC%B9%98%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C.png" alt="배치처리시스템"></p>
<p>FIFO(First In First Out) - 데이터 구조 큐와 비슷</p>
<h2 id="배치-처리-시스템이-안쓰이는-이유"><a href="#배치-처리-시스템이-안쓰이는-이유" class="headerlink" title="배치 처리 시스템이 안쓰이는 이유"></a>배치 처리 시스템이 안쓰이는 이유</h2><ul>
<li>요구사항 : 여러 프로그램을 순차적으로 실행시킬 수 있도록 해주세요!<ul>
<li>어떤 프로그램은 실행이 너무 시간이 많이 걸려서, 다른 프로그램이 실행하는데 시간을 많이 기다려야 한다.<ul>
<li>어플리케이션 실행시간을 예측해서 빠른순으로 못하니까</li>
</ul>
</li>
</ul>
</li>
<li>MP 3 음악을 들으면서, 문서 작성을 하고 싶어요! (동시에 여러 응용 프로그램 실행)</li>
<li>여러 사용자가 동시에 하나의 컴퓨터를 쓰려면 어떻게 해야 하나요? (다중 사용자 지원)<blockquote>
<p>멀티 프로그래밍/시분할 시스템이 나왔다</p>
</blockquote>
</li>
</ul>
<h2 id="시분할-시스템"><a href="#시분할-시스템" class="headerlink" title="시분할 시스템"></a>시분할 시스템</h2><p>다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화하는 시스템<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8B%9C%EB%B6%84%ED%95%A0%EC%8B%9C%EC%8A%A4%ED%85%9C.png" alt="시분할시스템"></p>
<h2 id="멀티-태스킹"><a href="#멀티-태스킹" class="headerlink" title="멀티 태스킹"></a>멀티 태스킹</h2><p>단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템</p>
<ul>
<li>MP 3 음악을 들으며, 문서 작성하는 상황 그림<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9.png" alt="멀티태스킹"></li>
</ul>
<h3 id="실제-멀티-태스킹"><a href="#실제-멀티-태스킹" class="headerlink" title="실제 멀티 태스킹"></a>실제 멀티 태스킹</h3><ul>
<li>1000 밀리초(ms) = 1 초</li>
<li>10 ~ 20 ms 단위로도 실행 응용 프로그램이 바뀌더라</li>
<li>사용자에게는 동시에 실행되는 것처럼 보임</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B92.png" alt="멀티태스킹2"></p>
<h2 id="멀티-태스킹과-멀티-프로세싱"><a href="#멀티-태스킹과-멀티-프로세싱" class="headerlink" title="멀티 태스킹과 멀티 프로세싱"></a>멀티 태스킹과 멀티 프로세싱</h2><p>-멀티 태스킹: 단일 CPU<br>-멀티 프로세싱: 여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 극대화시키는 시스템<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9%EA%B3%BC%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1%EB%B9%84%EA%B5%90.png" alt="멀티태스킹과멀티프로세싱비교"></p>
<p>출처: <a target="_blank" rel="noopener" href="http://donghoson.tistory.com/15">http://donghoson.tistory.com/15</a></p>
<h2 id="정리-1"><a href="#정리-1" class="headerlink" title="정리"></a>정리</h2><ul>
<li>배치 처리 시스템:</li>
<li>시분할 시스템: 다중 사용자 지원, 응답시간 최소화 시스템</li>
<li>멀티 태스킹: 동시 실행하는 것 처럼 보이도록 하는 시스템</li>
<li>멀티 프로세싱: 여러 CPU에 하나의 프로그램을 병렬로 실행시키는 시스템</li>
</ul>
<h1 id="프로세스-스케쥴링-2"><a href="#프로세스-스케쥴링-2" class="headerlink" title="프로세스 스케쥴링 2"></a>프로세스 스케쥴링 2</h1><p>스캐줄링 기법 - 멀티 프로그래밍</p>
<h2 id="멀티-프로그래밍"><a href="#멀티-프로그래밍" class="headerlink" title="멀티 프로그래밍"></a>멀티 프로그래밍</h2><ul>
<li><p>목적 : 최대한 CPU를 많이 활용하도록 하는 시스템</p>
<ul>
<li>시간 대비 CPU 활용도를 높이자</li>
<li>응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있음</li>
</ul>
</li>
<li><p>응용 프로그램은 온전히 CPU를 쓰기 보다, 다른 작업을 중간에 필요로 하는 경우가 많다</p>
<ul>
<li>응용 프로그램이 실행되다가 파일을 읽는다.</li>
<li>응용 프로그램이 실행되다가 프린팅을 한다.<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png" alt="멀티프로그래밍"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D2.png" alt="멀티프로그래밍2"></li>
</ul>
</li>
</ul>
<h2 id="Code-example"><a href="#Code-example" class="headerlink" title="Code example"></a>Code example</h2><h2 id="메모리-계층-‑-컴퓨터-구조-복습"><a href="#메모리-계층-‑-컴퓨터-구조-복습" class="headerlink" title="메모리 계층 ‑ 컴퓨터 구조 복습"></a>메모리 계층 ‑ 컴퓨터 구조 복습</h2><p>Flash Drive - SSD<br>Hard Disk - HDD<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0.png" alt="메모리계층구조"><br>출처: <a target="_blank" rel="noopener" href="http://computationstructures.org/lectures/caches/caches.html">http://computationstructures.org/lectures/caches/caches.html</a></p>
<h2 id="System-Bus-‑-컴퓨터-구조-복습"><a href="#System-Bus-‑-컴퓨터-구조-복습" class="headerlink" title="System Bus ‑ 컴퓨터 구조 복습"></a>System Bus ‑ 컴퓨터 구조 복습</h2><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0.png" alt="컴퓨터구조"></p>
<h2 id="정리-2"><a href="#정리-2" class="headerlink" title="정리"></a>정리</h2><p>실제로는 시분할 시스템, 멀티 프로그래밍, 멀티 태스킹이 유사한 의미로 통용된다.</p>
<blockquote>
<p>핵심</p>
<ul>
<li>여러 응용 프로그램 실행을 가능토록 함</li>
<li>응용 프로그램이 동시에 실행되는 것처럼 보이도록 함</li>
<li>CPU를 쉬지 않고 응용 프로그램을 실행토록 해서, 짧은 시간 안에 응용 플오그램이 실행완료될 수 있도록 함</li>
<li>컴퓨터 응답 시간도 짧게 해서, 다중 사용자도 지원</li>
</ul>
</blockquote>
<p>용어정리  </p>
<blockquote>
<p>시분할 시스템: 다중 사용자 지원, 컴퓨터 응답시간을 최소화하는 시스템</p>
</blockquote>
<blockquote>
<p>멀티 태스킹: 단일 CPU에서 여러 응용 프로그램을 동시에 실행하는 것처럼 보이게 하는 시스템</p>
</blockquote>
<blockquote>
<p>멀티 프로세싱: 여러 CPU에서 하나의 응용 프로그램을 병렬로 실행하게 해서, 실행속도를 높이는 기법</p>
</blockquote>
<blockquote>
<p>멀티 프로그래밍: 최대한 CPU를 일정 시간당 많이 활용하는 시스템</p>
</blockquote>
<h1 id="스케쥴링-알고리즘-1"><a href="#스케쥴링-알고리즘-1" class="headerlink" title="스케쥴링 알고리즘 1"></a>스케쥴링 알고리즘 1</h1><p>스케쥴링 알고리즘 기본<br>FIFO (FCFS), 최단 작업 우선(SJF), 우선순위 기반(정적/동적), Round Robin (시분할 시스템 기반)</p>
<h2 id="프로세스-process-란"><a href="#프로세스-process-란" class="headerlink" title="프로세스 (process) 란?"></a>프로세스 (process) 란?</h2><p>실행 중인 프로그램은 프로세스라고 함</p>
<ul>
<li>프로세스: 메모리에 올려져서, 실행 중인 프로그램</li>
<li>코드 이미지(바이너리): 실행 파일, 예:ELF format<blockquote>
<p>프로세스라는 용어는 작업, task, job 이라는 용어와 혼용</p>
</blockquote>
</li>
</ul>
<h2 id="여기서-잠깐"><a href="#여기서-잠깐" class="headerlink" title="여기서 잠깐!"></a>여기서 잠깐!</h2><ul>
<li>응용 프로그램 =! 프로세스<ul>
<li>응용 프로그램은 여러 개의 프로세스로 이루어질 수 있음</li>
</ul>
</li>
<li>(유닉스 철학) 하나의 응용 프로그램은 여러 개의 프로세스(프로그램)가 상호작용을 하면서 실행될 수도 있음 <blockquote>
<p>간단한 C/C++ 프로그램을 만든다면 ‑&gt; 하나의 프로세스<br>여러 프로그램을 만들어서, 서로 통신하면서 프로그램을 작성할 수도 있음 (<strong>IPC 기법</strong>)</p>
</blockquote>
</li>
</ul>
<h2 id="스케쥴러와-프로세스"><a href="#스케쥴러와-프로세스" class="headerlink" title="스케쥴러와 프로세스"></a>스케쥴러와 프로세스</h2><blockquote>
<p>누가 프로세스 실행을 관리할까요? ‑ 스케쥴러</p>
</blockquote>
<h2 id="스케쥴링-알고리즘-대표-4-가지"><a href="#스케쥴링-알고리즘-대표-4-가지" class="headerlink" title="스케쥴링 알고리즘 대표 4 가지"></a>스케쥴링 알고리즘 대표 4 가지</h2><blockquote>
<p>어느 순서대로 프로세스를 실행시킬까?  </p>
</blockquote>
<ul>
<li>목표<ul>
<li>시분할 시스템 예: 프로세스 응답 시간을 가능한 짧게</li>
<li>멀티 프로그래밍 예: CPU 활용도를 최대로 높혀서, 프로세스를 빨리 실행<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/FIFO_Scheduler.png" alt="FIFO_Scheduler"></li>
</ul>
</li>
</ul>
<h3 id="FIFO-스케쥴러"><a href="#FIFO-스케쥴러" class="headerlink" title="FIFO 스케쥴러"></a>FIFO 스케쥴러</h3><blockquote>
<p>프로세스가 저장매체를 읽는 다든지, 프린팅을 한다든지 하는 작업 없이, 쭉 CPU를 처음부터 끝까지 사용한다. </p>
</blockquote>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/FIFO_Scheduler2.png" alt="FIFO_Scheduler2"></p>
<ul>
<li>가장 간단한 스케쥴러 (배치 처리 시스템)</li>
<li>FCFS (First Come First Served) 스케쥴러 라고도 함</li>
</ul>
<h4 id="FIFO-는-어디서-배웠을까"><a href="#FIFO-는-어디서-배웠을까" class="headerlink" title="FIFO 는 어디서 배웠을까?"></a>FIFO 는 어디서 배웠을까?</h4><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/FIFO.png" alt="FIFO"></p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Queue_FIFO.png" alt="Queue_FIFO"><br>출처: <a target="_blank" rel="noopener" href="http://www.stoimen.com/blog/2012/06/05/computer%E2%80%91algorithms%E2%80%91stack%E2%80%91and%E2%80%91queue%E2%80%91">http://www.stoimen.com/blog/2012/06/05/computer‑algorithms‑stack‑and‑queue‑</a><br>data‑structure/</p>
<h3 id="최단-작업-우선-SJF-스케쥴러"><a href="#최단-작업-우선-SJF-스케쥴러" class="headerlink" title="최단 작업 우선(SJF) 스케쥴러"></a>최단 작업 우선(SJF) 스케쥴러</h3><p>SJF(Shortest Job First) 스케쥴러<br>가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/SJF.png" alt="SJF"></p>
<h3 id="여기서-잠깐-RTOS-GPOS"><a href="#여기서-잠깐-RTOS-GPOS" class="headerlink" title="여기서 잠깐! RTOS, GPOS"></a>여기서 잠깐! RTOS, GPOS</h3><ul>
<li>RealTime OS(RTOS): 응용 프로그램 실시간 성능 보장을 목표로 하는 OS<ul>
<li>정확하게 프로그램 시작, 완료 시간을 보장 (공정에서 사용)</li>
<li>시간에 민감한 환경, 각각의 시간 실행속도도 알 수 있음</li>
<li>Hardware RTOS, Software RTOS</li>
</ul>
</li>
<li>General Purpose OS(GPOS):<ul>
<li>프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS, 예: Windows, Linux등</li>
</ul>
</li>
</ul>
<h3 id="우선순위-기반-스케쥴러"><a href="#우선순위-기반-스케쥴러" class="headerlink" title="우선순위 기반 스케쥴러"></a>우선순위 기반 스케쥴러</h3><ul>
<li>Priority‑Based 스케쥴러<ul>
<li>정적 우선순위<ul>
<li>프로세스마다 우선순위를 미리 지정</li>
</ul>
</li>
<li>동적 우선순위<ul>
<li>스케쥴러가 상황에 따라 우선순위를 동적으로 변경<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Priority_Scheduler.png" alt="Priority_Scheduler"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Round-Robin-스케쥴러"><a href="#Round-Robin-스케쥴러" class="headerlink" title="Round Robin 스케쥴러"></a>Round Robin 스케쥴러</h3><p>시분할 시스템 + 큐<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/RoundRobin_Scheduler.png" alt="RoundRobin_Scheduler"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/RoundRobin_Scheduler2.png" alt="RoundRobin_Scheduler2"></p>
<h2 id="정리-3"><a href="#정리-3" class="headerlink" title="정리"></a>정리</h2><ul>
<li>다양한 기본 스케쥴링 알고리즘<ul>
<li>FIFO (FCFS) 스케쥴링 알고리즘 (배치 처리 시스템)</li>
<li>최단 작업 우선(SJF) 스케쥴링 알고리즘</li>
<li>우선순위 기반 스케쥴링 알고리즘<ul>
<li>정적 우선순위, 동적 우선순위</li>
</ul>
</li>
<li>Round Robin 스케쥴링 알고리즘<ul>
<li>시분할 시스템 기반</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="스케쥴링-알고리즘-2"><a href="#스케쥴링-알고리즘-2" class="headerlink" title="스케쥴링 알고리즘 2"></a>스케쥴링 알고리즘 2</h1><p>프로세스 상태와 스케쥴링</p>
<h2 id="멀티-프로그래밍과-Wait"><a href="#멀티-프로그래밍과-Wait" class="headerlink" title="멀티 프로그래밍과 Wait"></a>멀티 프로그래밍과 Wait</h2><ul>
<li>멀티 프로그래밍: CPU의 활용도를 극대화 하는 스케쥴링 알고리즘</li>
<li>Wait: 간단히 저장매체로부터 파일 읽기를 기다리는 시간으로 가정<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BCwait.png" alt="멀티프로그래밍과wait"></li>
</ul>
<h2 id="프로세스-상태"><a href="#프로세스-상태" class="headerlink" title="프로세스 상태"></a>프로세스 상태</h2><p>스케줄러가 각 시점에 따라 프로세스의 상태를 알고 있어야 한다.<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C.png" alt="프로세스상태"></p>
<ul>
<li>running state: 현재 CPU에서 실행 상태</li>
<li>ready state: CPU에서 실행 가능 상태 (실행 대기 상태)</li>
<li>block state: 특정 이벤트 발생 대기 상태 (예: 프린팅이 다 되었다!)<ul>
<li>저장매체에 파일읽기를 요청했다고 하면, 파일을 다 읽을 때 까지 기다리는 블럭상태가 됨</li>
<li>끝나고 나면 끝났다는 걸 알려주는 특정 이벤트를 발생시켜서 다 끝났다고 알려줌</li>
</ul>
</li>
<li>최신의 알고리즘은 훨신 복잡하게 이리저리 쪼개놓음</li>
</ul>
<h2 id="프로세스-상태간-관계"><a href="#프로세스-상태간-관계" class="headerlink" title="프로세스 상태간 관계"></a>프로세스 상태간 관계</h2><ul>
<li>ready, running, block states<br>input(=특정 이벤트) 대기<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C%EA%B0%84%EA%B4%80%EA%B3%84.png" alt="프로세스상태간관계">  <blockquote>
<p>OS.xlsx -&gt; Process Status (BASIC) &amp; (QUEUE)</p>
</blockquote>
</li>
</ul>
<h2 id="프로세스가-3가지인-경우-스케줄러-동작"><a href="#프로세스가-3가지인-경우-스케줄러-동작" class="headerlink" title="프로세스가 3가지인 경우 스케줄러 동작"></a>프로세스가 3가지인 경우 스케줄러 동작</h2><p>프로세스가 3가지인 경우 다음과 같이 3개의 큐를 사용해 관리하면 됨</p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%83%80%EA%B3%84%ED%95%A0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%ED%95%84%EC%9A%94%ED%95%9C%EC%83%81%ED%99%A9.png" alt="타계할알고리즘필요한상황"><br>해결법<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/3%EA%B0%9C%EC%9D%98_%ED%81%90%EB%A1%9C_%EC%8A%A4%EC%BC%80%EC%A4%84%EA%B4%80%EB%A6%AC_2.png" alt="3개의_큐로_스케줄관리"></p>
<p>*** CPU idle 상태 : CPU가 아무것도 하지않는 상태</p>
<h1 id="스케쥴링-알고리즘-3"><a href="#스케쥴링-알고리즘-3" class="headerlink" title="스케쥴링 알고리즘 3"></a>스케쥴링 알고리즘 3</h1><p>선점형과 비선점형 스케쥴러</p>
<h2 id="선점형과-비선점형-스케쥴러"><a href="#선점형과-비선점형-스케쥴러" class="headerlink" title="선점형과 비선점형 스케쥴러"></a>선점형과 비선점형 스케쥴러</h2><ul>
<li>선점형 스케쥴러 (Preemptive Scheduling)<br>: 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할수 있음</li>
<li>비선점형 스케쥴러 (Non‑preemptive Scheduling)<br>: 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음</li>
</ul>
<h2 id="선점형과-비선점형-스케쥴러-차이"><a href="#선점형과-비선점형-스케쥴러-차이" class="headerlink" title="선점형과 비선점형 스케쥴러 차이"></a>선점형과 비선점형 스케쥴러 차이</h2><p>비선점형: 프로세스가 자발적으로 blocking 상태로 들어가거나, 실행이 끝났을 때만, 다른 프로세스로 교체 가능</p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC.png" alt="비선점형스케쥴러"></p>
<p>선점형: 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체 가능</p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C%EA%B0%84%EA%B4%80%EA%B3%84.png" alt="프로세스상태간관계">  </p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95%EC%84%A0%EC%A0%90%ED%98%95%EB%B9%84%EA%B5%90.png" alt="비선점형선점형비교"></p>
<blockquote>
<p>OS.xlsx ‑&gt; Preemptive</p>
</blockquote>
<h2 id="스케쥴러-구분"><a href="#스케쥴러-구분" class="headerlink" title="스케쥴러 구분"></a>스케쥴러 구분</h2><p>FIFO(FCFS), SJF, Priority‑based 는 어떤 프로세스를 먼저 실행시킬지에 대한 알고리즘<br>RoundRobin 은 시분할 시스템을 위한 기본 알고리즘 (선점형 스케쥴러)</p>
<blockquote>
<p>여러 알고리즘 조합가능!!<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EA%B8%B0%EB%B0%98,%EC%8B%9C%EB%B6%84%ED%95%A0,%EC%84%A0%EC%A0%90%ED%98%95.png" alt="우선순위기반,시분할,선점형.png"></p>
</blockquote>
<h2 id="랙"><a href="#랙" class="headerlink" title="랙?"></a>랙?</h2><p>: 마우스 / 키보드 반응이 느린 경우?</p>
<ul>
<li><p>스케쥴러가 해결해야하는 이슈!</p>
</li>
<li><p>다양하고 복잡한 스케쥴링 알고리즘 필요</p>
</li>
<li><p>리눅스 스케쥴러: O(1), CFS 와 같이 다양한 방식으로 변경시도 중</p>
<ul>
<li>프로세스 수 $\uparrow$</li>
<li>인터렉티브, IO, CPU 중심 프로세스로 미리 구분할 수 있다면 보다 개선된 스케쥴링이 가능함<ul>
<li>우선순위 조정</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h1><p>스케쥴링 알고리즘 4<br>인터럽트 - CPU에 알림</p>
<h2 id="인터럽트란"><a href="#인터럽트란" class="headerlink" title="인터럽트란?"></a>인터럽트란?</h2><ul>
<li>CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요한 경우에 CPU에 알려서 처리하는 기술</li>
</ul>
<blockquote>
<p>어느 한순간 CPU가 실행하는 명령은 하나! 다른 장치와 어떻게 커뮤니케이션을 할까?</p>
</blockquote>
<h3 id="이벤트와-인터럽트"><a href="#이벤트와-인터럽트" class="headerlink" title="이벤트와 인터럽트"></a>이벤트와 인터럽트</h3><ul>
<li>  인터럽트는 일종의 이벤트로 불림</li>
<li>  이벤트에 맞게 운영체제가 처리</li>
<li><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/CPU%EA%B8%B0%EB%B3%B8%EA%B5%AC%EC%A1%B0.png" alt="CPU기본구조"><br>복습. 시그널을 보내주는게 인터럽트<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/event%EB%B0%9C%EC%83%9D%EC%9D%B4interupt.png" alt="event발생이interupt"></li>
</ul>
<h2 id="인터럽트-필요-이유"><a href="#인터럽트-필요-이유" class="headerlink" title="인터럽트 필요 이유"></a>인터럽트 필요 이유</h2><ul>
<li><p>선점형 스케쥴러 구현</p>
<ul>
<li>프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른<br>  프로세스로 교체하기 위해, 현재 프로세스 실행을 중단시킴<ul>
<li> 그러려면, 스케쥴러 코드가 실행이 되서, 현 프로세스 실행을 중지시켜야 함</li>
</ul>
</li>
</ul>
</li>
<li><p>IO Device와의 커뮤니케이션</p>
<ul>
<li>저장매체에서 데이터 처리 완료시, 프로세스를 깨워야 함 (block<br>  state -&gt; ready state)</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/schedbasic2.png"></p>
<ul>
<li>예외 상황 핸들링<ul>
<li>CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나<br>  또는 예외상황이 발생할 경우, CPU가 해당 처리를 할 수 있도록<br>  CPU에 알려줘야 함</li>
</ul>
</li>
</ul>
<h2 id="인터럽트-처리-예"><a href="#인터럽트-처리-예" class="headerlink" title="인터럽트 처리 예"></a>인터럽트 처리 예</h2><ul>
<li>CPU가 프로그램을 실행하고 있을 때,<ul>
<li>입출력 하드웨어 등의 장치 이슈 발생<ul>
<li>  파일 처리가 끝났다는 것을 운영체제에 알려주기</li>
<li>운영체제는 해당 프로세스를 block state에서 실행 대기(ready)<br>  상태로 프로세스 상태 변경하기</li>
</ul>
</li>
<li>또는 예외 상황이 발생<ul>
<li>  0으로 나누는 계산이 발생해서, 예외 발생을 운영체제 알려주기</li>
<li>  운영체제가 해당 프로세스 실행 중지/에러 표시</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="주요-인터럽트-Interrupt"><a href="#주요-인터럽트-Interrupt" class="headerlink" title="주요 인터럽트(Interrupt)"></a>주요 인터럽트(Interrupt)</h2><ul>
<li>주요 인터럽트:<ul>
<li>입출력, <strong>타이머</strong>, 프로세스간 인터럽트, 폴트(0으로 나누기<br>  발생), 중단(강제 실행 중지)등</li>
</ul>
</li>
</ul>
<p>예시</p>
<ol>
<li><p>계산하는 코드에서 0으로 나누는 코드 실행시 (Divide-by-Zero Interrupt) 프로세스 킬 필요</p>
<pre><code class="c">#import &lt;stdio.h&gt;

int main()
&#123;
    printf(&quot;Hello World!\n&quot;);
    int data;
    int divider = 0;
    data = 1 / divider;  // 여기서 인터럽트 발생
    return 0;
&#125;
</code></pre>
<ul>
<li>zero.c 실행하면 다음과 같이 나옴<pre><code class="c">Hello World!
Floathing point exception (core dumped)
</code></pre>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li> 타이머 인터럽트</li>
</ol>
<ul>
<li>선점형 스케줄러(RoundRobin)를 위해 필요<ul>
<li>프로세스 동작과 별도이기 때문에 인터럽트가 필요<br><img src="https://www.fun-coding.org/00_Images/timer.png"></li>
</ul>
</li>
</ul>
<ol start="3">
<li> 입출력(IO) 인터럽트</li>
</ol>
<p><img src="https://www.fun-coding.org/00_Images/iodevice.png"></p>
<h2 id="인터럽트-종류"><a href="#인터럽트-종류" class="headerlink" title="인터럽트 종류"></a>인터럽트 종류</h2><ul>
<li><p>내부 인터럽트</p>
<ul>
<li>주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시<br>  발생<ul>
<li>  <strong>0 으로 나눴을 때</strong></li>
<li>사용자 모드에서 허용되지 않은 명령 또는 공간 접근시<ul>
<li>예를 들면 C언어의 포인터가 주소를 잘못 가르킬 때!<br>하나의 프로세스는 기본적으로 4G를 가지고 있고 0-3GB는 사용자 모드, 3-4GB 는 커널모드에서 접근가능. 만약 포인터가 3-4G를 가르키면 바로 오류발생.</li>
</ul>
</li>
<li>계산 결과가 Overflow/Underflow 날 때<ul>
<li>  변수 표현범위 벗어났을 경우 (32bit 사용 타입에서 $2^31$ 이상의 수 등)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>외부 인터럽트</p>
<ul>
<li>주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)<ul>
<li>  전원 이상</li>
<li>  기계 문제</li>
<li>  <strong>키보드등 IO 관련 이벤트</strong></li>
<li>  <strong>Timer 이벤트</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>  내부 인터럽트는 주로 프로그램 내부에서 발생하므로, 소프트웨어 인터럽트라고도 함</p>
</blockquote>
<blockquote>
<p>  외부 인터럽트는 주로 하드웨어에서 발생하므로, 하드웨어 인터럽트라고도 함</p>
</blockquote>
<h2 id="시스템-콜-인터럽트"><a href="#시스템-콜-인터럽트" class="headerlink" title="시스템 콜 인터럽트"></a>시스템 콜 인터럽트</h2><ul>
<li><p>시스템콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.</p>
</li>
<li><p>시스템 콜 실제 코드</p>
<ul>
<li>eax 레지스터에 시스템 콜 번호를 넣고,</li>
<li>ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,</li>
<li>소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌<pre><code>mov eax, 1 // 시스템콜번호
mov ebx, 0 // 인자
int 0x80 // 소프트웨어 인터럽트 명령
// (instruction 코드) CPU제공 op code로 인터럽트번호를 넣어줌 (시스템 콜은 0x80)
// 사용자 모드의 코드안에서 사용 할 수 있음
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="인터럽트와-시스템-콜-고급"><a href="#인터럽트와-시스템-콜-고급" class="headerlink" title="인터럽트와 시스템 콜 (고급)"></a>인터럽트와 시스템 콜 (고급)</h3><ul>
<li>시스템콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌<ol>
<li> CPU는 사용자 모드를 커널 모드로 바꿔줌</li>
<li>IDT(Interrupt Descriptor Table) 에서 0x80에 해당하는<br> 주소(함수)를 찾아서 실행함</li>
<li>system_call() 함수에서 eax 로부터 시스템 콜 번호를 찾아서, 해당<br> 번호에 맞는 시스템콜 함수로 이동</li>
<li>해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로<br> 변경하고, 다시 해당 프로세스 다음 코드 진행</li>
</ol>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/SYSCALLLIST.png"></p>
<h4 id="이거-나중에-다시보기"><a href="#이거-나중에-다시보기" class="headerlink" title="이거 나중에 다시보기"></a>이거 나중에 다시보기</h4><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C(%EA%B3%A0%EA%B8%89).png" alt="인터럽트와시스템콜(고급)"></p>
<h2 id="사용자-커널-모드와-프로세스-인터럽트"><a href="#사용자-커널-모드와-프로세스-인터럽트" class="headerlink" title="사용자/커널 모드와 프로세스, 인터럽트"></a>사용자/커널 모드와 프로세스, 인터럽트</h2><hr>
<p><img src="https://www.fun-coding.org/00_Images/mode&syscall.png"></p>
<p>정리</p>
<blockquote>
<p>인터럽트는 번호가 정해져있고</p>
<p>번호에 해당하는 코드들 운영체제에 있으며,</p>
<p>번호와 코드들에 대한 정보들이 IDT라는 테이블에 들어있음</p>
</blockquote>
<blockquote>
<p>인터럽트가 발생하면 (= 사용자모드에서 이벤트가 발생하면)</p>
<p>커널 모드로 진입해서 IDT를 찾고 (가장 먼저 IDT 참조)</p>
<p>인터럽트 번호에 해당하는 함수를 실행한뒤</p>
<p>다시 사용자모드로 돌아감</p>
</blockquote>
<hr>
<h3 id="인터럽트와-IDT"><a href="#인터럽트와-IDT" class="headerlink" title="인터럽트와 IDT"></a>인터럽트와 IDT</h3><ul>
<li>인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가<br>  기록되어 있음<ul>
<li>어디에? IDT(Interrupt Descriptor Table) 에 기록<ul>
<li>  이벤트 번호 : 실행코드(=함수)가 저장되어있는 주소</li>
</ul>
</li>
<li>  언제? 컴퓨터 부팅시 운영체제가 기록</li>
<li>어떤 코드? 운영체제 내부 코드<ul>
<li>  커널 영역 (특정한 메모리 공간, 커널 모드에서 실행되는 코드들이 저장되는 영역)에 저장</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>다시 예를 보면,<ul>
<li>  항상 인터럽트 발생시, IDT를 확인</li>
<li>  시스템콜 인터럽트 명령은 0x80 번호가 미리 정의</li>
<li>  인터럽트 0x80 에 해당하는 운영체제 코드는 system_call() 이라는 함수</li>
<li>  즉, IDT에는 0x80 -&gt; system_call() 와 같은 정보가 기록되어 있음</li>
</ul>
</li>
</ul>
<hr>
<p>인터럽트마다 번호가 적혀되어 있다고 했는데 리눅스의 경우 다음과 같음.</p>
<ul>
<li>리눅스의 예<ul>
<li>  0 ~ 31 : 예외상황 인터럽트 (일부는 정의안된 채로 남겨져 있음)</li>
<li>  32 ~ 47 : 하드웨어 인터럽트 (주변장치 종류/갯수에 따라 변경 가능)</li>
<li>  128(0x80) : 시스템 콜</li>
</ul>
</li>
</ul>
<hr>
<h3 id="인터럽트와-프로세스"><a href="#인터럽트와-프로세스" class="headerlink" title="인터럽트와 프로세스"></a>인터럽트와 프로세스</h3><ol>
<li> 프로세스 실행 중 인터럽트 발생</li>
<li> 현 프로세스 실행 중단</li>
<li> 인터럽트 처리 함수 실행 (운영체제)</li>
<li> 현 프로세스 재실행</li>
</ol>
<p><img src="https://www.fun-coding.org/00_Images/IRQ.png"></p>
<hr>
<h2 id="인터럽트와-스케쥴러"><a href="#인터럽트와-스케쥴러" class="headerlink" title="인터럽트와 스케쥴러"></a>인터럽트와 스케쥴러</h2><blockquote>
<p>RoundRobin 스케쥴러 구현 예</p>
</blockquote>
<ul>
<li>수시로 타이머 인터럽트 발생<ul>
<li>운영체제가 타이머 인터럽트 발생 횟수를 기억해서 5번 타이머<br>  인터럽트 발생하면, 현재 프로세스를 다른 프로세스로 바꿔준다</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/timer.png"></p>
<blockquote>
<p>선점형 스케쥴링이 가능!!!!</p>
</blockquote>
<hr>
<h1 id="프로세스-구조와-컨텍스트-스위칭"><a href="#프로세스-구조와-컨텍스트-스위칭" class="headerlink" title="프로세스 구조와 컨텍스트 스위칭"></a>프로세스 구조와 컨텍스트 스위칭</h1><p>프로세스 구조에 대해 자세히 알아보자!</p>
<h2 id="컨텍스트-스위칭이란"><a href="#컨텍스트-스위칭이란" class="headerlink" title="컨텍스트 스위칭이란?"></a>컨텍스트 스위칭이란?</h2><ul>
<li>프로세스 (process)의 일반적인 구성<ul>
<li>text(CODE): 코드</li>
<li>data: 변수/초기화된 데이터</li>
<li>stack: 임시 데이터(함수 호출, 로컬 변수등)<ul>
<li> stack frame 이라고도 부름</li>
</ul>
</li>
<li>heap: 코드에서 동적으로 만들어지는 데이터</li>
</ul>
</li>
<li>PC(Program Counter) + SP(Stack Pointer)<ul>
<li>SP: 스택에 데이터가 채워진 위치를 가리키는 레지스터 (스택프레임의 최상단을 가르킴)</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/process.png"></p>
<hr>
<hr>
<h3 id="메모리-영역과-함수의-동작"><a href="#메모리-영역과-함수의-동작" class="headerlink" title="메모리 영역과 함수의 동작"></a>메모리 영역과 함수의 동작</h3><h4 id="메모리-영역"><a href="#메모리-영역" class="headerlink" title="메모리 영역"></a>메모리 영역</h4><ul>
<li>스택 (stack)<blockquote>
<p>함수안에 지역변수, 매개변수, 함수주소, 리턴주소 등이 들어감<br>FILO, 코드 실행시 스택에 차곡차곡 쌓인다</p>
</blockquote>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%BD%94%EB%93%9C%EC%8B%A4%ED%96%89%EC%8A%A4%ED%83%9D%EC%82%AC%EC%9A%A9.png" alt="코드실행스택사용"></p>
<ul>
<li><p>Heap</p>
<ul>
<li><p>동적 저장공간, 프로그래머 할당(배열 등, 런타임 크기를 결정)</p>
<ul>
<li><p>malloc 할당, free 해제</p>
<pre><code class="c">#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main()
&#123;
  int *data;
  data = (int *) malloc(sizeof(int));
  *data = 1;
  printf(&quot;%d\n&quot;, *data);

  return 0;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/C%EC%96%B8%EC%96%B4%EC%BD%94%EB%93%9C%EB%8F%99%EC%9E%91.png" alt="C언어코드동작"></p>
<h4 id="함수의-동작"><a href="#함수의-동작" class="headerlink" title="함수의 동작"></a>함수의 동작</h4><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD.png" alt="프로세스와컨텍스트스위칭"></p>
<ul>
<li><p>함수안에도 별도의 변수를 지정할 수 있음  </p>
<ul>
<li>함수가 끝나면 사라짐  <blockquote>
<p>함수는 스택이라는 동적으로 할당되는 메모리 공간을 갖고있음<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD2.png" alt="프로세스와컨텍스트스위칭2"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>해야될 일을 쭉 깔아놓고 뒤에서 부터 실행해서 return 이 가르키는 데로 감</p>
</li>
</ul>
<h4 id="정리-4"><a href="#정리-4" class="headerlink" title="정리"></a>정리</h4><ul>
<li>스택과 힙은 동적인 공간<ul>
<li>Stack 은 함수를 위한 공간,</li>
</ul>
</li>
<li>Code 는 못건들여 (프로그램이 실행되면 여기 들어감)</li>
<li>Data 는 ???고, 그래서 Heap 공간 사용  </li>
</ul>
<p><em>c언어의 molloc()으로 특정 메모리 공간을 형성 (동적인 메모리임)</em></p>
<h3 id="파이썬에서-동작"><a href="#파이썬에서-동작" class="headerlink" title="파이썬에서 동작"></a>파이썬에서 동작</h3><p>주의 : TEXT (CODE)부는 원래 중앙 하단처럼 뒤집혀서 들어가 있어야 하지만 보기 편하게 위에서부터 써 둠  </p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%BD%94%EB%93%9C%EC%8B%A4%ED%96%89%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC.png" alt="파이썬코드실행시메모리"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%BD%94%EB%93%9C%EC%8B%A4%ED%96%89%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A7%88%EC%A7%80%EB%A7%89.png" alt="파이썬코드실행메모리마지막"></p>
<blockquote>
<p>EBP</p>
</blockquote>
<p>: 함수들의 주소를 갖고 있는 레지스터로 주로 프로그램이 뻑 날 때 사용됨 (빠른 트래킹을 위함)</p>
<blockquote>
<p>EAX</p>
</blockquote>
<p>: 리턴값 가지고 있음</p>
<h2 id="프로세스-구조"><a href="#프로세스-구조" class="headerlink" title="프로세스 구조"></a>프로세스 구조</h2><p>: Stack, HEAP, DATA(BSS, DATA), TEXT(CODE)</p>
<ul>
<li>DATA를 BSS와 DATA로 분리<ul>
<li>BSS : 초기화 되지 않은 전역변수 </li>
<li>DATA : 초기값이 있는 전역변수<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%98%81%EC%97%AD.png" alt="메모리할당"></li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/processstructure.png"><br>출처: <a target="_blank" rel="noopener" href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832">http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832</a> </p>
<h3 id="스택-오버플로우"><a href="#스택-오버플로우" class="headerlink" title="스택 오버플로우"></a>스택 오버플로우</h3><p><strong>(가볍게 듣자)</strong></p>
<ul>
<li>주로 해커들의 공격에 활용되었음</li>
</ul>
<ul>
<li><p><em>주의 : 엑셀그림에선 스택을 보기편하게 거꿀로 기술함</em></p>
</li>
<li><p>strcpy는 end 기호까지를 무조건 복사하는 함수</p>
<p>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/strcpy%EC%99%80argc.png" alt="strcpy와argc"><br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/strcpy%EC%99%80argc2.png" alt="strcpy와argc2"></p>
</li>
<li><p>마지막에 해커가 원하는 주소를 가르켜서 실행되는 프로그램을 바꿔버림(루트 사용자권한을 얻음)<br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/strcpy%EC%99%80argc3.png" alt="strcpy와argc3"></p>
<p>  <img src="https://www.fun-coding.org/00_Images/processstructure.png"></p>
</li>
</ul>
<blockquote>
<p>출처: <a target="_blank" rel="noopener" href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832">http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832</a></p>
</blockquote>
<hr>
<h2 id="컨텍스트-스위칭-원리"><a href="#컨텍스트-스위칭-원리" class="headerlink" title="컨텍스트 스위칭 원리"></a>컨텍스트 스위칭 원리</h2><p>컨텍스트 스위칭 : CPU가 A란 프로세스를 실행하다가 스케줄러에 인해 B 프로세스를 실행할 때, 이것을 컨텍스트 스위칭 이라 함<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD%EC%9D%B4%EB%9E%80.png" alt="컨텍스트스위칭이란"></p>
<blockquote>
<p>다시 PC, SP에 주목하자. (주요 레지스터)</p>
</blockquote>
<ul>
<li>PC(Program Counter) + SP(Stack Pointer)<ul>
<li>PC는 코드를 가르키고, SP는 리턴 될 스택을 가르킴</li>
</ul>
</li>
</ul>
<blockquote>
<p>Stack, HEAP, DATA(BSS, DATA), TEXT(CODE)</p>
</blockquote>
<!-- > 
> OS.xlsx -> ProcessAllWithCS -->

<!-- ![컨텍스트스위칭두가지비교](/운영체제/컨스1.png)
![컨텍스트스위칭두가지비교](/운영체제/컨스2.png)
![컨스3(PCB)](/운영체제/컨스3(PCB).png) -->

<hr>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>: 프로세스 상태가 저장되어 있는 위치!</p>
<blockquote>
<p>PC, SP는 어디에 저장하나?</p>
</blockquote>
<ul>
<li>Process Control Block (PCB) 에 저장!</li>
<li>Process Context Block 이라고도 함</li>
</ul>
<ol>
<li> Porcess ID</li>
<li><strong>Register (PC, SP 등)</strong><ul>
<li>적합한 레지스터에 덮어씌어 줌  </li>
</ul>
</li>
<li>Scheduling Info (Porcess State)<ul>
<li>ready, block, running 등 어떤 상태인지</li>
</ul>
</li>
<li>Memory Info (메모리 사이즈 limit) …<ul>
<li>관련 리소스<blockquote>
<p>PCB: 프로세스가 실행중인 상태를 캡쳐/구조화해서 저장</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<hr>
<p>CPU에 있는 Program Counter와 Stack Pointer를 PCB에 PC와 SP에 저장하고,</p>
<p>바꿀 프로세스의 PCB에 저장된 PC, SP값을 CPU에 넣어줌 (업데이트)<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80%EC%8A%A4%EC%9C%84%EC%B9%ADPCB.png" alt="컨텍스트와스위칭PCB"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80%EC%8A%A4%EC%9C%84%EC%B9%ADPCB2.png" alt="컨텍스트와스위칭PCB"></p>
<hr>
<h3 id="PCB-리눅스-예"><a href="#PCB-리눅스-예" class="headerlink" title="PCB: 리눅스 예"></a>PCB: 리눅스 예</h3><hr>
<ol>
<li> Porcess ID</li>
<li> Register (PC, SP 등)</li>
<li> Scheduling Info (Porcess State)</li>
<li>Memory Info (메모리 사이즈 limit) …  <img src="https://www.fun-coding.org/00_Images/PCB2.png"></li>
</ol>
<hr>
<h3 id="정리-5"><a href="#정리-5" class="headerlink" title="정리"></a>정리</h3><ul>
<li>프로세스 구조<ul>
<li>Stack, HEAP, DATA(BSS, DATA), TEXT(CODE)</li>
</ul>
</li>
<li>PCB<ul>
<li>프로세스 상태 정보 - PC, SP, 메모리, 스케쥴링 정보등<ul>
<li>얘넨 빨리 실행되어야 하므로 어셈블리어로 되있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="컨텍스트-스위칭-정리"><a href="#컨텍스트-스위칭-정리" class="headerlink" title="컨텍스트 스위칭 정리"></a>컨텍스트 스위칭 정리</h2><ul>
<li>Context Switching, 컨텍스트 스위칭, 한굴말론 문맥 교환<ul>
<li>CPU에 실행할 프로세스를 교체하는 기술</li>
</ul>
</li>
</ul>
<ol>
<li>실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장<ul>
<li>PCB정보를 메인메모리에 저장하냐 마냐는 운영체제에서 관리함  </li>
</ul>
</li>
<li>다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보를 CPU에 넣고, 실행<img src="https://www.fun-coding.org/00_Images/pcb.png"></li>
</ol>
<hr>
<h3 id="레지스터는-어디에"><a href="#레지스터는-어디에" class="headerlink" title="레지스터는 어디에?"></a>레지스터는 어디에?</h3><p>컴퓨터 구조 복습해보자!<br>컨텍스트 스위칭의 동작은 마치 레코드판 같다</p>
<ol>
<li> 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장</li>
<li> 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 <strong>PCB 정보(PC, SP)를 CPU의 레지스터에 넣고</strong>, 실행<blockquote>
<p>디스패치 (dispatch): ready 상태의 프로세스를 running 상태로 바꾸는 것</p>
</blockquote>
</li>
</ol>
<p><img src="https://www.fun-coding.org/00_Images/pcb.png"></p>
<!-- OS.xlsx -> ProcessWithCS -->

<hr>
<h3 id="컨텍스트-스위칭-동작"><a href="#컨텍스트-스위칭-동작" class="headerlink" title="컨텍스트 스위칭 동작"></a>컨텍스트 스위칭 동작</h3><ol>
<li> 프로세스 실행 중 인터럽트 발생</li>
<li> 현 프로세스 실행 중단 (이 때 PCB 업데이트)</li>
<li> 인터럽트 처리 함수 실행 (운영체제)</li>
<li> 현 프로세스 재실행 (PCB 정보를 CPU에 넣고 실행)</li>
</ol>
<p><img src="https://www.fun-coding.org/00_Images/IRQ.png"></p>
<hr>
<h3 id="컨텍스트-스위칭-성능"><a href="#컨텍스트-스위칭-성능" class="headerlink" title="컨텍스트 스위칭 성능"></a>컨텍스트 스위칭 성능</h3><blockquote>
<p>실제로는 굉장히 짧은 시간 (nano second) 단위로, 프로세스 스위칭이 일어남  </p>
</blockquote>
<p><img src="https://www.fun-coding.org/00_Images/pcb.png"></p>
<blockquote>
<p>밀리초(ms) : 1/1,000초 마이크로초(μs) : 1/1,000,000초 나노초(ns) : 1/1,000,000,000초</p>
</blockquote>
<p>컨텍스트 스위칭 시간이 오래 걸리면…  정말 쓸모 없는 애일 꺼임</p>
<p>Q. 어떻게 하면 조금이라도 컨텍스트 스위칭 시간을 짧게 할 수 있을까?</p>
<p>A. C언어가 아니라, 어셈블리어로 컨텍스트 스위칭 코드를 작성하면…</p>
<blockquote>
<p>리눅스의 경우 컨텍스트 스위칭 코드는 각 CPU마다 별도로 존재</p>
</blockquote>
<hr>
<h4 id="여기서-잠깐-컴파일러"><a href="#여기서-잠깐-컴파일러" class="headerlink" title="[여기서 잠깐] 컴파일러"></a>[여기서 잠깐] 컴파일러</h4><ul>
<li><p>초기 컴퓨터 프로그램들은 어셈블리어로 작성</p>
<ul>
<li>서로 다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램 작성</li>
<li>어셈블리어로는 프로그램 작성 속도가 매우 떨어짐</li>
</ul>
</li>
<li><p>컴파일러 등장</p>
<ul>
<li>CPU 아키텍처에 따라서는 컴파일러 프로그램만 만들면 됨, 기존 코드는 <strong>재작성할 필요 없음</strong> (이식성$\uparrow$)</li>
<li>그러나, 어셈블리어로 작성한 코드보다는 속도가 떨어질 수 있음 (속도$\downarrow$)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="정리-6"><a href="#정리-6" class="headerlink" title="정리"></a>정리</h3><ul>
<li>컨텍스트 스위칭<ul>
<li>프로세스 상태 정보를 PCB로부터 CPU에 로드하고, 실행</li>
</ul>
</li>
</ul>
<blockquote>
<p>레코드판 가운데에 핀을 놓는 느낌!</p>
</blockquote>
<hr>
<h1 id="프로세스간-커뮤니케이션-기법-IPC"><a href="#프로세스간-커뮤니케이션-기법-IPC" class="headerlink" title="프로세스간 커뮤니케이션 기법 (IPC)"></a>프로세스간 커뮤니케이션 기법 (IPC)</h1><p>Inter Process Communication</p>
<blockquote>
<p>프로세스들이 서로의 공간을 쉽게 접근할 수 있다면? – 프로세스 데이터/코드가 바뀔 수 있으니 얼마나 위험할까?</p>
</blockquote>
<ul>
<li>  프로세스는 다른 프로세스의 공간을 접근할 수 없다.</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/processstructure.png"></p>
<blockquote>
<p>출처: <a target="_blank" rel="noopener" href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832">http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832</a></p>
</blockquote>
<hr>
<h2 id="IPC-InterProcess-Communication"><a href="#IPC-InterProcess-Communication" class="headerlink" title="IPC(InterProcess Communication)"></a>IPC(InterProcess Communication)</h2><blockquote>
<p>프로세스간에 커뮤니케이션을 해야한다면 어떻게 해야할까?</p>
</blockquote>
<ul>
<li>  프로세스간 통신 방법을 제공함</li>
<li>  IPC: InterProcess Communcation</li>
</ul>
<hr>
<h2 id="프로세스간-통신이-필요한가"><a href="#프로세스간-통신이-필요한가" class="headerlink" title="프로세스간 통신이 필요한가?"></a>프로세스간 통신이 필요한가?</h2><ul>
<li>성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행 <ul>
<li>  CPU core 8~64개</li>
</ul>
</li>
<li>  이 때 프로세스간 상태 확인 및 데이터 송수신이 필요</li>
</ul>
<hr>
<h3 id="가볍게-생각해보기"><a href="#가볍게-생각해보기" class="headerlink" title="가볍게 생각해보기"></a>가볍게 생각해보기</h3><p>여러 프로세스 동시 실행하기</p>
<h4 id="fork-시스템콜-병렬-처리"><a href="#fork-시스템콜-병렬-처리" class="headerlink" title="fork() 시스템콜 (병렬 처리)"></a>fork() 시스템콜 (병렬 처리)</h4><ul>
<li><p>fork() 시스템콜</p>
<ul>
<li><p>fork() 함수로 프로세스 자신을 복사해서 새로운 프로세스로 만들 수 있음</p>
<ul>
<li>  부모 프로세스, 자식 프로세스</li>
</ul>
</li>
<li><p>  프로세스를 fork() 해서, 여러 프로세스를 동시에 실행시킬 수 있음</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>CPU가 한 개일때만 생각하지만, 최근에는 CPU 안에 코어가 8개 되는 경우도 많고, 각 프로세스를 각 코어에 동시 실행 가능(병렬 처리)</p>
</blockquote>
<h4 id="예시-1"><a href="#예시-1" class="headerlink" title="예시 1"></a>예시 1</h4><ul>
<li>1 ~ 10000까지 더하기<ul>
<li>  fork() 함수로 10개 프로세스 만들어서, 각각 1 ~ 1000, 1001 ~ 2000, …. 더하기</li>
<li>  각각 더한 값을 모두 합하면, 더 빠르게 동작 가능</li>
</ul>
</li>
</ul>
<blockquote>
<p>단, 이 때 각 프로세스가 더한 값을 수집해야 하므로, 프로세스간 통신 필요</p>
</blockquote>
<h4 id="예시-2-웹서버"><a href="#예시-2-웹서버" class="headerlink" title="예시 2 : 웹서버"></a>예시 2 : 웹서버</h4><ul>
<li><p>웹서버 예</p>
<ul>
<li>  여러개의 컴퓨터애서 웹브라우저로 요청</li>
<li>  서버컴퓨터에 웹서버라는 프로그램이 각각의 요청에 따라 맞는 html파일을 전송하거나 원하는 걸 해줌</li>
</ul>
</li>
<li><p>클라이언트와 서버</p>
<p>  <img src="https://www.fun-coding.org/00_Images/webserver.png"></p>
</li>
<li><p>웹서버 만들기</p>
<ul>
<li>  웹서버란? 요청이 오면, HTML 파일을 클라이언트에 제공하는 프로그램</li>
<li>  새로운 사용자 요청이 올 때마다, fork() 함수로 새로운 프로세스 만들고, 각 사용자 요청에 즉시 대응</li>
</ul>
</li>
</ul>
<blockquote>
<p>CPU 병렬 처리가 가능하다면, 더 빠른 대응이 가능</p>
<p>단, 이 때 각 프로세스 제어 및 상태 정보 교환을 위해 프로세스간 통신 필요</p>
</blockquote>
<hr>
<h2 id="파일을-사용한-커뮤니케이션"><a href="#파일을-사용한-커뮤니케이션" class="headerlink" title="파일을 사용한 커뮤니케이션"></a>파일을 사용한 커뮤니케이션</h2><blockquote>
<p>프로세스간에 커뮤니케이션을 해야한다면 어떻게 해야할까?</p>
</blockquote>
<ul>
<li>  프로세스간 통신 방법을 제공함</li>
<li>IPC: InterProcess Communcation<ul>
<li>  그 중의 한가지 방법: <strong>file 사용</strong> (저장 매체는 공유가 가능하기 때문)</li>
</ul>
</li>
</ul>
<blockquote>
<p>간단히 다른 프로세스에 전달할 내용을 파일에 쓰고, 다른 프로세스가 해당 파일을 읽으면 됨</p>
</blockquote>
<h3 id="file-사용의-한계점"><a href="#file-사용의-한계점" class="headerlink" title="file 사용의 한계점"></a>file 사용의 한계점</h3><ul>
<li>file을 사용하면, 실시간으로 직접 원하는 프로세스에 데이터 전달이 어려움<ul>
<li>  왜? 해당 프로세스가 파일을 읽어야 하는데… 계속 실시간으로 읽고만 있을 수는 없으니..</li>
</ul>
</li>
</ul>
<blockquote>
<p>그래서 보다 다양한 IPC 기법이 있음</p>
</blockquote>
<hr>
<h2 id="실제-프로세스-리눅스-예"><a href="#실제-프로세스-리눅스-예" class="headerlink" title="실제 프로세스: 리눅스 예"></a>실제 프로세스: 리눅스 예</h2><ul>
<li><p>프로세스간 공간은 완전히 분리되어 있다.</p>
<p>  <img src="https://www.fun-coding.org/00_Images/processmemory.png"></p>
<ul>
<li>어떤 프로세스든지 지정할 수 있는 주소는 0-4GB 까지의 주소, 3-4GB 사이는 운영체제의 주소가 들어감. 0-3GB가 우리가 쓰는 프로그램이 사용하는 공간</li>
<li>(내 램 8GB인데 왜 4GB?) 내부적으로 가상 주소를 물리주소로 바꾸는 기능이 있음. </li>
</ul>
</li>
</ul>
<blockquote>
<p>사용자 모드에서는 커널 공간 접근 불가</p>
</blockquote>
<hr>
<ul>
<li>  커널 공간은 공유한다.</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/processspacewithkernel.png"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/kernel%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%B5%EC%9C%A0.png" alt="kernel메모리공유"></p>
<blockquote>
<p>보다 구체적인 내용은 가상 메모리에서 다룸</p>
</blockquote>
<hr>
<h2 id="다양한-IPC-기법"><a href="#다양한-IPC-기법" class="headerlink" title="다양한 IPC 기법"></a>다양한 IPC 기법</h2><ul>
<li>IPC: InterProcess Communcation<ol>
<li> file 사용 (저장매체는 실시간 $\downarrow$)</li>
<li> Message Queue</li>
<li> Shared Memory</li>
<li> Pipe</li>
<li> Signal</li>
<li> Semaphore</li>
<li> Socket …</li>
</ol>
</li>
</ul>
<blockquote>
<p>2번부터는 모두 <strong>커널 공간</strong>을 사용하는 것임 - 이것이 핵심</p>
</blockquote>
<hr>
<h2 id="정리-7"><a href="#정리-7" class="headerlink" title="정리"></a>정리</h2><ul>
<li>  여러 프로세스 동시 실행을 통한 성능 개선, 복잡한 프로그램을 위해 <em>프로세스간 통신 필요</em></li>
<li>  프로세스간 공간이 완전 분리</li>
<li>프로세스간 통신을 위한 특별한 기법 필요<ul>
<li>  IPC (InterProcess Communication)</li>
</ul>
</li>
<li>대부분의 IPC 기법은 결국 커널 공간을 활용하는 것임<ul>
<li>  이유: 커널 공간은 공유하기 때문</li>
</ul>
</li>
</ul>
<hr>
<h1 id="다양한-IPC-기법-1"><a href="#다양한-IPC-기법-1" class="headerlink" title="다양한 IPC 기법"></a>다양한 IPC 기법</h1><h2 id="파이프-Pipe"><a href="#파이프-Pipe" class="headerlink" title="파이프 (Pipe)"></a>파이프 (Pipe)</h2><ul>
<li>pipe (파이프)<ul>
<li>  기본 파이프는 단방향 통신</li>
<li>fork() 로 자식 프로세스 만들었을 때, 부모와 자식간의 통신  <img src="https://www.fun-coding.org/00_Images/pipe.png"></li>
</ul>
</li>
</ul>
<hr>
<h3 id="파이프-코드-예제"><a href="#파이프-코드-예제" class="headerlink" title="파이프 코드 예제"></a>파이프 코드 예제</h3><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/fork%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C.png" alt="fork시스템콜"></p>
<ul>
<li><p>원래의 유닉스는 포크라는 시스템콜이 있음</p>
</li>
<li><p>fork() 하면 현재 프로세스의 코드를 그대로 복사한 새로운 프로세스가 생성됨</p>
</li>
<li><p>원래껄 부모 프로세스, 새로 생긴걸 자식 프로세스라 함</p>
</li>
<li><p>부모 프로세스의 pid엔 실제 프로세스 ID(정수)가 들어가고, 자식 프로세스 pid=0</p>
</li>
<li><p>코드가 같지만 동작은 다름</p>
<pre><code class="c">char* msg = &quot;Hello Child Process!&quot;;
int main()
&#123;
    char buf[255];
    int fd[2], pid, nbytes;

    if (pipe(fd) &lt; 0)  // pipe(fd) 로 파이프 생성 
        exit(1);
    pid = fork(); // 이 함수 실행 다음 코드부터 부모/자식 프로세스로 나뉘어짐

    if (pid &gt; 0) &#123;  // 부모 프로세스에는 pid가 0이 들어감
        write(fd[1], msg, MSGSIZE); //fd[1]에 씁니다.
        exit(0);
    &#125;
    else &#123;  // 자식 프로세스에는 pid가 실제 프로세스 ID가 들어감
        nbytes = read(fd[0], buf, MSGSIZE); // fd[0]으로 읽음
        printf(&quot;%d %s\n&quot;, nbytes, buf);
        exit(0);
    &#125;
    return 0;
&#125;
</code></pre>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/fork%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%BD%9C%ED%86%B5%EC%8B%A0.png" alt="fork시스템콜통신"></p>
<hr>
<h2 id="메시지-큐-message-queue"><a href="#메시지-큐-message-queue" class="headerlink" title="메시지 큐(message queue)"></a>메시지 큐(message queue)</h2><ul>
<li>큐니까, 기본은 FIFO 정책으로 데이터 전송  <img src="https://www.fun-coding.org/00_Images/queue.png"><ul>
<li>  출처: <a target="_blank" rel="noopener" href="http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/">http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="메시지-큐-코드-예제"><a href="#메시지-큐-코드-예제" class="headerlink" title="메시지 큐 코드 예제"></a>메시지 큐 코드 예제</h3><ul>
<li>A 프로세스<pre><code class="c">msqid = msgget(key, msgflg) // key는 1234, msgflg는 옵션
msgsnd(msqid, &amp;sbuf, buf_length, IPC_NOWAIT)
</code></pre>
</li>
<li>B 프로세스<pre><code class="c">msqid = msgget(key, msgflg) // key는 동일하게 1234로 해야 해당 큐의 msgid를 얻을 수 있음
msgrcv(msqid, &amp;rbuf, MSGSZ, 1, 0)
</code></pre>
</li>
</ul>
<hr>
<h2 id="파이프와-메시지-큐"><a href="#파이프와-메시지-큐" class="headerlink" title="파이프와 메시지 큐"></a>파이프와 메시지 큐</h2><ul>
<li>  message queue는 부모/자식이 아니라, 어느 프로세스간에라도 데이터 송수신이 가능</li>
<li>  먼저 넣은 데이터가, 먼저 읽혀진다.</li>
</ul>
<h3 id="pipe-VS-message-queue"><a href="#pipe-VS-message-queue" class="headerlink" title="pipe VS message queue"></a>pipe VS message queue</h3><ul>
<li>  부모/자식 프로세스간 only or not</li>
<li>  단방향만 가능 or 양방향 가능</li>
</ul>
<hr>
<h2 id="IPC-기법과-커널-모드"><a href="#IPC-기법과-커널-모드" class="headerlink" title="IPC 기법과 커널 모드"></a>IPC 기법과 커널 모드</h2><blockquote>
<p>pipe, message queue 는 모두 kernel 공간의 메모리를 사용합니다.</p>
</blockquote>
<p><img src="https://www.fun-coding.org/00_Images/kernelmessagequeue.png"></p>
<blockquote>
<p>메모리 공간도 kernel/user 로 구분됩니다. 이 부분은 가상 메모리와 함께 다음에 이해해보겠습니다.</p>
</blockquote>
<hr>
<h2 id="공유-메모리-shared-memory"><a href="#공유-메모리-shared-memory" class="headerlink" title="공유 메모리 (shared memory)"></a>공유 메모리 (shared memory)</h2><blockquote>
<p>kernel에 memory 공간을 하나 파는 거</p>
</blockquote>
<ul>
<li>  노골적으로 kernel space에 메모리 공간을 만들고, 해당 공간을 변수처럼 쓰는 방식</li>
<li>  message queue 처럼 FIFO 방식이 아니라, 해당 메모리 주소를 마치 변수처럼 접근하는 방식</li>
<li>  공유메모리 key를 가지고, 여러 프로세스가 접근 가능</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/kernelsharedmemory.png"></p>
<h3 id="공유-메모리-코드-예제"><a href="#공유-메모리-코드-예제" class="headerlink" title="공유 메모리 코드 예제"></a>공유 메모리 코드 예제</h3><ol>
<li>공유 메모리 생성<pre><code class="c">shmid = shmget((key_t)1234, SIZE, IPC_CREAT|0666))
shmaddr = shmat(shmid, (void *)0, 0)
</code></pre>
</li>
<li>공유 메모리에 쓰기<pre><code class="c">strcpy((char *)shmaddr, &quot;Linux Programming&quot;)
</code></pre>
</li>
<li>공유 메모리에서 읽기<pre><code class="c">printf(&quot;%s\n&quot;, (char *)shmaddr)
</code></pre>
</li>
</ol>
<hr>
<p>정리</p>
<ol>
<li>주요 IPC 기법<ul>
<li>pipe<ul>
<li>  단방향</li>
<li>  fork로 (부모와 자식)으로 생성된 관계에서만 통신 됨</li>
</ul>
</li>
<li>message queue<ul>
<li>  양방향</li>
<li>  key값(여러개 만들 수 있음)으로 프로세스간 통신</li>
</ul>
</li>
<li>shared memory<ul>
<li>  커널에 메모리 공간을 만들어서, 키값을 가지고 주소값을 얻어내면 프로세스에서 마치 변수처럼 쓸 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li> 모두 커널 공간을 활용해서 프로세스간 데이터 공유</li>
</ol>
<blockquote>
<p>이상은 기본적인 IPC</p>
</blockquote>
<hr>
<hr>
<h2 id="시그널과-소켓-Signal-amp-Socket"><a href="#시그널과-소켓-Signal-amp-Socket" class="headerlink" title="시그널과 소켓 (Signal &amp; Socket)"></a>시그널과 소켓 (Signal &amp; Socket)</h2><ul>
<li>본래 다른 용도이지만, IPC로도 사용가능한 기법<ul>
<li>  시그널 (signal)</li>
<li>  소켓 (socket)</li>
</ul>
</li>
</ul>
<blockquote>
<p>각각은 알면 알 수록, 깊은 내용 간단하게만 짚고 넘어가기</p>
</blockquote>
<hr>
<h3 id="시그널-signal"><a href="#시그널-signal" class="headerlink" title="시그널 (signal)"></a>시그널 (signal)</h3><ul>
<li>  유닉스에서 30년 이상 사용된 전통적인 기법</li>
<li>  커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법</li>
<li>시그널 (signal) 동작<ul>
<li></li>
<li>  프로그램에서 특정 시그널의 기본 동작 대신 다른 동작을 하도록 구현 가능</li>
<li>  각 프로세스에서 시그널 처리에 대해 다음과 같은 동작 설정 가능</li>
</ul>
<ol>
<li> 시그널 무시</li>
<li> 시그널 블록(블록을 푸는 순간, 해당 프로세스에서 시그널 처리)</li>
<li> 프로그램 안에 등록된 시그널 핸들러로 재정의한 특정 동작 수행</li>
<li> 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행   </li>
</ol>
</li>
</ul>
<blockquote>
<p>Ctrl+C 를 눌러서 프로세스 종료시키기 (시그널 사용 예)</p>
</blockquote>
<hr>
<h4 id="주요-시그널"><a href="#주요-시그널" class="headerlink" title="주요 시그널"></a>주요 시그널</h4><p>미리 정해져 있는 이벤트  </p>
<ul>
<li>시그널 종류와 각 시그널에 따른 기본 동작이 미리 정해져 있음<ul>
<li>  SIGKILL: 프로세스를 죽여라(슈퍼관리자가 사용하는 시그널로, 프로세스는 어떤 경우든 죽도록 되어 있음)</li>
<li>  SIGALARM: 알람을 발생한다</li>
<li>  SIGSTP: 프로세스를 멈춰라(Ctrl + z)</li>
<li>  SIGCONT: 멈춰진 프로세스를 실행해라</li>
<li>  SIGINT: 프로세스에 인터럽트를 보내서 프로세스를 죽여라(Ctrl + c)</li>
<li>  SIGSEGV: 프로세스가 다른 메모리영역을 침범했다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>시그널 종류: kill -l<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/signalkill.png" alt="signalkill"><br>SIGUSER1 SIGUSR2 를 정의해서 프로세스간 통신 가능</p>
</blockquote>
<h4 id="시그널-동작"><a href="#시그널-동작" class="headerlink" title="시그널 동작"></a>시그널 동작</h4><p>프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행</p>
<ul>
<li>  프로그램에서 특정 시그널의 기본 동작 대신 다른 동작을 하도록 구현 가능</li>
<li>각 프로세스에서 시그널 처리에 대해 다음과 같은 동작 설정 가능<ol>
<li> 시그널 무시</li>
<li> 시그널 블록(블록을 푸는 순간, 해당 프로세스에서 시그널 처리)</li>
<li> 프로그램 안에 등록된 시그널 핸들러로 재정의한 특정 동작 수행</li>
<li> 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행</li>
</ol>
</li>
</ul>
<hr>
<h4 id="시그널-관련-코드-예제"><a href="#시그널-관련-코드-예제" class="headerlink" title="시그널 관련 코드 예제"></a>시그널 관련 코드 예제</h4><ol>
<li><p>시그널 핸들러 등록 및 핸들러 구현 예 </p>
<pre><code class="c"> static void signal_handler (int signo) &#123; 
    printf(&quot;Catch SIGINT!\n&quot;);
    exit (EXIT_SUCCESS);
&#125;

int main (void) &#123; 
    if (signal (SIGINT, signal_handler) == SIG_ERR) &#123; 
        printf(&quot;Can&#39;t catch SIGINT!\n&quot;); 
        exit (EXIT_FAILURE); 
    &#125;

    for (;;)
        pause();
    return 0;
&#125;
</code></pre>
</li>
<li><p>시그널 핸들러 무시<br>기본 동작 하지말고 무시하라고 프로그램안에서 재정의 가능</p>
<pre><code class="c">int main (void) &#123;
    if (signal (SIGINT, SIG_IGN) == SIG_ERR) &#123;
            printf(&quot;Can&#39;t catch SIGINT!\n&quot;);
            exit (EXIT_FAILURE);
        &#125;

        for (;;)
            pause();
        return 0;
&#125;
</code></pre>
</li>
</ol>
<hr>
<h4 id="참고-시그널과-프로세스"><a href="#참고-시그널과-프로세스" class="headerlink" title="[참고] 시그널과 프로세스"></a>[참고] 시그널과 프로세스</h4><p>PCB : 프로세스 상태를 저장하는 블록</p>
<ul>
<li>  PCB에 해당 프로세스가 블록 또는 처리해야하는 시그널 관련 정보 관리</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/signalpcb.png"></p>
<ul>
<li>여러가지 자료구조를 갖고있음<ul>
<li>pending : 처리를 대기 중인 시그널을 나타내주는 자료구조</li>
<li>sigpending : 대기하고 있는 시그널이 뭔지 알려주는 자료구조</li>
<li>blocked : 블럭된 애 알려주는 자료구조</li>
<li>sig : 어떤 시그널을 (기본시그널 or 특정시그널)을 사용할지 알려주는 자료구조</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/PCBsignal.png" alt="PCBsignal"></p>
<ul>
<li>PCB에서 해당 프로세스 signal 자료구조 확인해서, 필요한 커널 함수를 호출해서 실행 한 후 사용자 모드로 올라감</li>
<li>만약 특정동작을 프로세스에서 정의했다면 (사용자 모드에 있음), 함수가 기본동작이 아니라 그 동작을 사용자모드로 전환할 때 함</li>
</ul>
<blockquote>
<p>정리 : 커널모드 $\Rightarrow$ 사용자모드</p>
<p>전환시 시그널 처리</p>
</blockquote>
<hr>
<h3 id="소켓-socket"><a href="#소켓-socket" class="headerlink" title="소켓(socket)"></a>소켓(socket)</h3><ul>
<li>  소켓은 네트워크 통신을 위한 기술</li>
<li>기본적으로는 클라이언트와 서버등 두 개의 다른 컴퓨터간의 네트워크 기반 통신을 위한 기술  <img src="https://www.fun-coding.org/00_Images/webserver.png">네트워크 기기를 이용할 수 있는 시스템 콜 이라고 봐도 됨  </li>
</ul>
<hr>
<h4 id="소켓-socket-과-IPC"><a href="#소켓-socket-과-IPC" class="headerlink" title="소켓(socket)과 IPC"></a>소켓(socket)과 IPC</h4><p>레이어드된 프로토콜 기술로? 지금은 넘어가기 (시스템프로그래밍에서 이해하자)<br>자기 컴퓨터 안에서, 또 다른 프로세스 안에서도 사용가능하기 때문에 IPC에서도 사용하게 됨   </p>
<ul>
<li>소켓을 하나의 컴퓨터 안에서, 두 개의 프로세스간에 통신 기법으로 사용 가능</li>
<li>리눅스 커널 내부 네트워크 스택 예  <img src="https://www.fun-coding.org/00_Images/socketIPC.png"><br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/IPCsoket.png" alt="IPCsoket"></li>
</ul>
<hr>
<h2 id="정리-8"><a href="#정리-8" class="headerlink" title="정리"></a>정리</h2><ul>
<li>  다양한 IPC 기법을 활용해서, 프로세스간 통신이 가능하다.</li>
<li>IPC 기법 이외에도 사용할 수 있는 다음 두 가지 기술 개념도 가볍게 알아둡니다.<ul>
<li>  시그널(signal)</li>
<li>  소켓(socket)</li>
</ul>
</li>
</ul>
<blockquote>
<p>실제 관련 코드에 대해서는 시스템 프로그래밍을 통해 실습 과정을 함께 진행해보겠습니다.</p>
</blockquote>
<h1 id="코드-돌아가는-거-지금까지-한거-정리"><a href="#코드-돌아가는-거-지금까지-한거-정리" class="headerlink" title="코드 돌아가는 거 (지금까지 한거 정리)"></a>코드 돌아가는 거 (지금까지 한거 정리)</h1><p>실행 전까지 과정</p>
<ol>
<li>코드 작성 $\rightarrow$ 컴파일<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8B%9C%EC%95%BC%EB%84%93%ED%9E%88%EA%B8%B01.png" alt="시야넓히기1"></li>
<li>코드가 들어감<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90%EC%BD%94%EB%93%9C.png" alt="메모리에코드"></li>
<li>스케줄러 정책에 따라 러닝 스테이트로 바꿔줌<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EC%97%90%EC%84%9C%EB%9F%AC%EB%8B%9D.png" alt="스케줄러에서러닝"></li>
</ol>
<ul>
<li>선점형 스케줄러, 50ms 0.05초 마다 프로세스 상태를 바꿔주겠다(=컨택스트 스위칭을 하겠다)고하면<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%84%A0%EC%A0%90%ED%98%95%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.png" alt="선점형스케줄러"></li>
<li>운영체제에게 알려주는 타이머 인터럽트가 있다고 가정</li>
</ul>
<ol start="4">
<li>인터럽트 사용</li>
</ol>
<ul>
<li>을 위해 CPU 가 사용자 모드를 커널 모드로 바꿔주고</li>
<li>IDT 라는 테이블에 들어가서 timer 인터럽트에 해당하는 번호에 매칭된 커널함수의 주소 값을 찾아서 실행함<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.png" alt="인터럽트"></li>
</ul>
<ol start="5">
<li>러닝상태로 컨텍스트 스위칭<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9E%90%EC%84%B8%ED%9E%88.png" alt="인터럽트자세히"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%9F%AC%EB%8B%9D%EC%83%81%ED%83%9C%EB%A1%9C%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%8A%A4%EC%9C%84%EC%B9%AD.png" alt="러닝상태로컨텍스트스위칭"></li>
</ol>
<p>실행<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8B%A4%ED%96%89.png" alt="실행"><br>프로그램 실행</p>
<ol>
<li>stack에 메인함수 올라 감<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/stack%EC%97%90%EB%A9%94%EC%9D%B8%ED%95%A8%EC%88%98%EC%98%AC%EB%9D%BC%EA%B0%90.png" alt="stack에메인함수올라감"></li>
<li>open 함수, 헤더파일로 들어감<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/open%ED%95%A8%EC%88%98.png" alt="open함수"></li>
<li>open() $\rightarrow$ 시스템콜<br>CPU 명령어 op code (인터럽트 번호를 사용해서 일으킴)<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/open%ED%95%A8%EC%88%98%EB%82%B4%EB%B6%80.png" alt="open함수내부"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9E%90%EC%84%B8%ED%9E%882.png" alt="인터럽트자세히2"></li>
<li>sysopen()<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/sysopen.png" alt="sysopen"></li>
<li>저장매체에서 open하는 동안 wait mode<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/cpuDMS.png" alt="cpuDMS"></li>
</ol>
<p>저장메체를 처리하는 것은 레지스터를 처리하는 것과 다르게 굉장히 시간을 많이 소요함<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%95%84%EC%A7%81%EB%AA%BB%EB%84%98%EC%96%B4%EA%B0%80%EB%82%98.png" alt="아직못넘어가나"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%B2%9C%EB%B0%B0%EB%A7%8C%EB%B0%B0%EC%B0%A8%EC%9D%B4.png" alt="천배만배차이"><br>따라서 waiting 으로 넘어감<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/waitmode.png" alt="waitmode"><br>6. 다 읽으면 DMS 가 CPU에 다읽었다고 알림<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/DMS%EA%B0%80CPU%EC%97%90%EA%B2%8C.png" alt="DMS가CPU에게"><br>7. 다시 인터럽트가 됨<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/ready%EB%A1%9C%EB%B0%94%EB%80%9C.png" alt="ready로바뀜"></p>
<ol start="8">
<li>타이머 인터럽트<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%8B%A4%EC%8B%9Crunning.png" alt="다시running"></li>
</ol>
<p>마지막<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/IO%EA%B4%80%EB%A0%A8%EC%B2%98%EB%A6%AC.png" alt="IO관련처리"><br>따라서 빈번한 IO는 시간을 $\uparrow$<br>그래서 한방에 메모리를 읽고 프로그램을 처리하려고 노력함</p>
<p>옛날엔 빅데이터는 읽어오고 하는데 1<del>2일 걸림. 스파크는 메모리에 싹올려놔서 1</del>2시간</p>
<p>결론!  </p>
<blockquote>
<p>IO 줄이자! </p>
</blockquote>
<h1 id="Thread-스레드"><a href="#Thread-스레드" class="headerlink" title="Thread (스레드)"></a>Thread (스레드)</h1><ul>
<li>  Light Weight Process 라고도 함</li>
<li>프로세스<ul>
<li>  프로세스 간에는 각 프로세스의 데이터 접근이 불가</li>
</ul>
</li>
<li>스레드<ul>
<li>  하나의 프로세스에 여러개의 스레드 생성 가능</li>
<li>  스레드들은 동시에 실행 가능</li>
<li>  프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/IPC%EC%99%80Thread.png" alt="IPC와Thread"></p>
<hr>
<h2 id="Thread는-각기-실행이-가능한-stack-존재"><a href="#Thread는-각기-실행이-가능한-stack-존재" class="headerlink" title="Thread는 각기 실행이 가능한 stack 존재"></a>Thread는 각기 실행이 가능한 stack 존재</h2><p>스레드는 각각의 스택포인트를 가진 함수 (스택과 힙 중간에 특별한 공간을 만들어서 사용)<br>각 스레드를 위한 SP와 PC가 존재<br>힙과 DATA(BSS/DATA), CODE를 모두 공유<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Thread.png" alt="Thread"></p>
<p><strong>Process VS Thread</strong></p>
<p><img src="https://www.fun-coding.org/00_Images/process&thread.png"></p>
<blockquote>
<p>OS.xlsx -&gt; Thread</p>
</blockquote>
<hr>
<h2 id="Multi-Thread-멀티-스레드"><a href="#Multi-Thread-멀티-스레드" class="headerlink" title="Multi Thread (멀티 스레드)"></a>Multi Thread (멀티 스레드)</h2><ul>
<li>소프트웨어 병행 작업 처리를 위해 Multi Thread를 사용함  <img src="https://www.fun-coding.org/00_Images/multithread.png"></li>
</ul>
<hr>
<h2 id="멀티-프로세스와-멀티-태스킹"><a href="#멀티-프로세스와-멀티-태스킹" class="headerlink" title="멀티 프로세스와 멀티 태스킹"></a>멀티 프로세스와 멀티 태스킹</h2><ul>
<li>멀티 태스킹과 멀티 프로세싱<ul>
<li>멀티 태스킹 : 하나의 CPU에 여러개의 프로세스 (착각)</li>
<li>멀티 프로세싱 : 하나/여러개의 프로세스를 여러개의 CPU로 병렬사용해서 속도를 높임<ul>
<li>이 기술은 Thread를 여러개 만들면 가능함</li>
<li>실행속도를 높이는데 굉장한 기능을 함<br><img src="https://www.fun-coding.org/00_Images/multiprocessing.png"></li>
</ul>
</li>
</ul>
</li>
<li>출처: <a target="_blank" rel="noopener" href="http://donghoson.tistory.com/15">http://donghoson.tistory.com/15</a></li>
<li>최근 CPU는 멀티 코어를 가지므로, Thread를 여러 개 만들어, 멀티 코어를 활용도를 높임</li>
</ul>
<hr>
<ul>
<li>one process one thread : 배치프로세싱에 맞을듯</li>
<li>multiple processes one or multiple threads per process : 멀티 프로세싱<br><img src="https://www.fun-coding.org/00_Images/multithread2.png"></li>
</ul>
<hr>
<h2 id="Thread-장단점"><a href="#Thread-장단점" class="headerlink" title="Thread 장단점"></a>Thread 장단점</h2><h3 id="Thread-장점"><a href="#Thread-장점" class="headerlink" title="Thread 장점"></a>Thread 장점</h3><ol>
<li><p>사용자에 대한 응답성 향상</p>
<p> <img src="https://www.fun-coding.org/00_Images/threadad1.png"><br> <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Thread%EC%9E%A5%EC%A0%90%EB%B9%A0%EB%A5%B8%EC%9D%91%EB%8B%B5.png" alt="Thread장점빠른응답"></p>
</li>
<li><p>자원 공유 효율</p>
<ul>
<li>  IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없음</li>
<li>  프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능</li>
</ul>
</li>
</ol>
<p><img src="https://www.fun-coding.org/00_Images/processmemory.png"></p>
<ol start="3">
<li>작업이 분리되어 코드가 간결<ul>
<li>  사실 작성하기 나름</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Thread-단점"><a href="#Thread-단점" class="headerlink" title="Thread 단점"></a>Thread 단점</h3><ol>
<li>스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음</li>
</ol>
<ul>
<li>멀티 프로세스  <img src="https://www.fun-coding.org/00_Images/multiprocessdown.png"></li>
<li>멀티 스레드  <img src="https://www.fun-coding.org/00_Images/multithreaddown.png"></li>
</ul>
<ol start="2">
<li>스레드를 많이 생성하면, Context Switching이 많이 일어나, 성능 저하</li>
</ol>
<ul>
<li>예: 리눅스 OS에서는 Thread를 Process와 같이 다룸<ul>
<li>  스레드를 많이 생성하면, 모든 스레드를 스케쥴링해야 하므로, Context Switching이 빈번할 수 밖에 없음</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Thread-vs-Process"><a href="#Thread-vs-Process" class="headerlink" title="Thread vs Process"></a>Thread vs Process</h2><ul>
<li>  프로세스는 독립적, 스레드는 프로세스의 서브셋</li>
<li>  프로세스는 각각 독립적인 자원을 가짐, 스레드는 프로세스 자원 공유</li>
<li>  프로세스는 자신만의 주소영역을 가짐, 스레드는 주소영역 공유</li>
<li>  프로세스간에는 IPC 기법으로 통신해야 함, 스레드는 필요 없음</li>
</ul>
<hr>
<h2 id="PThread"><a href="#PThread" class="headerlink" title="PThread"></a>PThread</h2><ul>
<li>POSIX 스레드(POSIX Threads, 약어: PThread)<ul>
<li>  Thread 관련 표준 API</li>
</ul>
</li>
</ul>
<hr>
<h2 id="정리-9"><a href="#정리-9" class="headerlink" title="정리"></a>정리</h2><ul>
<li>Thread 개념 정리<ul>
<li>  프로세스와 달리 스레드간 자원 공유</li>
</ul>
</li>
<li>스레드 장점<ul>
<li>  CPU 활용도를 높이고,</li>
<li>  성능 개선 가능</li>
<li>  응답성 향상</li>
<li>  자원 공유 효율 (IPC를 안써도 됨)</li>
</ul>
</li>
<li>스레드 단점<ul>
<li>  하나의 스레드 문제가, 프로세스 전반에 영향을 미침</li>
<li>  여러 스레드 생성시 성능 저하 가능</li>
</ul>
</li>
</ul>
<hr>
<h2 id="동기화-Synchronization"><a href="#동기화-Synchronization" class="headerlink" title="동기화(Synchronization)"></a>동기화(Synchronization)</h2><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%8F%99%EA%B8%B0%ED%99%94%EC%9D%B4%EC%8A%88%EB%9E%80.png" alt="동기화이슈란"></p>
<h3 id="여기서-잠깐-1"><a href="#여기서-잠깐-1" class="headerlink" title="여기서 잠깐!"></a>여기서 잠깐!</h3><blockquote>
<p>스레드의 개념/원리를 이해하면 관리가 용이! 사용하다 문제가 생겼을 때, 어떤 부분이 잘못될 수 있는지, 왜 특별한 함수들을 사용하는지를 이해 가능!</p>
</blockquote>
<hr>
<h3 id="동기화-Synchronization-이슈"><a href="#동기화-Synchronization-이슈" class="headerlink" title="동기화(Synchronization) 이슈"></a>동기화(Synchronization) 이슈</h3><ul>
<li>  동기화: 작업들 사이에 실행 시기를 맞추는 것</li>
<li>여러 스레드가 동일한 자원(데이터) 접근시 동기화 이슈 발생<ul>
<li>  동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 줌</li>
</ul>
</li>
</ul>
<hr>
<h4 id="동기화-Synchronization-이슈-예제"><a href="#동기화-Synchronization-이슈-예제" class="headerlink" title="동기화(Synchronization) 이슈 예제"></a>동기화(Synchronization) 이슈 예제</h4><ul>
<li>  컴퓨터 구조, 파이썬과 함께 복습</li>
</ul>
<blockquote>
<p>python_mutual_exclusion OS.xlsx -&gt; Thread Synchronization</p>
</blockquote>
<pre><code class="python">import threading

g_count = 0 # 전역변수

def thread_main():
    global g_count # 함수에서 변수를 쓸 때, 지역변수로 인식할 수 있기 때문에, 전역변수라고 표시해줘야 함 
    for i in range(10000):
        g_count = g_count + 1

threads = []

# thread 가 50개 생기고, 각각에 접근할 수 있는 주소가 threads에 append 됨
for i in range(50):
    th = threading.Thread(target = thread_main)
    threads.append(th)

for th in threads:
    th.start()

# 다른 threads가 끝날 때 까지 기다림 (동기화 = 이 땐, 기간을 맞춘다는 의미)
for th in threads:
    th.join()

print(&#39;g_count = &#39;, g_count)

    g_count = 12470682 #500000

</code></pre>
<p>Thread Testing 예제 코드 부연 설명 그림 (python_mutual_exclusion.ipynb)<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/ThreadPython%EC%98%88%EC%A0%9C%EB%B6%84%EC%84%9D.png" alt="ThreadPython예제분석"></p>
<ul>
<li>컨택스트 스위칭이 되면서 덧셈이 누락됐음 $\rightarrow$ 동기화 이슈</li>
<li></li>
</ul>
<hr>
<h3 id="동기화-이슈-해결-방안"><a href="#동기화-이슈-해결-방안" class="headerlink" title="동기화 이슈 해결 방안"></a>동기화 이슈 해결 방안</h3><ul>
<li>Mutual exclusion (상호 배제)</li>
<li>쓰레드는 프로세스 모든 데이터를 접근할 수 있으므로,<ul>
<li>  여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요</li>
<li>  어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레그가 동시 접근하지 못하도록 막아라</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Mutual-exclusion-상호-배제"><a href="#Mutual-exclusion-상호-배제" class="headerlink" title="Mutual exclusion (상호 배제)"></a>Mutual exclusion (상호 배제)</h4><ul>
<li>  임계 자원(critical resource) : 동시에 수정 불가한 애들</li>
<li>임계 영역(critical section) : 실행하면 안되는 구간<pre><code class="python">lock.acquire()           
  for i in range(100000):
      g_count += 1
  lock.release()
</code></pre>
</li>
</ul>
<hr>
<h4 id="동기화-이슈-해결-예제"><a href="#동기화-이슈-해결-예제" class="headerlink" title="동기화 이슈 해결 예제"></a>동기화 이슈 해결 예제</h4><p>실행시기를 맞춰야 함</p>
<blockquote>
<p>python_mutual_exclusion.ipynb</p>
</blockquote>
<pre><code class="python">import threading

g_count = 0

def thread_main():
    global g_count
    # 스레드가 임계영역에 들어가기 전에 키를 가져서 열쇠를 따고 들어가고
    # 중간에 컨택스트 스위칭이 되더라도, 다른 스레드가 들어와도 계속 원래 실행중이던 애가 열쇠를 갖고 있는 상태 (기다리게 됨)
    lock.acquire()
    for i in range(10000):
        g_count = g_count + 1
    lock.realease()

lock = threading.Lock()
threads = []

# thread 가 50개 생기고, 각각에 접근할 수 있는 주소가 threads에 append 됨
for i in range(50):
    th = threading.Thread(target = thread_main)
    threads.append(th)

for th in threads:
    th.start()

# 다른 threads가 끝날 때 까지 기다림 (동기화 = 이 땐, 기간을 맞춘다는 의미)
for th in threads:
    th.join()

print(&#39;g_count = &#39;, g_count)

    g_count = 50000000

</code></pre>
<h2 id="세마포어-Semaphore"><a href="#세마포어-Semaphore" class="headerlink" title="세마포어(Semaphore)"></a>세마포어(Semaphore)</h2><p>동기화(Synchronization)와 세마포어</p>
<h3 id="Mutex와-세마포어"><a href="#Mutex와-세마포어" class="headerlink" title="Mutex와 세마포어"></a>Mutex와 세마포어</h3><ul>
<li>Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요<ul>
<li>  Mutex(binary semaphore) : 임계구역에 하나의 스레드만 들어갈 수 있음</li>
<li>Semaphore : 임계구역에 여러 스레드가 들어갈 수 있음 : counter를 두어서 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어<ul>
<li>  임계구역에 한개만 들어가면 성능상의 이슈가 있을 수 있어서</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="세마포어-Semaphore-1"><a href="#세마포어-Semaphore-1" class="headerlink" title="세마포어 (Semaphore)"></a>세마포어 (Semaphore)</h3><ul>
<li>P: 검사 (임계영역에 들어갈 때) <ul>
<li>  lock.acquire()</li>
<li>  S값이 1 이상이면, 임계 영역 진입 후, S값 1 차감 (S값이 0이면 대기)</li>
</ul>
</li>
<li>V: 증가 (임계영역에서 나올 때)<ul>
<li>  lock.release</li>
<li>  S값을 1 더하고, 임계 영역을 나옴</li>
</ul>
</li>
<li>  S: 세마포어 값 (초기 값만큼 여러 프로세스가 동시 임계 영역 접근 가능)</li>
</ul>
<pre><code class="c">P(S): wait(S) &#123;
        while S &lt;= 0;  // 대기
        S--;    // 다른 프로세스 접근 제한
      &#125;
</code></pre>
<pre><code class="c">V(S): signal(S) &#123;
        S++;    // 다른 프로세스 접근 허용
      &#125;
</code></pre>
<hr>
<h3 id="세마포어-Semaphore-바쁜-대기"><a href="#세마포어-Semaphore-바쁜-대기" class="headerlink" title="세마포어 (Semaphore) - 바쁜 대기"></a>세마포어 (Semaphore) - 바쁜 대기</h3><ul>
<li>wait() 은 S가 0이라면, 임계영역에 들어가기 위해, 반복문 수행<ul>
<li>바쁜 대기, busy waiting<pre><code class="c">P(S): wait(S) &#123;
    while S &lt;= 0; // 바쁜 대기
    S--;    // 다른 프로세스 접근 제한
  &#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="여기서-잠깐-2"><a href="#여기서-잠깐-2" class="headerlink" title="여기서 잠깐"></a>여기서 잠깐</h4><ul>
<li>프로그래밍은 근본적으로는 중단이 없음. 끊임없이 코드 실행<ul>
<li>  중단은 대부분 loop로 표현</li>
<li>  loop는 CPU에 부하를 걸리게 함</li>
</ul>
</li>
</ul>
<hr>
<h3 id="세마포어-Semaphore-대기큐"><a href="#세마포어-Semaphore-대기큐" class="headerlink" title="세마포어 (Semaphore) - 대기큐"></a>세마포어 (Semaphore) - 대기큐</h3><p>busy waiting (쓸모없는 CPU 사용)을 없애보자!</p>
<blockquote>
<p>운영체제 기술로 보완 - 대기큐</p>
</blockquote>
<ul>
<li>S가 음수일 경우, 바쁜 대기 대신, 대기큐에 넣는다.<pre><code class="c">wait(S) &#123;
  S-&gt;count--;
  if (S-&gt;count &lt; 0) &#123;
      add this process to S-&gt;queue;
      block() //sleep()
  &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>wakeup() 함수를 통해 대기큐에 있는 프로세스 재실행<pre><code class="c">signal(S) &#123;
  S-&gt;count++;
  if (S-&gt;count &lt;= 0) &#123;
      remove a process P from S-&gt;queue;
      wakeup(P)
  &#125;
&#125;
</code></pre>
</li>
</ul>
<hr>
<h4 id="참고-주요-세마포어-함수-POSIX-세마포어"><a href="#참고-주요-세마포어-함수-POSIX-세마포어" class="headerlink" title="참고: 주요 세마포어 함수 (POSIX 세마포어)"></a>참고: 주요 세마포어 함수 (POSIX 세마포어)</h4><ul>
<li>sem_open(): 세마포어를 생성</li>
<li>sem_wait(): 임계영역 접근 전, 세마포어를 잠그고, 세마포어가 잠겨있다면, 풀릴 때까지 대기</li>
<li>sem_post(): 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.</li>
</ul>
<h2 id="교착상태-Deadlock-와-기아상태-Starvation"><a href="#교착상태-Deadlock-와-기아상태-Starvation" class="headerlink" title="교착상태(Deadlock)와 기아상태(Starvation)"></a>교착상태(Deadlock)와 기아상태(Starvation)</h2><p>목표 : 용어의 이해</p>
<h3 id="교착상태-deadlock-란"><a href="#교착상태-deadlock-란" class="headerlink" title="교착상태(deadlock)란?"></a>교착상태(deadlock)란?</h3><ul>
<li>  무한 대기 상태: 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태</li>
</ul>
<!-- ![](https://www.fun-coding.org/00_Images/deadlock2.png) -->
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C.png" alt="교착상태"></p>
<blockquote>
<p>배치 처리 시스템에서는 일어나지 않는 문제 프로세스, 스레드 둘다 이와 같은 상태가 일어날 수 있음</p>
</blockquote>
<h4 id="참고-교착상태-발생-조건"><a href="#참고-교착상태-발생-조건" class="headerlink" title="참고: 교착상태 발생 조건"></a>참고: 교착상태 발생 조건</h4><ul>
<li>  다음 <em>네 가지 조건이 모두 성립</em>될 때, 교착상태 발생 가능성이 있음</li>
</ul>
<ol>
<li> 상호배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.</li>
<li> 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.</li>
<li> 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.</li>
<li> 순환대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.</li>
</ol>
<hr>
<h4 id="참고-교착상태-해결-방법"><a href="#참고-교착상태-해결-방법" class="headerlink" title="참고: 교착상태 해결 방법"></a>참고: 교착상태 해결 방법</h4><ol>
<li> 교착상태 예방</li>
<li> 교착상태 회피</li>
<li> 교착상태 발견</li>
<li> 교착상태 회복</li>
</ol>
<h4 id="참고-교착상태-예방-deadlock-prevention"><a href="#참고-교착상태-예방-deadlock-prevention" class="headerlink" title="참고: 교착상태 예방(deadlock prevention)"></a>참고: 교착상태 예방(deadlock prevention)</h4><blockquote>
<p>  4가지 조건 중 <strong>하나를 제거</strong>하는 방법</p>
</blockquote>
<ol>
<li> 상호배제 조건의 제거: 임계 영역 제거</li>
<li> 점유와 대기 조건의 제거: 한번에 모든 필요 자원 점유 및 해제</li>
<li> 비선점 조건 제거: 선점 가능 기법을 만들어줌</li>
<li> 순환 대기 조건 제거: 자원 유형에 따라 순서를 매김</li>
</ol>
<hr>
<h4 id="참고-교착상태-회피-deadlock-avoidance"><a href="#참고-교착상태-회피-deadlock-avoidance" class="headerlink" title="참고: 교착상태 회피(deadlock avoidance)"></a>참고: 교착상태 회피(deadlock avoidance)</h4><ul>
<li>교착상태 조건 1, 2, 3은 놔두고, 4번만 제거<ul>
<li>  1, 2, 3 제거시, 프로세스 실행 비효율성이 증대</li>
</ul>
</li>
<li>  교착상태 조건 중, 자원 할당 순서를 정의하지 않음(순환 대기 조건 제거)</li>
</ul>
<ol>
<li> 상호배제 조건의 제거: 임계 영역 제거</li>
<li> 점유와 대기 조건의 제거: 한번에 모든 필요 자원 점유 및 해제</li>
<li> 비선점 조건 제거: 선점 가능 기법을 만들어줌</li>
<li> 순환 대기 조건 제거: 자원 유형에 따라 순서를 매김</li>
</ol>
<hr>
<h3 id="참고-교착상태-발견-deadlock-detection-과-회복"><a href="#참고-교착상태-발견-deadlock-detection-과-회복" class="headerlink" title="참고: 교착상태 발견(deadlock detection)과 회복"></a>참고: 교착상태 발견(deadlock detection)과 회복</h3><ul>
<li>교착상태 발견(deadlock detection)<ul>
<li>  교착상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것</li>
</ul>
</li>
<li>교착상태 회복(deadlock recovery)<ul>
<li>  교착 상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것</li>
</ul>
</li>
</ul>
<hr>
<h3 id="기아상태-starvation"><a href="#기아상태-starvation" class="headerlink" title="기아상태(starvation)"></a>기아상태(starvation)</h3><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C%EC%9E%90%EC%9B%90%EB%B6%80%EC%A1%B1.png" alt="기아상태자원부족"></p>
<ul>
<li>특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태</li>
<li>교착상태와 기아상태<ul>
<li>  교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생</li>
<li>  기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함</li>
</ul>
</li>
</ul>
<hr>
<h4 id="기아상태-해결-방안"><a href="#기아상태-해결-방안" class="headerlink" title="기아상태 해결 방안"></a>기아상태 해결 방안</h4><ul>
<li>우선순위 변경<ul>
<li>  프로세스 우선순위를 수시로 변경해서, 각 프로세스가 높은 우선순위를 가질 기회주기</li>
<li>  오래 기다린 프로세스의 우선순위를 높여주기</li>
<li>  우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용</li>
</ul>
</li>
</ul>
<h1 id="여기서-잠깐-3"><a href="#여기서-잠깐-3" class="headerlink" title="여기서 잠깐!"></a>여기서 잠깐!</h1><blockquote>
<p>가상 메모리도 굉장히 큰 부분 프로세스 관련 기술을 이해하면, 가상 메모리도 보다 쉽게 이해 가능 프로세스 이해가 조금 부족하더라도, 가상 메모리에 프로세스 관련 설명이 반복되므로, 조금씩 더 이해 가능</p>
</blockquote>
<hr>
<h1 id="가상-메모리-Virtual-Memory-System"><a href="#가상-메모리-Virtual-Memory-System" class="headerlink" title="가상 메모리 (Virtual Memory System)"></a>가상 메모리 (Virtual Memory System)</h1><blockquote>
<p>실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음</p>
</blockquote>
<ul>
<li>  예: 리눅스는 하나의 프로세스가 4GB 임</li>
<li>  통상 메모리는 8GB? 16GB?</li>
</ul>
<blockquote>
<p>폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 함<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%9C%EC%9A%94.png" alt="가상메모리개요"></p>
</blockquote>
<hr>
<h2 id="가상-메모리가-필요한-이유"><a href="#가상-메모리가-필요한-이유" class="headerlink" title="가상 메모리가 필요한 이유"></a>가상 메모리가 필요한 이유</h2><ul>
<li><p>하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템등)</p>
<ol>
<li> 프로그램을 메모리로 로드(load)</li>
<li> 프로세스 실행</li>
<li> 프로세스 종료 (메모리 해제)</li>
</ol>
</li>
<li><p>여러 프로세스 동시 실행 시스템</p>
<ol>
<li> 메모리 용량 부족 이슈</li>
<li> 프로세스 메모리 영역간에 침범 이슈</li>
</ol>
</li>
</ul>
<hr>
<h2 id="가상-메모리-Virtual-Memory-System-1"><a href="#가상-메모리-Virtual-Memory-System-1" class="headerlink" title="가상 메모리 (Virtual Memory System)"></a>가상 메모리 (Virtual Memory System)</h2><ul>
<li>가상 메모리: 메모리가 실제 메모리보다 많아 보이게 하는 기술<ul>
<li>  실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술</li>
<li>프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음  <img src="https://www.fun-coding.org/00_Images/processmemory.png"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>가상 메모리 기본 아이디어<ul>
<li>  프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다.</li>
<li>  virtual address (가상 주소): 프로세스가 참조하는 주소</li>
<li>physical address (물리 주소): 실제 메모리 주소<ul>
<li>  물리 주소로는 필요한 부분(일부분)만 올림</li>
</ul>
</li>
</ul>
</li>
<li>MMU(Memory Management Unit)<ul>
<li>  CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>메인 메모리에 실제 각 프로세스의 데이터가 조각으로 씌여 있다.<blockquote>
<p>OS.xlsx –&gt; VirtualMemorySystem2</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="가상-메모리-Virtual-Memory-System-와-MMU"><a href="#가상-메모리-Virtual-Memory-System-와-MMU" class="headerlink" title="가상 메모리 (Virtual Memory System) 와 MMU"></a>가상 메모리 (Virtual Memory System) 와 MMU</h2><ul>
<li>CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근<ul>
<li>  하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/MMU.png"></p>
<hr>
<h2 id="가상-메모리-메커니즘"><a href="#가상-메모리-메커니즘" class="headerlink" title="가상 메모리 메커니즘"></a>가상 메모리 메커니즘</h2><h3 id="페이징-시스템-paging-system"><a href="#페이징-시스템-paging-system" class="headerlink" title="페이징 시스템(paging system)"></a>페이징 시스템(paging system)</h3><p>가장 많이 쓰임</p>
<ul>
<li>페이징(paging) 개념<ul>
<li>  크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리</li>
<li>하드웨어 지원이 필요<ul>
<li>  예) Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원</li>
</ul>
</li>
<li>  리눅스에서는 4KB로 paging</li>
<li>페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%95%EC%8B%9C%EC%8A%A4%ED%85%9C.png" alt="페이징시스템"></li>
</ul>
</li>
</ul>
<hr>
<h4 id="페이징-시스템-paging-system-의-예"><a href="#페이징-시스템-paging-system-의-예" class="headerlink" title="페이징 시스템(paging system)의 예"></a>페이징 시스템(paging system)의 예</h4><blockquote>
<p>실질적인 예를 기반으로 페이징 시스템에 대해 알아보겠습니다.</p>
</blockquote>
<ul>
<li><p>  프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음</p>
</li>
<li><p>Page Table에는 가상 주소와 물리 주소간 매핑 정보가 있음</p>
<p>  <img src="https://www.fun-coding.org/00_Images/pagingsystem.png"></p>
<ul>
<li>CPU에서 주소를 확인한뒤 처리<h4 id="페이징-시스템-구조"><a href="#페이징-시스템-구조" class="headerlink" title="페이징 시스템 구조"></a>페이징 시스템 구조</h4></li>
</ul>
</li>
<li><p>  page 또는 page frame: 고정된 크기의 block (4KB)</p>
</li>
<li><p>paging system</p>
<ul>
<li>가상 주소 v = (p, d)<ul>
<li>  p: 가상 메모리 페이지</li>
<li>d: p안에서 참조하는 위치 (변위라고도 함)  <img src="https://www.fun-coding.org/00_Images/pagingnumber.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>페이지 크기가 4KB 예</p>
<ul>
<li>  가상 주소의 0비트에서 11비트가 변위 (d)를 나타내고,</li>
<li>  12비트 이상이 페이지 번호가 될 수 있음</li>
</ul>
</li>
</ul>
<hr>
<h4 id="쉬었다-가기-모든-것은-결국-bit와-연결"><a href="#쉬었다-가기-모든-것은-결국-bit와-연결" class="headerlink" title="쉬었다 가기 - 모든 것은 결국 bit와 연결"></a>쉬었다 가기 - 모든 것은 결국 bit와 연결</h4><ul>
<li>프로세스가 4GB를 사용하는 이유 - 32bit 시스템에서 2의 32승이 4GB  <img src="https://www.fun-coding.org/00_Images/processmemory.png"></li>
</ul>
<hr>
<h3 id="페이지-테이블-page-table"><a href="#페이지-테이블-page-table" class="headerlink" title="페이지 테이블(page table)"></a>페이지 테이블(page table)</h3><p><strong>메모리에 올림</strong></p>
<ul>
<li>page table<ul>
<li>  물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표</li>
<li>가상주소 v = (p, d) 라면<ul>
<li>  p: 페이지 번호</li>
<li>  d: 페이지 처음부터 얼마 떨어진 위치인지</li>
</ul>
</li>
</ul>
</li>
<li>paging system 동작<ul>
<li>해당 프로세스에서 특정 가상 주소 엑세스를 하려면<ul>
<li>  해당 프로세스의 page table 에 해당 가상 주소가 포함된 page 번호가 있는지 확인</li>
<li>  page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고(p’)</li>
<li>p’ + d 가 실제 물리 주소가 됨<br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%ED%85%8C%EC%9D%B4%EB%B8%94.png" alt="페이지테이블"><br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%ED%85%8C%EC%9D%B4%EB%B8%942.png" alt="페이지테이블2"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="페이징-시스템과-MMU-컴퓨터-구조"><a href="#페이징-시스템과-MMU-컴퓨터-구조" class="headerlink" title="페이징 시스템과 MMU(컴퓨터 구조)"></a>페이징 시스템과 MMU(컴퓨터 구조)</h3><ul>
<li>CPU는 가상 주소 접근시<ul>
<li>MMU 하드웨어 장치를 통해 물리 메모리 접근  <img src="https://www.fun-coding.org/00_Images/MMU.png"></li>
</ul>
</li>
<li>프로세스 생성시, 페이지 테이블 정보 생성<ul>
<li>  PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재</li>
<li>  프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)</li>
<li>  CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서,물리 주소를 가져옴</li>
</ul>
</li>
</ul>
<hr>
<h4 id="다중-단계-페이징-시스템"><a href="#다중-단계-페이징-시스템" class="headerlink" title="다중 단계 페이징 시스템"></a>다중 단계 페이징 시스템</h4><p>페이지 테이블은 <strong>메모리에 올림</strong><br>$\rightarrow$ 쓸데 없는 메모리를 낭비할 수 있다.<br>따라서, 전체를 만들지 않고 필요한 부분만 올리면,<br>즉, 페이징 정보를 단계를 나누어 생성하면 공간 절약이 가능하다.<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%8B%A4%EC%A4%91%EB%8B%A8%EA%B3%84%ED%8E%98%EC%9D%B4%EC%A7%95%EC%8B%9C%EC%8A%A4%ED%85%9C.png" alt="다중단계페이징 시스템"></p>
<ul>
<li>32bit 시스템에서 4KB 페이지를 위한 페이징 시스템은<ul>
<li>  하위 12bit는 오프셋</li>
<li>  상위 20bit가 페이징 번호이므로, 2의 20승(1048576)개의 페이지 정보가 필요함</li>
</ul>
</li>
<li>페이징 정보를 단계를 나누어 생성<ul>
<li>  필요없는 페이지는 생성하지 않으면, 공간 절약 가능</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>페이지 번호를 나타내는 bit를 구분해서, 단계를 나눔 (리눅스는 3단계, 최근 4단계)<ul>
<li>공간적으로 효율적인 것을 볼 수 있음<br><img src="https://www.fun-coding.org/00_Images/paginglevel.png"></li>
<li>CR3 레지스터가 (전체)페이지테이블 맨 앞을 가르킴<ul>
<li>페이지테이블의 맨 앞의 주소 = 해당 디렉토리에 대한 페이지 주소를 가르키게됨</li>
<li>해당 페이지 번호를 찾아서 그 페이지 번호와 오프셋 정보를 가지고 그 주소의 정보(데이터)를 가져옴</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="MMU와-TLB-컴퓨터-구조"><a href="#MMU와-TLB-컴퓨터-구조" class="headerlink" title="MMU와 TLB(컴퓨터 구조)"></a>MMU와 TLB(컴퓨터 구조)</h3><ul>
<li><p>MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함</p>
<ol>
<li><p>CPU가 가상메모리를 요청</p>
</li>
<li><p>MMU가 CR3 레지스터의 값을 가지고 페이지 테이블에 들어감 </p>
</li>
<li><p>페이지 테이블이던 다중 단계 페이징 시스템이든, 똑같이 맨 위로가서, MMU가 그 주소를 가져옴</p>
</li>
<li><p>그 물리적 주소에 MMU가 접근해서 해당 페이지의 주소를 가져와서</p>
</li>
<li><p>해당 데이터가 CPU에 전달됨<br><img src="https://www.fun-coding.org/00_Images/pagingwMMU.png"></p>
<p>페이지 테이블에 한번 가기 위해 CR3 레지스터 갔다오고, 물리주소를 갖고와서 물리주소에 대한 데이터를 갖고오기 위해서 해당 메모리로 가야함 (시간이 걸림)</p>
<blockquote>
<p>따라서 별도의 캐시 보조 하드웨어 TLB를 두게됨</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="메모리-계층-컴퓨터-구조-복습"><a href="#메모리-계층-컴퓨터-구조-복습" class="headerlink" title="메모리 계층 - 컴퓨터 구조 복습"></a>메모리 계층 - 컴퓨터 구조 복습</h4><p>레지스터를 처리할 때 보다, 메인메모리에 왔다갔다 하는게 시간이 많이 걸림</p>
<p><img src="https://www.fun-coding.org/00_Images/memoryhierarchy.png"></p>
<p>출처: <a target="_blank" rel="noopener" href="http://computationstructures.org/lectures/caches/caches.html">http://computationstructures.org/lectures/caches/caches.html</a></p>
<hr>
<h4 id="MMU와-TLB-컴퓨터-구조-1"><a href="#MMU와-TLB-컴퓨터-구조-1" class="headerlink" title="MMU와 TLB(컴퓨터 구조)"></a>MMU와 TLB(컴퓨터 구조)</h4><ul>
<li><p>TLB(Translation Lookaside Buffer): 페이지 정보 캐쉬<br>  한번 변환이 된 물리주소는 (최근의 물리주소는) 하드웨어인 TLB에 저장됨  </p>
<ul>
<li><p>예를 들어 A라는 가상메모리의 물리주소가 A’라면 TLB에 저장됨</p>
<p><img src="https://www.fun-coding.org/00_Images/TLBpaging.png"></p>
</li>
<li><p>일단 TLB에 가서 가상주소의 물리주소가 있는지를 보고, 없으면 MMU로 감</p>
<ul>
<li>메모리 접근을 2에서 1번으로 줄일 수 있음 (TLB는 cache 이므로 훨신 적게 걸림)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="페이징-시스템과-공유-메모리"><a href="#페이징-시스템과-공유-메모리" class="headerlink" title="페이징 시스템과 공유 메모리"></a>페이징 시스템과 공유 메모리</h3><ul>
<li>공유 메모리 (복습) : 커널영역에서 만들어지는 메모리  </li>
<li>커널공간 (복습) : 4GB-3GB 영역의 메모리<br>  커널공간은 프로세스마다 운영체제를 다 가지고 있다 (엄청 아까운 공간)<br>  내부적, 기술적으로 보면 아깝지 않다!  <blockquote>
<p>그 공간의 페이지 테이블은 결과적으로 동일한 메모리 공간을 가르키면 되기 때문  </p>
<p>프로세스에서 커널공간을 일일히 가지고 있는 것 처럼 표시되어도 물리 메모리에서 추가로 필요한 메모리는 없다</p>
</blockquote>
</li>
</ul>
<p>프로세스 A의 노란공간과 프로세스 B의 노란공간이 같은 주소라고하면<br>동일한 주소를 가르키므로 굳이 두번 쓰지 않아도 됨  </p>
<ul>
<li>  프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/copyonwriteread.png"></p>
<ul>
<li>전통적인 리눅스 운영체제에서 프로세스가 생성되는, 생성하는 방법<ul>
<li>어떤 프로세스에서 해당 데이터를 복사(fork)해서 새로운 프로세스를 만듦<ul>
<li>Process A : Parent Process</li>
<li>Process B : Child Process</li>
<li>4GB라 한다면 통째로 복사하진 않음<ul>
<li>그냥 페이지 테이블 중 프로세스 A의 일부가 들어있는 메모리 공간을, 프로세스 B가 가르키게 함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>물리 주소 데이터 변경시 (쓰기를 한다면?)<ul>
<li>물리 주소에 데이터 수정 시도시, 물리 주소를 복사할 수 있음 (copy-on-write)<ul>
<li>  이 때 다른 공간으로 복사를 해서 변경 </li>
<li>프로세스 생성시간 $\downarrow$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/copyonwritewrite.png"></p>
<ul>
<li>정리<ul>
<li>커널, 공유메모리든 공유데이타는 물리메모리 공간 공유<ul>
<li>  공간 절약, 프로세스의 생성시간까지 줄일 수 있다</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="요구-페이징-Demand-Paging-또는-Demanded-Paging"><a href="#요구-페이징-Demand-Paging-또는-Demanded-Paging" class="headerlink" title="요구 페이징 (Demand Paging 또는 Demanded Paging)"></a>요구 페이징 (Demand Paging 또는 Demanded Paging)</h3><p>여러 프로그램 실행시, 어느 블럭을 어느 시점에 물리 메모리에 해당 페이지를 넣어줘야하는지 정책이 필요<br>기본적으로 7페이지 정도 미리 올려놓음  $\rightarrow$ 선행페이징  </p>
<ul>
<li>프로세스 모든 데이터를 메모리로 적재하지 않고, <strong>실행 중 필요한 시점에서만 메모리로 적재</strong>함<ul>
<li>  선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념: 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념</li>
<li>  더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 (<strong>페이지 교체 알고리즘 필요</strong>)</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9A%94%EA%B5%AC%ED%8E%98%EC%9D%B4%EC%A7%951.png" alt="요구페이징1"><br>해당 페이지를 올려준 모습<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9A%94%EA%B5%AC%ED%8E%98%EC%9D%B4%EC%A7%952.png" alt="요구페이징2"></p>
<hr>
<h3 id="페이지-폴트-page-fault"><a href="#페이지-폴트-page-fault" class="headerlink" title="페이지 폴트 (page fault)"></a>페이지 폴트 (page fault)</h3><p>인터럽트</p>
<ul>
<li><p>  어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트</p>
</li>
<li><p>  운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림</p>
</li>
<li><p>예시</p>
<ul>
<li>page3 이 일어나려는데, page3에대한 valid bit 가 i 임 (없네?!)<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8.png" alt="페이지폴트1"></li>
<li>처리방법 : page fault 인터럽트를 운영체제에 날려줌<ul>
<li>페이지 폴트를 받은 운영체제가 해당 페이지를 물리메모리에 올려준 다음, valid bit로 바꿔줌</li>
<li>다시 재실행<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B82.png" alt="페이지폴트2"></li>
</ul>
</li>
<li>이제 요구페이징을 지원하는 메커니즘을 만들 수 있음~!</li>
</ul>
</li>
<li><p>페이지 폴트와 인터럽트<br>  <img src="https://www.fun-coding.org/00_Images/pagefault.png"></p>
<ol>
<li>CPU 가상 어드레스 요청 </li>
<li>MMU는 TLB로 가서 해당가상메모리에 대한 주소가 있는지를 보고 물리주소가 있으면 바로 메모리에서 해당 데이터를 가져와서 CPU로 처리해줌<ul>
<li>   만약에 모르면 CR3 레지스터를 가지고, 메모리에 접근해서</li>
</ul>
<ol start="3">
<li>valid bit인지 (물리메모리에 저장되어있는지 아닌지를 보고) MMU가 해당 물리주소를 가져와서, 해당 페이지의 데이터를 가져와서 CPU에 보내면 끝</li>
</ol>
<ul>
<li>만약 안들어와 있다, invalid bit 이면 Page fault interrupt 가 운영체제에 던져지고,</li>
</ul>
<ol start="4">
<li>운영체제는 Page fault interrupt를 처리(handling)하기 위해 해당 페이지를 프로세스의 저장공간에서 가져와서(찾아와서) (실행파일 등에서 가져옴),<ul>
<li>IDT로 가서 Page fault 인터럽트 번호에 대한 (운영체제 안에있는) 함수를 호출</li>
</ul>
</li>
<li>해당 데이터를 메모리에 올려주고</li>
<li>페이지 테이블을 업데이트함</li>
<li>CPU에게 다시실행(restart)를 요청<ul>
<li> CPU는 가상 주소를 다시 요청해서 MMU를 타고 해당 메모리에 있는 데이터를 가져 옴</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="생각해보기"><a href="#생각해보기" class="headerlink" title="생각해보기"></a>생각해보기</h4><ul>
<li><p>페이지 폴트가 자주 일어나면?</p>
<ul>
<li>실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함<ul>
<li>  시간이 오래 걸림</li>
</ul>
</li>
</ul>
</li>
<li><p>페이지 폴트가 안 일어나게 하려면?</p>
<ul>
<li>향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨<ul>
<li>앞으로 있을 일을 예측해야 함 - 신의 영역<ul>
<li>  이를 위한 여러 알고리즘이 존재</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>PC 쓸 때, 프로그램을 많이 띄어두면, 하드읽는 소리가 엄청 났었음</p>
<ul>
<li>페이지 폴트 때문임</li>
<li>메모리는 한정적이기 때문에 각각의 프로세스별 데이터가 조각조각 들어가 있기 때문<ul>
<li>다른 프로그램을 바꾸면, 해당 데이터를 마구 카피해서 올려야 함 $\rightarrow$ 페이지 폴트, 페이지 스왑 필요</li>
<li>프로그램을 많이 띄운다 $\rightarrow$ 돈주고 메모리(RAM)을 늘린다 ㅋㅋㅋ</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="페이지-교체-정책-page-replacement-policy"><a href="#페이지-교체-정책-page-replacement-policy" class="headerlink" title="페이지 교체 정책 (page replacement policy)"></a>페이지 교체 정책 (page replacement policy)</h3><p>메모리가 페이지로 다 찼다고 가정을 해보자!<br>이중 어떤 페이지를 필요한 페이지와 교체해 주겠는가?<br>$\rightarrow$ 페이지 교체 정책</p>
<ul>
<li>운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차있다면?<ul>
<li>  기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)</li>
<li>  새로운 페이지를 해당 물리 메모리 공간에 올린다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>어떤 페이지를 물리 메모리에서, 저장 매체로 내릴 것인가? -&gt; Page Replacement(Swapping) Algorithm</p>
</blockquote>
<ul>
<li>FIFO</li>
<li>OPT</li>
<li>LRU</li>
<li>LFU</li>
<li>NUR</li>
<li></li>
</ul>
<hr>
<h4 id="페이지-교체-알고리즘-FIFO"><a href="#페이지-교체-알고리즘-FIFO" class="headerlink" title="페이지 교체 알고리즘 (FIFO)"></a>페이지 교체 알고리즘 (FIFO)</h4><ul>
<li>FIFO Page Replacement Algorithm<ul>
<li>  가장 먼저 들어온 페이지를 내리자</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4FIFO.png" alt="페이지교체FIFO"><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4FIFO%EA%B2%B0%EA%B3%BC.png" alt="페이지교체FIFO결과"></p>
<hr>
<h4 id="페이지-교체-알고리즘-OPT"><a href="#페이지-교체-알고리즘-OPT" class="headerlink" title="페이지 교체 알고리즘 (OPT)"></a>페이지 교체 알고리즘 (OPT)</h4><ul>
<li>최적 페이지 교체 알고리즘 (OPTimal Replacement Algorithm)<ul>
<li>  앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자</li>
<li>일반 OS에서는 구현 불가<ul>
<li>  불가능한 정책</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4OPT.png" alt="페이지교체OPT"></p>
<ul>
<li>Requested Page : 시간대 별로 요청된 페이지</li>
<li>Physical Memory : 물리메모리에 어떤 페이지가 들어가 있는진</li>
<li>결과 : 앞으로 안쓰는 거 3을 4로 교체함</li>
</ul>
<h4 id="페이지-교체-알고리즘-LRU"><a href="#페이지-교체-알고리즘-LRU" class="headerlink" title="페이지 교체 알고리즘 (LRU)"></a>페이지 교체 알고리즘 (LRU)</h4><p>OPT에 그나마 가까운 애  , 가장 많이 쓰임</p>
<ul>
<li>LRU(Least Recently Used) Page Replacement Algorithm<ul>
<li>  <strong>가장 오래 전에 사용된 페이지를 교체</strong></li>
<li>  OPT 교체 알고리즘이 구현이 불가하므로, 과거 기록을 기반으로 시도</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4LRU.png" alt="페이지교체LRU"></p>
<ul>
<li>결과 : 가장 오래 전에 사용한 페이지 3을 4로 교체</li>
</ul>
<hr>
<h5 id="참고-메모리-지역성"><a href="#참고-메모리-지역성" class="headerlink" title="참고: 메모리 지역성"></a>참고: 메모리 지역성</h5><p><img src="https://www.fun-coding.org/00_Images/locality.png"></p>
<ul>
<li>실행시간, 코드 주소<ul>
<li>실행시간에 따라 실행한 코드를 볼 수 있음</li>
<li>for문 같은 경우, 코드의 주변을 실행할 가능성이 큼</li>
</ul>
</li>
<li>결론 : 가장 오래 전에 사용된 페이지는 사용이 안 될 가능성이 높음</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A7%80%EC%97%AD%EC%84%B1for%EB%AC%B8.png" alt="메모리지역성for문"></p>
<hr>
<h5 id="페이지-스왑-알고리즘-LFU"><a href="#페이지-스왑-알고리즘-LFU" class="headerlink" title="페이지 스왑 알고리즘 (LFU)"></a>페이지 스왑 알고리즘 (LFU)</h5><ul>
<li>LFU(Least Frequently Used) Page Replacement Algorithm<ul>
<li>  <strong>가장 적게 사용된 페이지를 내리자</strong></li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4LFU.png" alt="페이지교체LFU"></p>
<ul>
<li>결과 : page3이 2번 사용으로 가장 적게 사용되서 4로 교체</li>
</ul>
<hr>
<h5 id="페이지-스왑-알고리즘-NUR"><a href="#페이지-스왑-알고리즘-NUR" class="headerlink" title="페이지 스왑 알고리즘 (NUR)"></a>페이지 스왑 알고리즘 (NUR)</h5><ul>
<li>NUR(Not Used Recently) Page Replacement Algorithm<ul>
<li>  LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법</li>
<li>각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R, M)<ul>
<li>  읽었는지 수정했는지를 페어로 묶어서 정보를 유지함</li>
<li>(0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체<ul>
<li>  (0, 0) : 읽기도 안됐고, 수정도 안됐고</li>
<li>  (0, 1) : 수정만 됐고</li>
<li>  (1, 0) : 읽기만 됐고</li>
<li>  (1, 1) : 읽기도 됐고, 수정도 됐고<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4NUR.png" alt="페이지교체NUR"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="스레싱-Thrashing"><a href="#스레싱-Thrashing" class="headerlink" title="스레싱(Thrashing)"></a>스레싱(Thrashing)</h3><ul>
<li>반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황  <img src="https://www.fun-coding.org/00_Images/thrashing.png"><ul>
<li>페이지 스왑, 페이지 폴트만 계속 일어남<ul>
<li> 창을 너무 여러게 띄어 놓는걸 추천 안함 (메모리가 빵빵하면 상관 없긔..)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="참고-세그멘테이션-Segmentation"><a href="#참고-세그멘테이션-Segmentation" class="headerlink" title="[참고] 세그멘테이션 (Segmentation)"></a>[참고] 세그멘테이션 (Segmentation)</h3><p>페이징 시스템이 가장 많이 쓰이는 가상메모리 시스템</p>
<p>세그멘테이션 기법 - 페이징 시스템과 비교해서 알아두면 좋음</p>
<ul>
<li>가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할<ul>
<li>  페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할</li>
<li>예: x86 리얼모드<ul>
<li>인텔의 CPU가 발전하다가 중간에 80286이란 시스템에서 보호모드를 지원하기 시작<ul>
<li>  protection ring $\rightarrow$ kernel/user 모드 지원</li>
<li>  기존 CPU (8086/80186)에서 제작된 소프트웨어가 실행되기가 어려워짐</li>
<li>기존 CPU와 호환 모드가 바로 리얼모드<ul>
<li>  컴퓨터 부팅시 CPU 모드 - 아주 단순한 처리일 때, 리얼모드를 쓰다가 보호모드로 바뀜</li>
<li>  리얼모드 : 최대 1GB를 사용 가능 아래처럼 세그먼트를 나눠서 사용</li>
</ul>
</li>
</ul>
</li>
<li>  CS(Code Segment), DS(Data Segment), SS(Stack Segment), ES(Extra Segment) 로 세그먼트를 나누어, 메모리 접근</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="세그멘테이션-기법"><a href="#세그멘테이션-기법" class="headerlink" title="세그멘테이션 기법"></a>세그멘테이션 기법</h4><p>세그먼트의 특정주소를 물리주소와 매칭시키는 것은 페이징 시스템과 비슷</p>
<ul>
<li>세그먼트 가상주소<ul>
<li>v = (s,d): s는 세그먼트 번호, d는 블록 내 세그먼트의 변위<ul>
<li><p>  세그먼트 테이블에서 각각의 세그먼트에 대한 물리주소에 접근할 수 있음</p>
</li>
<li><p>각각 세그먼트에 변위를 더하면 해당 세그먼트에 베이스 주소에 변위를 더한, 특정 데이터 값을 얻어낼 수 있다. (페이징 시스템과 유사함)</p>
<p><img src="https://www.fun-coding.org/00_Images/segmentation.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="세그멘테이션-기법-페이징-기법-비교"><a href="#세그멘테이션-기법-페이징-기법-비교" class="headerlink" title="세그멘테이션 기법, 페이징 기법 비교"></a>세그멘테이션 기법, 페이징 기법 비교</h4><p>세그멘테이션 : 세그먼트 별로 전혀 다른 크기의 영역의 물리 메모리에 매칭됨<br>페이징 : 스택이든, 힙이든, 공유메모리이던 상관없이 일괄적으로 4kbyte 식으로 쪼개져서 물리메모리에 넣어짐</p>
<ul>
<li>세그멘테이션은 크기가 다른 segment 단위로 물리 메모리에 로딩  <img src="https://www.fun-coding.org/00_Images/seg_page.png"></li>
</ul>
<hr>
<ul>
<li>내부 단편화 (페이지 기법)<ul>
<li>페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비<br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94.png" alt="내부단편화"></li>
</ul>
</li>
<li>외부 단편화 (세그멘테이션 기법)<ul>
<li>물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우<br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%99%B8%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94.png" alt="외부단편화">   </li>
</ul>
</li>
<li>세그멘테이션/페이징 모두 <strong>하드웨어 지원 필요</strong><ul>
<li>다양한 컴퓨터 시스템에 이식성을 중요시하는 <em>리눅스는 페이징 기법을 기반으로 구현</em><ul>
<li>  일부 CPU에선 세그멘테이션 기법을 지원을 안하는 경우도 있기 때문</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="총정리-실제-프로세스의-메모리-사용-및-동작-방식"><a href="#총정리-실제-프로세스의-메모리-사용-및-동작-방식" class="headerlink" title="총정리 : 실제 프로세스의 메모리 사용 및 동작 방식"></a>총정리 : 실제 프로세스의 메모리 사용 및 동작 방식</h2><p>가상메모리 이해를 기반으로 실제 프로세스의 메모리 사용과 동작 방식을 알아보자!<br>프로그램을 보는 시야를 넓히자!</p>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC1.png" alt="가상메모리총정리1"></p>
<ol>
<li><p>컴파일 $\rightarrow$ 실행파일(size 1KB)</p>
</li>
<li><p>쉘을 통해 실행이 됨</p>
</li>
<li><p>프로세스가 만들어짐</p>
<ul>
<li>이 때 프로세스가 차지하고 있는 가상 메모리 영역 : 4GB<ul>
<li>실행파일이 1KB 여도, 가상 메모리 영역에 있는건 4GB<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC2.png" alt="가상메모리총정리2"></li>
</ul>
</li>
<li>4GB 위치엔 가상메모리주소</li>
<li>커널영역</li>
<li>사용자영역<ul>
<li>int fd는 초기화 변수를 지정하지 않았기 때문에 DATA 영역의 bss로 들어감</li>
<li>힙과 스택 관련 공간은 공란<ul>
<li>main함수가 실행되면 stack 안에서 실행이 됨</li>
</ul>
</li>
</ul>
</li>
<li>프로그램 실행파일은 1kB 밖에 안됨 $\rightarrow$ 그러나 사용은 4GB<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC3.png" alt="가상메모리총정리3"></li>
</ul>
</li>
<li><p>(보통 4KB의) 고정된 페이지로 나뉘어서 (왼쪽 가상메모리), 실제 페이지들이 물리메모리(오른쪽)에 들어가 있는지 안들어가있는지 확인하고, 들어가있다면 그 때 주소는 어떻게 되는지, 주소를 가지고 있는 페이지 테이블들이 생성 됨</p>
<ul>
<li>실제 코드는 1KB이기 때문에, 모든 것(4GB)에 대해 페이지를 만드는 것은 굉장히 비효율적임<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC4.png" alt="가상메모리총정리4"></li>
</ul>
</li>
<li><p>페이지 디렉토리로 만들어서 필요없는 디렉토리들은 페이지 영역을 만들지 않고, 필요한 영역만 해당 페이지 테이블을 만들어서 디렉토리로 관리를 함</p>
<ul>
<li><p>나머지 필요없는 애들은 페이지 테이블을 만들지 않기 때문에, 페이지 테이블을 만드는 공간과 시간을 줄일 수 있음<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC5.png" alt="가상메모리총정리5"></p>
</li>
<li><p>실행파일을 만들 때 마다 (=프로세스마다) 커널영역이 붙음</p>
<ul>
<li>굉장한 공간 낭비가 있을 수 있겠음</li>
</ul>
</li>
</ul>
<p><img src="%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC6.png" alt="가상메모리총정리6"></p>
<ul>
<li>각 프로세스 마다 커널영역(가상메모리 영역)이 붙어있다 하더라도, 각 프로세스의 페이지 테이블에서 실제로 물리메모리와 메칭되는 주소값을 넣게 되어있음<ul>
<li>실제로 커널 관련된 공간의 (커널 일부 페이지가) CPU에서 실행이 필요할 때, 우리 메모리의 커널 일부 페이지(4KB)를 물리 메모리에 넣게 됨</li>
<li>프로세스 A, B 여러개가 있더라도 가상메모리를 사용하고 가상메모리는 페이지 테이블에서 실제 해당영역을 가르키는 주소값을 맵핑해주는 역할을 하기 때문에, 이 커널 영역(메모리)에 대해서는 동일한 주소를 각각의 페이지 테이블에 넣어주면 물리 메모리의 공간은 낭비하는 것 없이 (= 동일한 커널 페이지를 여러개 만들 필요 없이) 한 페이지만 만들어도, 한 번만 메모리에 넣어도, 주소만 페이지 테이블에서 매핑 시켜서 공간을 추가적으로 낭비할 필요가 없음</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC7.png" alt="가상메모리총정리7"><br>6. 아까 1KB가 가상메모리공간(혹은 실제 메모리)으로 만들어 진다 하더라도, 저 kernel영역은 다른 프로세스에 있는 걸 고대로 가르키기만 함<br>    - 우리가 쓴 코드는 TEXT에 넣어주고,<br>    - Heap에서? 필요한 페이지만 넣어서 동작시키고<br>    - 나머지 필요없는 (큰) 영역들은 페이지 디렉토리 상에서 해당 페이지를 만들지 않으면 됨<br>      - 큰 이슈(오베헤드)없이 동작을 할 수 있게 됨</p>
<p><img src="%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC8.png" alt="가상메모리총정리8"><br>7. 코드가 가상메모리에 올라갔을 때, (=프로세스가 가상메모리에 만들어 졌을 때,) 실제 실행을 하기 전에는 관련된 코드가 바로 적제되진 않음 (DATA, Stack, Heap 등의 영역에 바로적제 안됨)</p>
<ul>
<li><code>lazy allocation</code> : 실행파일은 저장매체(SSD/HDD)에 있으므로, 데이터를 읽어서 물리 메모리에 올리는 작업은 굉장히 많은 시간을 소요함<ul>
<li>최대한 할당을 지연시킴<ul>
<li>실행파일이 가상메모리화되서 프로세스가 만들어지는데</li>
<li>프로세스가 실행하면서 꼭 해당 데이터가 필요한 시점이 되기전까지는 어느 데이타도 파일에서 물리메모리로 직접넣지 않음<ul>
<li>왜냐면 시간이 오래걸리니까 최대한 미룸</li>
</ul>
</li>
<li>마지막 코드가 실행이 되면 (실행이 필요한 시점) 실행해야하니까 해당 페이지를 물리메모리로 올릴것임 $\rightarrow$ 이게 바로 요구 페이징<ul>
<li>기본적인 철학은 lazy allocation과 같은 느낌 : 할당을 지연 (시간을 아낌)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="8">
<li>해당 페이지가, 정말 필요한 시점이 되면 요구 페이징 기법을 사용해서 페이징 폴트가 일어남<ul>
<li> 페이징 폴트가 일어나면, 코드를 물리메모리에 올리고 페이지 테이블을 업데이트해서 해당 페이지를 CPU가 접근해서 데이터를 가져오게 된다. </li>
</ul>
</li>
</ol>
<h3 id="다시정리"><a href="#다시정리" class="headerlink" title="다시정리"></a>다시정리</h3><p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B4%9D%EC%A0%95%EB%A6%AC0.png" alt="가상메모리총정리0"><br>전체적으로 가상메모리가 동작하는 것은</p>
<ol>
<li>CPU가 특정 가상 어드레스를 요청하면</li>
<li>MMU가 일단 캐시에 있는지를 TLB를 보고 확인하고<br>만약에 없으면 해당 페이지의 테이블에가서, 해당 페이지가 물리메모리에 있는 지를 보고</li>
<li>물리메모리에 없다면 페이지 폴트가 일어나서</li>
<li>저장매체에 페이지 블럭을 찾아서</li>
<li>물리메모리에 해당페이지 (페이지 블럭)를 넣어 놓고, </li>
<li>해당페이지와 관련된 페이지 테이블을 업데이트한 뒤에</li>
<li>다시 가상메모리를 요청해서 MMU에서 해당 데이터를 가져오게 끔 동작을 한다.</li>
</ol>
<h3 id="마지막정리"><a href="#마지막정리" class="headerlink" title="마지막정리"></a>마지막정리</h3><p>코드가 실행파일이 되면<br>가상메모리는 4GB(커널영역+사용자영역)가 만들어지고<br>그중 대부분은 커널 관련된 부분 - 다른 프로세스와 동일한 주소를 페이지 테이블에 맵핑시켜 놓음<br>나머지 3기가중에 해당 코드가 쓰는 페이지 테이블(해당 코드의 극히 일부분과 관련된 페이지 디렉토리에 있음) 만 업데이트(만들어 놓음)<br>실제 이 코드가 프로세스가 실행이 되면 정말 이 가상주소를 필요로 할 때, 요구페이징 기법을 사용해서 위에 7가지와 같은 순서(메커니즘)으로 해당데이터가 메모리에 올라가서 실행이 됨</p>
<h1 id="파일-시스템"><a href="#파일-시스템" class="headerlink" title="파일 시스템"></a>파일 시스템</h1><ul>
<li>  파일 시스템: 운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘</li>
</ul>
<hr>
<h2 id="파일-시스템이-만들어진-이유"><a href="#파일-시스템이-만들어진-이유" class="headerlink" title="파일 시스템이 만들어진 이유"></a>파일 시스템이 만들어진 이유</h2><ol>
<li><p>비트관리 $\rightarrow$ 블록관리</p>
<ul>
<li>0과 1의 데이터를 어떻게 저장매체에 저장할까?<ul>
<li>  비트로 관리하기는 오버헤드가 너무 큼</li>
<li>블록 단위로 관리하기로 함 (보통 4KB)<ul>
<li>  주소 수가 확 줄어들음</li>
</ul>
</li>
<li>블록마다 고유 번호를 부여해서, 관리<ul>
<li>  일반적인 사용자가 관리하기 어려움</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>블록관리 $\rightarrow$ 파일관리</p>
<ul>
<li>사용자가 각 블록 고유 번호를 관리하기 어려움<ul>
<li>  추상적(논리적) 객체 필요: 파일</li>
</ul>
</li>
<li>사용자는 파일단위로 관리<ul>
<li>  각 파일에는 블록 단위로 관리<blockquote>
<p>사용자는 추상적 객체인 파일 단위로 관리하고, 각 파일은 내부적으로 블록 단위로 관리 됨</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>저장 방법 (파일 시스템 방식)</p>
<ul>
<li>저장매체에 효율적으로 파일을 저장하는 방법<ul>
<li>  가능한 연속적인 공간에 파일을 저장하는 것이 좋음</li>
</ul>
</li>
<li>외부 단편화문제 발생 (파일 사이즈 변경 문제)<ul>
<li>불연속 공간에 파일 저장 기능 지원 필요<ol>
<li>블록 체인: 블록을 링크드 리스트로 연결<ul>
<li>블록 단위로 저장을 불연속적으로 함 (첫번째블록 주소만 저장)</li>
<li>단점 : 끝에 있는 블록을 찾으려면, 맨 처음 블록부터 주소를 따라가야 함<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8.png" alt="블록체인"></li>
</ul>
</li>
<li>인덱스 블록 기법: 각 블록에 대한 위치 정보를 기록해서, 한번에 끝 블록을 찾아길 수 있도록 함<ul>
<li>요즘 운영체제는 인덱스 블록 기법 기반<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%B8%94%EB%A1%9D%EA%B8%B0%EB%B2%95.png" alt="인덱스블록기법"></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>참고: 링크드 리스트 (datastructure.xlsx -&gt; linkedlist)</p>
</blockquote>
<hr>
<h2 id="다양한-파일-시스템"><a href="#다양한-파일-시스템" class="headerlink" title="다양한 파일 시스템"></a>다양한 파일 시스템</h2><ul>
<li>Windows: FAT, FAT32, NTFS<ul>
<li>  블록 위치를 FAT라는 자료 구조에 기록</li>
</ul>
</li>
<li>리눅스(UNIX): ext2, ext3, ext4<ul>
<li>  일종의 인덱스 블록 기법인 inode 방식 사용</li>
</ul>
</li>
</ul>
<hr>
<h2 id="파일-시스템과-시스템-콜"><a href="#파일-시스템과-시스템-콜" class="headerlink" title="파일 시스템과 시스템 콜"></a>파일 시스템과 시스템 콜</h2><ul>
<li>동일한 시스템콜을 사용해서 다양한 파일 시스템 지원 가능토록 구현<br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%98%A4%ED%94%88.png" alt="파일오픈"><ul>
<li>read/write 시스템 콜 호출시, 각 기기 및 파일 시스템에 따라 실질적인 처리를 담당하는 함수를 구현해둠<ul>
<li>  예: read_spec/write_spec</li>
<li>  즉, 어떤 파일시스템을 사용하는지에 대한 고려는 하지 않고 사용 가능</li>
</ul>
</li>
<li>실제는 파일을 실제 어떻게 저장할지는 다를 수 있음<ul>
<li>리눅스의 경우 ext4 외 NTFS, FAT32 파일 시스템 지원  <img src="https://www.fun-coding.org/00_Images/fileops.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="inode-방식-파일-시스템"><a href="#inode-방식-파일-시스템" class="headerlink" title="inode 방식 파일 시스템"></a>inode 방식 파일 시스템</h2><ul>
<li>파일 시스템 기본 구조 (크게 3가지)<ul>
<li>  수퍼 블록: 파일 시스템 정보 : 파일 시스템 전체에 대해 대표하는 정보</li>
<li>  아이노드 블록: 파일 상세 정보 : 마치 PCB가 프로세스 상태를 저장하듯한 느낌</li>
<li>  데이터 블록: 실제 데이터 (특정 고정된 사이즈로 구성 ex: 1KB ~ 4KB 등)</li>
</ul>
</li>
</ul>
<p>프로세스 생성 $\rightarrow$ process ID $\rightarrow$ PCB $\leftarrow$ 스케줄링 등 여러작업</p>
<p>파일 생성 $\rightarrow$ inode번호 $\rightarrow$ inode블록 $\leftarrow$  파일처리</p>
<hr>
<h3 id="inode-방식-파일-시스템-기본구조"><a href="#inode-방식-파일-시스템-기본구조" class="headerlink" title="inode 방식 파일 시스템 기본구조"></a>inode 방식 파일 시스템 기본구조</h3><ol>
<li>수퍼 블록 파일 시스템 정보 및 파티션 정보 포함 <img src="https://www.fun-coding.org/00_Images/superblock.png"><ul>
<li>FIlesystem : 파일시스템이 뭐가 있는지</li>
<li>1K-blocks : 각각의 파일 시스템은 1KB 짜리 블록이 몇개 인지</li>
<li>Used : 현재 사용되고 있는 용량</li>
<li>Available : 남아있는 용량</li>
<li>Mounted on : 각각의 파일 시스템이 어느 디렉토리(장소)에 있는지</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li>inode 블록<ul>
<li>파일: inode 고유값과 자료구조에 의해 주요 정보 관리<ul>
<li>‘파일이름:inode’ 로 파일이름은 inode 번호와 매칭<ul>
<li>  비슷한느낌 : 프로세스에 프로세스id가 부여되는 것과 같이 파일이름마다 inode가 부여 됨</li>
</ul>
</li>
<li>파일 시스템에서는 inode를 기반으로 파일 엑세스<ul>
<li>  비슷한느낌 : 프로세스 처리를 위해 PCB기반으로 처리하는 것 처럼</li>
</ul>
</li>
<li>inode 기반 메타 데이터 저장  <img src="https://www.fun-coding.org/00_Images/filesystem.png"></li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>데이터 블록<ul>
<li>inode 기반 메타 데이터(파일 권한, 소유자 정보, 파일 사이즈, 생성시간등 시간 관련 정보, 데이터 저장 위치등)<ul>
<li>파일 시스템의 inode 블럭을 가져와 보면 다음과 같음<br>  <img src="https://www.fun-coding.org/00_Images/inode2.png"><ul>
<li>Mode : 파일의 권한</li>
<li>Owner info : 소유자 정보</li>
<li>Size : 파일 사이즈</li>
<li>Timestamps : 생성 시간</li>
<li>Direct Blocks, Indirect Block, Double Indirect, Triple Indirect : 아래에 설명</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="inode-구조와-파일"><a href="#inode-구조와-파일" class="headerlink" title="inode 구조와 파일"></a>inode 구조와 파일</h3><!-- ![](https://www.fun-coding.org/00_Images/superblock_inode.png) -->
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/DirectBlocks.png" alt="DirectBlocks"></p>
<ul>
<li>cat files.txt :  파일에 들어있는 내용을 출력<ul>
<li>파일이름에 해당하는 inode 번호를 찾아서, inode 번호에 맞는 inode 블록으로 접근</li>
<li>파일에 내용을 출력하기 위해<ul>
<li>Direct Blocks, Indirect Block, Double Indirect, Triple Indirect 사용<ul>
<li>Direct Blocks: 12개(파일시스템의 버전마다 다름)의 주소공간을 갖고있는데, 걔네는 실제 데이터 블럭의 주소를 가르키고 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%83%81%EC%84%B8%EC%A0%95%EB%B3%B4.png" alt="파일상세정보"></p>
<ul>
<li>ls -al data10.txt : 파일 상세정보를 출력<ul>
<li>-rw-rw-r– : 파일 권한</li>
<li>ubuntu ubuntu : 시스템 프로그래밍에서 사용자 정보</li>
<li>Nov 4 14:52 : 파일 생성시간<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%83%81%EC%84%B8%EC%A0%95%EB%B3%B4%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0.png" alt="파일상세정보가져오기"></li>
</ul>
</li>
</ul>
<hr>
<h3 id="inode-구조와-파일-데이터"><a href="#inode-구조와-파일-데이터" class="headerlink" title="inode 구조와 파일 데이터"></a>inode 구조와 파일 데이터</h3><ul>
<li>Direct Blocks :  inode 블럭의 주소를 가지고 있는 공간 : 4KB 가 12개 있다고 했는데, 겨우 48KB 임  <ul>
<li>다이렉트 블록의 주소를 2GB(매우크게 잡으면, 늘리면)라고 하면, 다이렉트 블록이 얼마나 커질지… 노답임   </li>
<li>한마디로 inode 블럭이 너무 비효율적여짐</li>
</ul>
</li>
<li>파일은 아주 작은사이즈부터 큰 사이즈 까지 있는데, 그 때마다 inode 블럭을 큰 사이즈에 맞춰서 크게, 작은 사이즈에 맞춰서 작게 가져갈 순 없음<ul>
<li><p>그래서 나온게 3가지 추가 블럭정보</p>
<ul>
<li>Indirect Block, Double Indirect, Triple Indirect    </li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/inode_data.png"></p>
</li>
<li><p>Single Indirect Block : 4KB의 특정 블럭(direct block pointers)을 가르키는데, 이 블럭은 실제 데이터가 아닌, 각각의 주소가 4byte로 표현이 된다면, 1024개(4KB/4byte=1024)의 실제 데이터를 가지고있는 데이터블럭의 주소를 가르키고 있음 </p>
<ul>
<li>  약 4MB의 블럭 (1024개 * 4KB = 4MB)</li>
</ul>
</li>
<li><p>Double Indirect Block : single indirect pointers의 주소를 가진 4KB 블록을 가르키고, 1024개의 각각의 블록(direct block pointers)은 1024개의 데이터블록의 주소를 가르키고 있음</p>
<ul>
<li>  약 4GB의 데이터블록 (1024 * 1024 * 4KB = 4GB)</li>
</ul>
</li>
<li><p>Triple Indirect Block : double indirect pointers를 가르키는데, 걔네는 1024개(4KB/4byte=1024)의 single indirect pointers를 가르키고있고, 걔네는 다시 각각 1024개의 direct block pointers 를 가르키고, 각각의 direct block pointers 다시 1024개의 데이터블록을 가르킴</p>
<ul>
<li> 약 4GB의 데이터블록 (1024 * 1024 * 1024 * 4KB = 400GB)<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/datablckpointers.png" alt="datablckpointers"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="디렉토리-엔트리"><a href="#디렉토리-엔트리" class="headerlink" title="디렉토리 엔트리"></a>디렉토리 엔트리</h2><p>/ : 루트디렉토리  </p>
<ul>
<li>리눅스 파일 탐색: 예 - /home/ubuntu/link.txt<ul>
<li>저렇게 찾기위해 디렉토리 엔트리 구조를 가짐   </li>
</ul>
<ol>
<li><strong>각 디렉토리 엔트리(dentry)를 탐색</strong><ul>
<li>  각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있음</li>
</ul>
</li>
<li> ‘/‘ dentry 에서 ‘home’을 찾고, ‘home’에서 ‘ubuntu’를 찾고, ‘ubuntu’에서 link.txt 파일이름에 해당하는 <strong>inode를 얻음</strong></li>
</ol>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/dentry.png"></p>
<hr>
<h2 id="가상-파일-시스템-Virtual-File-System"><a href="#가상-파일-시스템-Virtual-File-System" class="headerlink" title="가상 파일 시스템(Virtual File System)"></a>가상 파일 시스템(Virtual File System)</h2><p>일반사용자는 open, read, write를 사용시 파일 시스템 종류를 고민할 필요 없이 쓰면 됨  </p>
<ul>
<li>read-spec, write-spec 등 내부적으로 알아서 처리되게 만들어 놓음<blockquote>
<p>즉, 파일 시스템 종류 1, 2에 대해서 상위 파일시스템 인터페이스(시스템콜)이 동일하다</p>
</blockquote>
</li>
</ul>
<p>그런데 여기서 확장을해서  </p>
<blockquote>
<p>다른 기기, 디바이스에도 확장을 함</p>
</blockquote>
<ul>
<li>Network (다른 PC와 통신하는 것)는 통신하는 네트워크 기기임에 불구하고, 파일시스템 인터페이스를 사용하여, 네트워크에 있는 데이터를 쓰거나 읽게끔 파일 시스템을 확장함</li>
<li>이것을 VFS interface (Virtual File System interface)</li>
</ul>
<hr>
<ul>
<li>  Network등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 가능</li>
<li>예: read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현 (운영체제 내부)  <img src="https://www.fun-coding.org/00_Images/vfs.png"><blockquote>
<p>전통적인 유닉스 시스템에서는 파일 시스템 뿐만 아닌 <strong>모든 디바이스 를</strong> <em>VFS 인터페이스를 사용하여</em> <strong>파일처럼 다룸</strong></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="참고-리눅스-유닉스-운영체제와-가상-파일-시스템"><a href="#참고-리눅스-유닉스-운영체제와-가상-파일-시스템" class="headerlink" title="참고: 리눅스(유닉스) 운영체제와 가상 파일 시스템"></a>참고: 리눅스(유닉스) 운영체제와 가상 파일 시스템</h3><ul>
<li>모든 것은 파일이라는 철학을 따름<ul>
<li>  모든 인터렉션은 파일을 읽고, 쓰는 것처럼 이루어져있음</li>
<li>  마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다루어짐</li>
<li><strong>모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용</strong><br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%82%B4%EB%B6%80%EB%A5%BC%EB%AA%B0%EB%9D%BC%EB%8F%84%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC%ED%86%B5%ED%95%B4%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5.png" alt="내부를몰라도인터페이스만 사용하면 사용이 가능"></li>
</ul>
</li>
</ul>
<hr>
<h3 id="참고-특수-파일"><a href="#참고-특수-파일" class="headerlink" title="참고: 특수 파일"></a>참고: 특수 파일</h3><ul>
<li>디바이스<ul>
<li>블록 다바이스(Block Device) : HDD, CD/DVD와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송, IO 송수신 속도가 높음<ul>
<li>  대용량 데이터가 왔다갔다해야하므로, 정해진 단위로 내부에서 송수신이 이루어짐</li>
</ul>
</li>
<li>캐릭터 디바이스(Character Device) : 키보드, 마우스등 byte 단위 데이터 전송, IO 송수신 속도가 낮음<blockquote>
<p>내부적인 처리는 달라도, 외부적인 파일시스템 인터페이스는 동일하다</p>
</blockquote>
</li>
<li>cd /dev, cat tty<pre><code>  brw-r-----            disk0
  crw-rw-rw-            tty
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><ul>
<li>  컴퓨터를 켜서 동작시키는 절차</li>
<li>Boot 프로그램<ul>
<li>  운영체제 커널을 Storage에서 특정 주소의 물리 메모리로 복사하고 커널의 처음 실행위치로 PC를 가져다 놓는 프로그램</li>
</ul>
</li>
</ul>
<p>폰노이만 구조 : CPU, 메모리, 프로그램 구조를 갖는 프로그램 내장 방식 컴퓨터<br>메모리에 올라와 있는 프로세스가 동작해야함<br>맨 처음엔 아무것도 없을텐데 대체 어디서 가져오는 걸까?!<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EB%B6%80%ED%8C%85%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90%EC%95%84%EB%AC%B4%EA%B2%83%EB%8F%84%EC%97%86%EC%9D%8C.png" alt="부팅시메모리에아무것도없음"></p>
<hr>
<h2 id="부팅-과정"><a href="#부팅-과정" class="headerlink" title="부팅 과정"></a>부팅 과정</h2><ul>
<li><p>컴퓨터를 키면</p>
<ul>
<li><p>BIOS가 특정 Storage 읽어와 bootstrap loader를 메모리에 올리고 실행함</p>
<ul>
<li>  ROM-BIOS(특별한 RAM) 바이오스 칩은 컴퓨터를 껏다 켜도 유지됨</li>
</ul>
</li>
<li><p>bootstrap loader 프로그램이 있는 곳을 찾아서 실행시킴</p>
<p>  <img src="https://www.fun-coding.org/00_Images/boot.png"></p>
</li>
</ul>
</li>
</ul>
<ol>
<li>BIOS 코드 (프로그램) 로드<ul>
<li>컴퓨터(하드웨어)를 초기화</li>
<li>저장매체 MBR 을 찾아감</li>
<li>특정 size의 프로그램을 읽어옴 $\rightarrow$ <strong>부트 로더</strong></li>
<li>부트 로더의 처음을 실행시킴</li>
</ul>
</li>
<li>부트 로더 로드<ul>
<li>MBR(저장매체에 있에 있음)에 적혀있는 특정 코드를 봄 (읽음)<ul>
<li>여기엔 파티션 테이블이 적혀있음<ul>
<li>C:/  D:/   $\rightarrow$  C:/v 여기에 운영체제 들어가 있음</li>
<li>/     /mnt  $\rightarrow$  /v 여기에 운영체제 들어가 있음</li>
</ul>
</li>
</ul>
</li>
<li>파티션 테이블의 정보가 같이 메모리에 들어가서, 어떤 파티션이 메인파티션인지를 알아냄</li>
</ul>
</li>
<li>부트 코드 로드<ul>
<li>부트로더 프로그램이 해당 파티션에 부트섹터로 저장매체의 주소를 따라감 </li>
<li>각 파티션마다 부트섹터라는 특별한 공간이 있음</li>
<li>부트코드를 읽어냄 (메모리에 올림)</li>
<li>(메모리에 올려진) 부트 코드로 실행을 바꿈</li>
</ul>
</li>
<li>운영체제 이미지 로드 <ul>
<li>부트코드의 역할 : 해당 파티션안에 커널이미지(운영체제의 실행파일임)의 주소를 알아내서, 해당 주소부터 시작해서 커널이미지를 쭉 읽어냄</li>
<li>커널이미지의 맨 앞으로 PC(Program Counter)를 옮기면, 우리가 익히 알고 있는 실행화면(윈도우 실행화면, 로그인 화면, 터미널모드면 터미널 등)이 뜸</li>
<li>즉, PC가 실행됨!</li>
</ul>
</li>
</ol>
<hr>
<h1 id="Virtual-Machine-가상-머신"><a href="#Virtual-Machine-가상-머신" class="headerlink" title="Virtual Machine (가상 머신)"></a>Virtual Machine (가상 머신)</h1><p>간단한 동작의 이해와, 사용법만 익히자! (너무 깊게는 그쪽분야 석사지식..)</p>
<ul>
<li><p>하나의 하드웨어(CPU, Memory등)에 다수의 운영체제를 설치하고, 개별 컴퓨터처럼 동작하도록 하는 프로그램<br>  <img src="https://www.fun-coding.org/00_Images/vm.png"></p>
<ul>
<li>가상머신이라는 소프트웨어가 마치 하드웨어처럼 동작함 (이를 에뮬레이터 한다고 함, 모사 함)</li>
<li>각 가상머신마다 운영체제를 설치해서 마치 컴퓨터가 여러대인 것 처럼 보이는 기술 </li>
</ul>
</li>
</ul>
<hr>
<h2 id="Virtual-Machine-구분"><a href="#Virtual-Machine-구분" class="headerlink" title="Virtual Machine 구분"></a>Virtual Machine 구분</h2><p>초창기 어떻게 구분할까 고민하다보니 여러가지 구현방식이 나왔고, 각각의 구현방식에 따라 구분됨</p>
<p>크게 2개정도 있음</p>
<ul>
<li>Virtual Machine Type1  Vs  Virtual Machine Type2</li>
<li>Full Virtualization(전가상화)  VS  Half Virtualization(반가상화)</li>
</ul>
<p>구분 기준과 각각의 구성을 이해해보자</p>
<h3 id="Virtual-Machine-Type1-native-또는-bare-metal"><a href="#Virtual-Machine-Type1-native-또는-bare-metal" class="headerlink" title="Virtual Machine Type1 (native 또는 bare metal)"></a>Virtual Machine Type1 (native 또는 bare metal)</h3><p>하드웨어위에 하드웨어를 에뮬레이터 하는 소프트웨어 (하이퍼바이저 또는 버추얼 머신 모니터, VMM 이라 함)가 있음</p>
<p>이 소프트웨어를 하드웨어 바로 위에 설치하고, 그 위에 가상머신 여러개를 구현하는 방식</p>
<ul>
<li>  하이퍼 바이저(또는 VMM): 운영 체제와 응용프로그램을 물리적 하드웨어에서 분리하는 프로세스</li>
<li>하이퍼바이저 또는 버추얼 머신 모니터 (VMM)라고 하는 소프트웨어가 Hardware 에서 직접 구동<ul>
<li>  Xen, KVM</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/vmtype1.png"></p>
<hr>
<h3 id="Virtual-Machine-Type2"><a href="#Virtual-Machine-Type2" class="headerlink" title="Virtual Machine Type2"></a>Virtual Machine Type2</h3><p>하드웨어 위에 이미 하나의 운영체제(리눅스, 윈도우즈, 맥OS …)가 설치되어 있음  </p>
<p>운영체제가 있기 때문에 그 위에서 당연히 앱을 구동시킬 수 있는데<br>하이퍼바이저(=버추얼 머신모니터, VMM)을 설치해서 (앱처럼 보고) 가상머신을 올림</p>
<ul>
<li>하이퍼바이저 또는 버추얼 머신 모니터 (VMM)라고 하는 소프트웨어가 Host OS 상위에 설치<ul>
<li>  VMWare, Parallels Desktop (Mac)</li>
</ul>
</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/vmtype2.png"></p>
<hr>
<h3 id="Full-Virtualization-전가상화"><a href="#Full-Virtualization-전가상화" class="headerlink" title="Full Virtualization(전가상화)"></a>Full Virtualization(전가상화)</h3><ul>
<li>전가상화: 각 가상머신이 하이퍼바이저를 통해서 하드웨어와 통신<ul>
<li>하이퍼바이저가 마치 하드웨어인 것처럼 동작하므로, 가상머신의 OS는 자신이 가상 머신인 상태인지를 모름<ul>
<li><p>가상머신에 설치되어있는 OS에 맞춰 VMM이 하드웨어에게 명령(또는 데이터)을 번역해줌</p>
<p><img src="https://www.fun-coding.org/00_Images/fullvm.png"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Half-Virtualization-반가상화"><a href="#Half-Virtualization-반가상화" class="headerlink" title="Half Virtualization(반가상화)"></a>Half Virtualization(반가상화)</h3><ul>
<li>반가상화: 각 가상머신에서 직접 하드웨어와 통신<ul>
<li>각 가상머신에 설치되는 OS는 가상 머신인 경우, 이를 인지하고, 각 명령에 하이퍼바이저 명령을 추가해서 하드웨어와 통신<ul>
<li>직접적으로 명령에 명시를 함 (가상머신을 위한 명령이라 요청을 할 때 명시함)<ul>
<li>다이렉트로 명령하므로, 전가상화보다 빠름. 그러나 OS 수정필요 (복잡도 $\uparrow$ 성능 $\downarrow$)</li>
</ul>
</li>
<li>VMM은 리소스 관리만 함<br><img src="https://www.fun-coding.org/00_Images/halfvm.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="최근-HW-성능-개선으로-전가상화-기술을-선호"><a href="#최근-HW-성능-개선으로-전가상화-기술을-선호" class="headerlink" title="최근 HW 성능 개선으로 전가상화 기술을 선호"></a>최근 HW 성능 개선으로 전가상화 기술을 선호</h2><h3 id="VMWare"><a href="#VMWare" class="headerlink" title="VMWare"></a>VMWare</h3><ul>
<li>  VMWare: 대중적인 가상머신 프로그램(Type2)</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/vmtype2.png"></p>
<hr>
<h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>클라우드 서비스라는건 100대의 컴퓨터를 가지고, 만명의 사람이 사용하는 결국 가상머신 사용하는 기술</p>
<ul>
<li><p>AWS(아마존 클라우드 컴퓨팅 서비스)등에서 사용(Type1)</p>
<p>  <img src="https://www.fun-coding.org/00_Images/kvm.png"></p>
<ul>
<li><p>Intel-VT등 가상화 기능을 가진 CPU에서는 VMX root/VMX non-root 모드 존재</p>
<ul>
<li>리눅스커널에 있는 기능을 사용함<ul>
<li>ioctl() 이라는 시스템콜이 있는데, 하드웨어 직접 명령(제어)가 가능한 특징을 가짐</li>
<li>CPU에 vCPU(가상CPU)를 만들어달라는 명령을 함 (인텔의 경우 Intel-VT 라는 명령어 셋을 사용)</li>
</ul>
</li>
<li>  CPU 하나로 가상머신 여러개를 어떻게 사용할까 하다가, 나온것이 VMX root/VMX non-root 모드</li>
</ul>
</li>
<li><p>각 모드별로 protection ring 0 ~ 3 지원, 가상화 기능을 사용하지 않을 경우, VMX root 모드사용</p>
<ul>
<li>  (복습) CPU에 protection ring 이 0(커널사용) 부터 3(응용프로그램사용) 까지 있었음</li>
<li>  컴퓨터가 CPU하나만 사용하면 VMX root 에 있는 protection ring 사용</li>
<li>  vCPU가 생성되서 요청을하면 VMX non-root 에 있는 protection ring 사용</li>
</ul>
</li>
</ul>
<ul>
<li><p>KVM은 각 가상 시스템에 대응하는 (=각각의 머신마다) KVM 프로세스 실행, KVM 모듈(/dev/kvm 즉, 인터페이스)을 통해 vCPU 사용</p>
</li>
<li><p>KVM 프로세스 기반 게스트 커널(VMX non-root / RING 0 사용), QEMU 장치 에뮬레이터가 로드됨</p>
<ul>
<li>  KVM 프로세스 안에다가 윈도우든 리눅스든 게스트 커널 설치가능</li>
<li>QEMU 장치 에뮬레이터 : 리눅스에서 IO 디바이스들을 소프트웨어로 에뮬레이터하는 장치</li>
</ul>
</li>
<li><p>게스트 커널 위에서 실행되는 응용 프로그램은 VMX non-root / RING 3 사용</p>
<ul>
<li>게스트 커널은 VMX non-root / RING 0 을 사용</li>
</ul>
</li>
<li><p>게스트 커널이 물리적 HW 자원 필요시, VM exit 가 발생, KVM 모듈에서 해당 요청 처리</p>
<ul>
<li>  물리적 HW 자원 필요 =&gt; CPU가 아닌 IO device 등이 필요할 때</li>
<li>  VM exit 발생 : 일종의 인터럽트 발생 $\rightarrow$ QEMU 장치 에뮬레이터에 하드웨어 자원처리를 요청</li>
</ul>
</li>
<li><p>일반 HW 자원은 QEMU 장치 에뮬레이터에서 처리</p>
<ul>
<li>QEMU 장치 에뮬레이터는 VMX root / RING 3를 통해, 호스트 커널에 요청 후, 해당 데이터는 공유 메모리를 통해 KVM 게스트 커널과 공유<ul>
<li>QEMU 장치 에뮬레이터는 IO device들을 소프트웨어로 에뮬레이터하고 있기 때문에, 해당 IO device에서 필요한 데이터를 송수신함.<ul>
<li>  장치 에뮬레이터를 게스트 커널에 엑세스 할 수 있기 때문에, 해당 데이터를 받아와서 응용프로그램에 주게 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="또-다른-가상-머신-Docker-가상-머신-vs-Docker"><a href="#또-다른-가상-머신-Docker-가상-머신-vs-Docker" class="headerlink" title="또 다른 가상 머신: Docker (가상 머신 vs Docker)"></a>또 다른 가상 머신: Docker (가상 머신 vs Docker)</h3><ul>
<li><strong>가상 머신은</strong> 컴퓨터 하드웨어를 가상화 <strong>(하드웨어 전체 추상화)</strong><ul>
<li>  하이퍼바이저 사용, 추가 OS 필요등 성능 저하 이슈 존재</li>
</ul>
</li>
<li><strong>Docker는</strong> 운영체제 레벨에서 별도로 분리된 실행환경을 제공 <strong>(커널 추상화)</strong><ul>
<li>마치 리눅스 처음 설치했을때와 유사한 실행환경을 만들어주는 리눅스 컨테이너 기술 기반<ul>
<li>chroot 라는 리눅스 명령이 있는데, 마치 분리된듯 한 공간이 만듦<ul>
<li>운영체제에 별도의(분리된 공간으로) 응용프로그램 실행환경을 만듦<ul>
<li>  root, 파일 시스템 등 다 다를 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>리눅스 컨테이너 기술이므로 macOS나 windows에 설치할 경우는 가상 머신 기반 제공  <img src="https://www.fun-coding.org/00_Images/docker.png"></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Docker-예-참고"><a href="#Docker-예-참고" class="headerlink" title="Docker 예 (참고)"></a>Docker 예 (참고)</h4><ul>
<li><p>Docker 로 운영체제/프로그램 이미지로 관리</p>
<p>  docker pull ubuntu:latest<br>  docker images<br>  docker run -i -t –name hello ubuntu /bin/bash<br>  docker start hello<br>  docker restart hello<br>  docker attach hello</p>
</li>
</ul>
<hr>
<h2 id="가상-머신-정리"><a href="#가상-머신-정리" class="headerlink" title="가상 머신 정리"></a>가상 머신 정리</h2><ul>
<li>Bare-Metal 방식이 가장 성능이 좋음<ul>
<li>  하드웨어 직접 엑세스하기 때문</li>
<li>  AWS(클라우드 컴퓨팅) 환경도 Bare-Metal 기반 가상 머신 기술 활용 (KVM)</li>
</ul>
</li>
<li>Docker는 경량 이미지로 <strong>실행환경을 통째로 백업, 실행 가능</strong> (실무에 많이 사용됨)<br>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8B%A4%ED%96%89%ED%99%98%EA%B2%BD%EC%84%A4%EC%B9%98.png" alt="실행환경설치"><ul>
<li>  Data Engineering에서 Docker로 시스템 환경 설정 + 프로그램을 한번에 배포</li>
<li>  예: 프로그램 업데이트 -&gt; Docker 이미지 작성 -&gt; Jenkins로 배치잡 생성 및 실행(AWS EC2 재생성 및 Docker 이미지 설치, 실행)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Java-Virtual-Machine"><a href="#Java-Virtual-Machine" class="headerlink" title="Java Virtual Machine"></a>Java Virtual Machine</h3><ul>
<li>가상 머신과는 다른 목적 (응용프로그램 레벨 가상화)<ul>
<li>응용프로그램 실행 환경에 따라, 실행을 알아서 맞춰줌<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/JavaVM.png" alt="JavaVM"></li>
</ul>
</li>
<li>  Java 컴파일러는 CPU dependency를 가지지 않는 bytecode를 생성함</li>
<li>이 파일을 Java Virtual Machine에서 실행함<ul>
<li>  바이트코드를 해석해서 각각에 운영체제에 맞게 명령을 만들어줌</li>
</ul>
</li>
<li>  각 운영체제를 위한 Java Virtual Machine 프로그램 존재</li>
</ul>
<p><img src="https://www.fun-coding.org/00_Images/javavm.png"></p>
<hr>
<h1 id="운영체제-총정리"><a href="#운영체제-총정리" class="headerlink" title="운영체제 총정리"></a>운영체제 총정리</h1><p>운영체제 이해를 바탕으로 실제 운영체제 구조 및 설계를 이해해보자</p>
<h2 id="실제-운영체제의-이해"><a href="#실제-운영체제의-이해" class="headerlink" title="실제 운영체제의 이해"></a>실제 운영체제의 이해</h2><ul>
<li><p>리눅스 운영체제</p>
<ul>
<li><p>리눅스 커널(운영체제) + 시스템 프로그램(쉘) + 응용 프로그램</p>
  <!-- ![](https://www.fun-coding.org/00_Images/kernel.png) -->
<p>  <img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%8B%A4%EC%A0%9C%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A1%9C%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%B4%9D%EC%A0%95%EB%A6%AC.png" alt="실제리눅스로운영체제총정리"></p>
<ul>
<li>Hardware<ul>
<li>various terminal equipment : IO device</li>
<li>network adapter : 네트워크 과목에서 다룰거임</li>
</ul>
</li>
<li>Linux-Kernal<ul>
<li>Components (5가지) : Process management, Memory management, File system, Device dirvers, Network<ul>
<li>Process management : 프로세스 어떻게 관리하냐<ul>
<li>Scheduler 에 달림<ul>
<li>하드웨어에선 CPU 동작과 관련됨</li>
</ul>
</li>
</ul>
</li>
<li>Memory management<ul>
<li>Virtual memory : 페이징시스템을 가지고함<ul>
<li>하드웨어에선 RAM 과 관련이 높음</li>
</ul>
</li>
</ul>
</li>
<li>File system<ul>
<li>Files, directories : inode 방식으로 파일과 디렉토리를 다룸  </li>
</ul>
</li>
<li>Device dirvers <ul>
<li>크게는 Block devices와 Character devices로 나눔<ul>
<li>Block devices : 특정 사이즈만큼 데이터를 송수신하여 디바이스를 관리<ul>
<li>Hard disk, CD, Floppy disk 등</li>
<li>인터페이스는 가상파일 시스템을 사용 (파일 시스템을 다루는 인터페이스(시스템콜)을 사용해서 모든 디바이스들을 다 추상화해서 다룰 수 있게금 함)</li>
</ul>
</li>
<li>Character devices : 1byte 씩 송수신<ul>
<li>Various terminal equipment (마우스, 키보드 등)</li>
</ul>
</li>
</ul>
</li>
<li>File system, Device dirvers 는 모두 가상파일 시스템에서 다뤄짐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>User space<ul>
<li>응용프로그램이 어떻게 리눅스 커널과 통신을 할까?<ul>
<li>리눅스에서 제공하는 시스템콜을 통해 통신한다.</li>
<li>시스템 콜을 통해 자원을 주고 받음</li>
<li>Shell : 특별한 형태의 Application : 사용자에게 인터페이스를 제공해서 응용프로그램을 실행시키거나, 시스템의 운영체제와 통신을 할 수 있도록 함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="쉘-종류"><a href="#쉘-종류" class="headerlink" title="쉘 종류"></a>쉘 종류</h3><ul>
<li>쉘(shell): 사용자와 컴퓨터 하드웨어 또는 운영체제간 인터페이스<ul>
<li>  사용자의 명령을 해석해서, 커널에 명령을 요청해주는 역할</li>
<li>  관련된 <strong>시스템콜을 사용</strong>해서 프로그래밍이 작성되어 있다.</li>
</ul>
</li>
<li>쉘 종류<ul>
<li>  Bourne-Again Shell (bash) : GNU 프로젝트의 일환으로 개발됨, 리눅스 거의 디폴트임</li>
<li>  Bourne Shell (sh)</li>
<li>  C Shell (csh)</li>
<li>  Korn Shell (ksh) : 유닉스에서 가장 많이 사용됨</li>
</ul>
</li>
</ul>
<hr>
<h2 id="실제-운영체제의-이해-다시-정리"><a href="#실제-운영체제의-이해-다시-정리" class="headerlink" title="실제 운영체제의 이해 다시 정리"></a>실제 운영체제의 이해 다시 정리</h2><ul>
<li>process management<ul>
<li>  응용 프로그램은 여러개의 process로 관리됨 (따라서 핵심은 멀티 프로그래밍)</li>
<li>process scheduler<ul>
<li>  process 실행, 종료 관리</li>
<li>  인터럽트 처리 관리</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>memory management<ul>
<li>가상 메모리<ul>
<li>  page 기반 메모리 관리</li>
</ul>
</li>
</ul>
</li>
<li>IO device management<ul>
<li>  VFS(Virtual File Syste) 을 사용하여 유사한 인터페이스로 지원이 된다</li>
<li>  file, Device drivers, Network 관리</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>시스템 프로그램<ul>
<li>핵심은 쉘<ul>
<li>  bash (Bourne-again shell)</li>
<li>  내부는 시스템콜을 호출하도록 구현</li>
</ul>
</li>
<li>각 프로그래밍 언어<ul>
<li>각 운영체제마다 별도로 구현이 되야 함<ul>
<li>시스템콜은 운영체제에서 제공이 되는데, 각 라이브러리에 있는 함수들은 내부적으로는 해당 시스템콜을 호출하도록 구현을 함. (이 함수를 각 프로그래밍 언어에 맞게 제공을 하면 됨)<ul>
<li>예시 : Linux 운영체제에서 Python 프로그래밍 언어를 동작시킬 때, 내가 open_file() 이라는 함수를 구현하려고 한다면, 그 함수안에 리눅스가 제공하는 시스템콜이 들어가 있어야 함<ul>
<li>이걸 컴파일해서 라이브러리로 만들고, 쓸 수 있게 만들면 그게 파이썬에서 파일처리가 가능한 라이브러리임<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%B2%98%EB%A6%AC%EC%A7%80%EC%9B%90%EC%9D%80%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%90%EB%8B%AC%EB%A6%BC.png" alt="파일처리지원은운영체제에달림"> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  필요시 해당 운영체제의 시스템콜 호출</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="안드로이드-스마트폰-Android"><a href="#안드로이드-스마트폰-Android" class="headerlink" title="안드로이드 스마트폰 (Android)"></a>안드로이드 스마트폰 (Android)</h2><ul>
<li><p>Linux Kernel + (Shell + Some basic programs) + Andorid Framework</p>
<p>  <img src="https://www.fun-coding.org/00_Images/android.png"></p>
<ul>
<li>리눅스 커널이 깔려 있기 때문에, 쉘 사용 가능하며, 리눅스 PC처럼 사용이 가능하다<ul>
<li>또는 쉘(터미널)만 연결해서 리눅스 명령을 내릴 수 있다</li>
</ul>
</li>
<li>안드로이드 런타임 부분에 JAVA VM 이 들어있음<ul>
<li>JAVA VM : 똑같은 코드를 운영체제에 맞게 코드를 바꿔서 실행시켜주는 기능을 함<br><img src="/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%ED%94%8C%EB%9E%AB%ED%8F%BC.png" alt="안드로이드플랫폼"><ul>
<li>안정적인 운영체제 커널을 만들기 위해선 시간이 너무 오래걸림</li>
<li>수십년동안 사용된 리눅스 커널을 사용하는 것이 이득이었음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="가볍게-이해하기-IoT"><a href="#가볍게-이해하기-IoT" class="headerlink" title="가볍게 이해하기: IoT"></a>가볍게 이해하기: IoT</h2><ul>
<li>IoT: 사물인터넷(Internet of Things)<ul>
<li>  각종 사물에 센서와 통신 기능을 내장하여 인터넷에 연결하는 기술</li>
</ul>
</li>
</ul>
<hr>
<h3 id="IoT-예-스마트-온도계"><a href="#IoT-예-스마트-온도계" class="headerlink" title="IoT 예 (스마트 온도계)"></a>IoT 예 (스마트 온도계)</h3><pre><code>무게 : 7.5g 
통신 : 블루투스 LE 
스피커 : 피에조 
배터리 : CR2032 (약 6개월 사용 가능) (전력사용을 줄이기 위해 초소형 기기를 사용해야 함 : RaspberryPi 등)
측정온도 : -20도씨에서 60도씨까지, 0.1도 단위 
측정범위 : 약 60m 
앱 지원 : iOS / 안드로이드 
가격 : $29 
</code></pre>
<p>물어 볼 곳 : <a target="_blank" rel="noopener" href="https://sen.se/store/thermopeanut/">https://sen.se/store/thermopeanut/</a> 출처: <a target="_blank" rel="noopener" href="http://www.iotdanawa.com/archives/8919">http://www.iotdanawa.com/archives/8919</a></p>
<hr>
<h3 id="IoT-하드웨어-예"><a href="#IoT-하드웨어-예" class="headerlink" title="IoT 하드웨어 예"></a>IoT 하드웨어 예</h3><p>출처: <a target="_blank" rel="noopener" href="http://linuxgizmos.com/files/rpi_pi3_detail.jpg">http://linuxgizmos.com/files/rpi_pi3_detail.jpg</a></p>
<p><img src="https://www.fun-coding.org/00_Images/rasberry.png"></p>
<ul>
<li>Raspberry Pi<ul>
<li>HW가 아주 작음</li>
<li>온도만 측정하거나, 인터넷만 되면되고, 여러 프로세스를 실행할 필요가 없음</li>
<li>가상메모리를 사용할 이유가 없음</li>
</ul>
</li>
</ul>
<hr>
<h3 id="IoT와-운영체제"><a href="#IoT와-운영체제" class="headerlink" title="IoT와 운영체제"></a>IoT와 운영체제</h3><ul>
<li><p>IoT 관련 OS - 초소형 기기의 경우, OS 기능 최소화</p>
<ul>
<li>  출처: <a target="_blank" rel="noopener" href="https://devopedia.org/images/article/15/4858.1525403330.jpg">https://devopedia.org/images/article/15/4858.1525403330.jpg</a></li>
</ul>
</li>
<li><p>TinyOS 예</p>
<p>  <img src="https://www.fun-coding.org/00_Images/tinyos.png"></p>
<blockquote>
<p>출처: <a target="_blank" rel="noopener" href="https://www.slideshare.net/snecute/tinyos">https://www.slideshare.net/snecute/tinyos</a></p>
</blockquote>
<ul>
<li>하드웨어가 들어오는 센싱(온도정보 등), 외부로 커뮤니케이션 정도만하면<ul>
<li>멀티태스킹 필요없고, 보호모드 필요없고, 가상메모리도 필요 없음 (그냥 물리메모리를 사용)</li>
<li>파일 시스템도 필요없음 (그냥 특정 주소에 해당코드를 바로 받으면 됨)</li>
<li>물리메모리에 바로 올려서 사용</li>
</ul>
</li>
</ul>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> Thanks for reading my post. </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">Title:</span>운영체제</p>
    
    <p><span class="copy-title">Author:</span><a  title="Chaejin Kim">Chaejin Kim</a></p>
    <p><span class="copy-title">Created At:</span>2021-03-07, 16:26:55</p>
    <p><span class="copy-title">Updated At:</span>2021-03-10, 23:52:48</p>
    <span class="copy-title">Url:</span><a class="post-url" href="/2021/03/07/ComputerScience/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/" title="운영체제">https://chaejin-jen.github.io/2021/03/07/ComputerScience/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/</a>
    <p>
        <span class="copy-title">Copyright:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#39;Attribution-non-commercial-shared in the same way 4.0&#39;</a> Reprint please keep the original link and author.
    </p>
</div>





    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021 Chaejin Kim
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="전체 화면 전환 단축키 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 572px;
    }
    .nav.fullscreen {
        margin-right: -572px;
    }
    .nav-left {
        width: 150px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 542px;
        }
        .nav.fullscreen {
            margin-right: -542px;
        }
        .nav-left {
            width: 150px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 542px;
            margin-right: -542px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #3390FF;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
