<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>컴퓨터 구조 | Chaejin&#39;s Blog</title>
  <meta name="keywords" content=" Computer Science , Computer Architecture ">
  <meta name="description" content="컴퓨터 구조 | Chaejin&#39;s Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="FAST CAMPUS ONLINE 컴퓨터 구조강사 : 이승주     목차w&#x2F;W : 글 목차 확인 또는 글 목록 보기s&#x2F;S : 디렉토리 숨기기 또는 열기 01. 왜 배울까? 현대의 컴퓨터란?  상태 머신(State Machine)과 소프트웨어  State Machine : 자료 입력받고, 프로세스 처리하고 저장하고 결과내고 등 기본적인 상태  (인강 그대로">
<meta property="og:type" content="article">
<meta property="og:title" content="컴퓨터 구조">
<meta property="og:url" content="https://chaejin-jen.github.io/2021/04/12/ComputerScience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/index.html">
<meta property="og:site_name" content="Chaejin&#39;s Blog">
<meta property="og:description" content="FAST CAMPUS ONLINE 컴퓨터 구조강사 : 이승주     목차w&#x2F;W : 글 목차 확인 또는 글 목록 보기s&#x2F;S : 디렉토리 숨기기 또는 열기 01. 왜 배울까? 현대의 컴퓨터란?  상태 머신(State Machine)과 소프트웨어  State Machine : 자료 입력받고, 프로세스 처리하고 저장하고 결과내고 등 기본적인 상태  (인강 그대로">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BD%94%EB%93%9C%EC%83%81%ED%83%9C%EB%A8%B8%EC%8B%A0%EA%B5%AC%ED%98%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BB%B4%ED%93%A8%ED%84%B0%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EA%B5%AC%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8B%A8%EC%9C%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B3%84%EC%82%B0%EA%B8%B0%EC%97%90%EC%84%9C%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B9%8C%EC%A7%80.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%86%B5%EC%8B%A0%EA%B8%B0%EA%B8%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9C%A0%EB%B9%84%EC%BF%BC%ED%84%B0%EC%8A%A4.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Mobile%EA%B3%BCWireless.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/IoT.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/AI.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/mother_board.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/memory_unit.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Memory_unit_and_Auxiliary_memory_device.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Memory_unit_and_Auxiliary_memory_device2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/NOS%EC%9D%98%EC%97%AD%ED%95%A0%ED%99%95%EB%8C%80.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/5G%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%96%91%EC%9E%90%EB%B3%91%EB%A0%AC%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9B%B9%EC%9D%98%EB%AF%B8%EB%9E%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9E%90%EB%A3%8C%EC%9D%98%ED%91%9C%ED%98%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8B%A8%EC%9C%840.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8B%A8%EC%9C%842.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/number_system.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/10%EC%A7%84%EC%88%982%EC%A7%84%EC%88%98%EB%B3%80%ED%99%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/2%EC%A7%84%EC%88%9810%EC%A7%84%EC%88%98%EB%B3%80%ED%99%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/8_16%EC%A7%84%EC%88%982%EC%A7%84%EC%88%98%EB%B3%80%ED%99%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/2sComplement1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/2sComplement2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%B4%EC%88%98%EC%9D%98%EC%A4%91%EC%9A%94%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/addition_with_complement.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%A4%EC%88%98%EC%9D%98%EB%B3%80%ED%99%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%EC%88%AB%EC%A0%90%EC%95%84%EB%9E%98%EA%B0%92%ED%91%9C%ED%98%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%EC%88%98%EC%A0%90%ED%91%9C%ED%98%84_%EC%88%9C%ED%99%98%EB%B0%98%EB%B3%B5.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A0%95%EC%88%98%ED%91%9C%ED%98%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/binary.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/ones_complement.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/twos_complement.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zone_digit.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zonetype_ex2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/unpacked_decimal.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zonetype_ex.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zoned_ex.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zoned2packed.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/packed_decimal.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zoned2packed_ex.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/decimal_ex.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B3%A0%EC%A0%95%EC%86%8C%EC%88%98%EC%A0%90_%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%A4%EC%88%98%ED%91%9C%ED%98%842.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%A4%EC%88%98%ED%91%9C%ED%98%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/BCD%EC%BD%94%EB%93%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/excess-3%EC%BD%94%EB%93%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%A8%EB%A6%AC%ED%8B%B0%EB%B9%84%ED%8A%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%95%B4%EB%B0%8D%EB%B9%84%ED%8A%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A7%81%EB%A0%AC%EC%97%B0%EA%B2%B0%EC%8A%A4%EC%9C%84%EC%B9%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%91%EB%A0%AC%EC%97%B0%EA%B2%B0%EC%8A%A4%EC%9C%84%EC%B9%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%EA%B3%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%ED%95%A9.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%EB%B6%80%EC%A0%95.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B0%B0%ED%83%80%EC%A0%81%EB%85%BC%EB%A6%AC%ED%95%A9.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/harf_adder_%EC%A7%84%EB%A6%AC%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Commutative_Law.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_Law.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Distributive_Law.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84%EB%B2%95%EC%B9%99.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/De_Morgam">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%80%EC%9A%B8%EB%8C%80%EC%88%98%EB%A1%9C%EA%B0%84%EB%9E%B5%ED%99%94.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B4%EB%B3%80%EC%88%98%EC%B9%B4%EB%85%B8%EB%A7%B5.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%82%BC%EB%B3%80%EC%88%98%EC%B9%B4%EB%85%B8%EB%A7%B5.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%82%AC%EB%B3%80%EC%88%98%EC%B9%B4%EB%85%B8%EB%A7%B5.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%B9%B4%EB%85%B8%EB%A7%B5step1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%B9%B4%EB%85%B8%EB%A7%B5step2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8%EB%A1%9C%ED%9A%8C%EB%A1%9C%EA%B5%AC%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/full_adder_%EC%A7%84%EB%A6%AC%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/fulladder.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/multiplexer.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/demultiplexer.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD_%EC%A7%84%EB%A6%AC%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%84%A4%EA%B0%80%EC%A7%80%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/SR%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%A7%84%EB%A6%AC%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/R-S_Latch.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/SR%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/JK%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%A7%84%EB%A6%AC%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/JK%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/DFlipFlop.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/D%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/T%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A1%B0%ED%95%A9%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%83%81%ED%83%9C%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%83%81%ED%83%9C%EB%8F%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Major_components_of_CPU.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0_re.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CU%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/ADD%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98%EC%8B%A4%ED%96%89%EC%98%88.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/컴퓨터구조_files/RegisterR.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/컴퓨터구조_files/가장일반적비트표현.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/컴퓨터구조_files/16비트레지스터의번호표현.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/컴퓨터구조_files/상위비트와하위비트의표현.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EC%A0%84%EC%86%A1_%EA%B8%B0%EB%B3%B8%EA%B8%B0%ED%98%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0_%EC%A7%81%EC%A0%91%EC%97%B0%EA%B2%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0_%EB%B2%84%EC%8A%A4%EC%97%B0%EA%B2%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A1%B0%ED%95%A9%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C_%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%84%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0_%EC%83%81%ED%98%B8_%EC%97%B0%EA%B2%B0_%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%84%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/three-state_buffer.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0_%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0_3-%EC%83%81%ED%83%9C%EB%B2%84%EC%8A%A4%EB%B2%84%ED%8D%BC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/stack2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/queue.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/deque.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/ALU.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%97%B0%EC%82%B0_%EC%82%B0%EC%88%A0%EC%97%B0%EC%82%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%97%B0%EC%82%B0_%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EA%B3%BC_%EC%82%B0%EC%88%A0%EC%8B%9C%ED%94%84%ED%8A%B8%EC%97%B0%EC%82%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC_%EC%97%B0%EC%82%B0_%EC%98%88%EC%8B%9C1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC_%EC%97%B0%EC%82%B0_%EC%98%88%EC%8B%9C2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%9C%ED%94%84%ED%8A%B8%EC%97%B0%EC%82%B0%EC%98%88%EC%8B%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%A2%85%EB%A5%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%AA%85%EB%A0%B9%EC%96%B4%EA%B5%AC%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%AA%85%EB%A0%B9%EC%96%B4%EA%B5%AC%EC%84%B12.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A7%81%EC%A0%91%EB%AA%A8%EB%93%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B0%84%EC%A0%91%EB%AA%A8%EB%93%9C%EC%98%88%EC%8B%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B0%84%EC%A0%91%EB%AA%A8%EB%93%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A3%BC%EC%86%8C%EC%A7%80%EC%A0%95%EB%AA%A8%EB%93%9C%EC%98%88%EC%8B%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B5%AC%EC%84%B1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%B4%88%EB%8B%A8%EC%9C%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/interrupt_cycle_flow_chart.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/interrupt_cycle_flow_chart_%EC%84%A4%EB%AA%85.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%A2%85%EB%A5%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%98%EB%A6%AC%EA%B3%BC%EC%A0%95.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_%EC%9D%B4%EC%A7%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_16%EC%A7%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_%EA%B8%B0%ED%98%B8%EC%97%B0%EC%82%B0%EC%BD%94%EB%93%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B8%EC%96%B4%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%98%EB%A6%AC%EA%B3%BC%EC%A0%952.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/capturing_from_Wi-Fi.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A4%EC%A4%91%EA%B8%B0%EB%8A%A5%EC%9E%A5%EC%B9%98%EC%98%88.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EC%8B%9C%EA%B0%84%EA%B3%B5%EA%B0%84%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EC%B2%98%EB%A6%AC%EC%98%88%EC%A0%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EA%B5%AC%ED%98%84%EC%98%88%EC%A0%9C1_1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EA%B5%AC%ED%98%84%EC%98%88%EC%A0%9C1_2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%84%A4_%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8_%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%91%EB%A0%AC%EC%A0%81%EC%9D%B8%EB%8B%A4%EC%A4%91%EA%B8%B0%EB%8A%A5%EC%9E%A5%EC%B9%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%EC%9D%B4%EC%A7%84%EC%88%98%EC%9E%85%EB%A0%A5.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%82%B0%EC%88%A0%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_flowchart.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98_%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%EB%AA%85%EB%A0%B9%EC%96%B4%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98%EC%98%88_%EB%AA%85%EB%A0%B9%EC%96%B4%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98_%EC%8B%9C%EA%B0%84%EA%B4%80%EA%B3%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%EB%AA%85%EB%A0%B9%EC%96%B4%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98%EC%98%88_%EC%88%9C%EC%84%9C%EB%8F%84.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RISC%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RAM%EC%9D%98_%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98_DDR.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98_DDR.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/SSD.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RAID_level0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RAID_level1_6.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/USB%ED%91%9C%EC%A4%80%EC%A0%84%EC%95%95%EA%B3%BC%EC%A0%84%EB%A5%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_memory%EC%9D%98_%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EA%B5%AC%EC%84%B1%EA%B3%BC_%EB%A9%94%EB%AA%A8%EB%A6%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_memory_Key_register%EC%9D%98%EC%97%AD%ED%95%A0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Locality_of_Reference.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/the_mapping_process_diagram.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A0%84%EC%86%A1%EA%B8%B0%EB%B3%B8%EB%AA%A8%ED%98%95.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Direct_Mapping_ex0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Direct_Mapping_ex.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Direct_Mapping_ex1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_mapping.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Set-asociative_mapping_cache_Ex.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Common_bus_line.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Common_bus_lines.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Common_bus_line_and_IO_bus_line.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/IEEE%ED%91%9C%EC%A4%80_796%EB%8B%A4%EC%A4%91%EB%B2%84%EC%8A%A4%EC%8B%A0%ED%98%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Daisy_chain.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Daisy_chain1.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B2%84%EC%8A%A4%EC%A0%9C%EC%96%B4%EA%B8%B0_%EC%A7%81%EB%A0%AC%EC%A4%91%EC%9E%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B2%84%EC%8A%A4%EC%A0%9C%EC%96%B4%EA%B8%B0_%EB%B3%91%EB%A0%AC%EC%A4%91%EC%9E%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/IEEE%ED%91%9C%EC%A4%80_796%EB%8B%A4%EC%A4%91%EB%B2%84%EC%8A%A4%EC%8B%A0%ED%98%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A4%91%EC%95%99%EC%A0%9C%EC%96%B4%EB%B2%84%EC%8A%A4%EC%8B%9C%EC%8A%A4%ED%85%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%84%EC%82%B0%EC%A0%9C%EC%96%B4%EB%B2%84%EC%8A%A4%EC%8B%9C%EC%8A%A4%ED%85%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8F%99%EA%B8%B0%EB%B2%84%EC%8A%A4%EC%97%90_%EC%9D%98%ED%95%9C_%EC%88%98%ED%96%89.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B9%84%EB%8F%99%EA%B8%B0%EB%B2%84%EC%8A%A4%EC%97%90%EC%9D%98%ED%95%9C%EC%88%98%ED%96%89.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%EC%9D%98%ED%95%9CIO.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%EC%9D%98%ED%95%9CIO.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Daisy_chain_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%91%EB%A0%AC%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EC%9D%B8%EC%BD%94%EB%8D%94%EC%A7%84%EB%A6%AC%ED%91%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%82%AC%EC%9D%B4%ED%81%B4_%E2%80%AAIEN%EC%83%81%ED%83%9C%EA%B0%92.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A8%EC%9D%BC%EA%B3%B5%ED%86%B5%EB%B2%84%EC%8A%A4%EC%8B%9C%EC%8A%A4%ED%85%9C.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B4%EC%A4%91%EB%B2%84%EC%8A%A4%EA%B5%AC%EC%A1%B0.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A4%EC%A4%91%ED%8F%AC%ED%8A%B8%EB%A9%94%EB%AA%A8%EB%A6%AC.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%81%AC%EB%A1%9C%EC%8A%A4%EB%B0%94%EC%8A%A4%EC%9C%84%EC%B9%98.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A4%EB%8B%A8%EA%B5%90%ED%99%98%EB%A7%9D.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Hypercube.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4-%ED%81%90%EB%B8%8C.gif">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4%EC%B0%A8%EC%9B%90%EC%9D%B4%EC%A7%84%ED%81%90%EB%B8%8C2.png">
<meta property="og:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Cashe%EC%9D%98%EC%9D%BC%EA%B4%80%EC%84%B1_Ex2.png">
<meta property="article:published_time" content="2021-04-12T01:12:00.000Z">
<meta property="article:modified_time" content="2021-04-14T05:25:18.716Z">
<meta property="article:author" content="Chaejin Kim">
<meta property="article:tag" content="Computer Science">
<meta property="article:tag" content="Computer Architecture">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chaejin-jen.github.io/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BD%94%EB%93%9C%EC%83%81%ED%83%9C%EB%A8%B8%EC%8B%A0%EA%B5%AC%ED%98%84.png">


<link rel="icon" href="/img/avatar.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="hide-list">
        <div class="semicircle" data-title=" close">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.png"/>
</a>
<div class="author">
    <span>Chaejin Kim</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <i class="iconfont icon-rss"></i>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/chaejin-jen"
               target="_blank">
                
                    <i class="iconfont icon-github"></i>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(18)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="DeepLearning">
                        <i class="fold iconfont icon-right"></i>
                        
                        DeepLearning
                        <small>(5)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="DeepLearning<--->밑바닥 3">
                                        
                                        밑바닥 3
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Algorithm">
                        <i class="fold iconfont icon-right"></i>
                        
                        Algorithm
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Algorithm<--->Basic">
                                        
                                        Basic
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="ComputerScience">
                        <i class="fold iconfont icon-right"></i>
                        
                        ComputerScience
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="ComputerScience<--->Bagic">
                                        
                                        Bagic
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="DataScience">
                        <i class="fold iconfont icon-right"></i>
                        
                        DataScience
                        <small>(5)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="DataScience<--->Math">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Math
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="DataScience<--->MathBagic">
                                                        
                                                        Bagic
                                                        
                                                            <small>(5)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="Unity">
                        
                        Unity
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
</ul>
<div class="right-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="18">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="outline-panel" style="display: none">
            <div class="right-title">Outline</div>
            <i class="iconfont icon-list" data-title="카테고리"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="이전"></i>
            <input id="local-search-input" />
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="대소 문자 구분"></i>
            <i class="iconfont icon-tag" data-title="태그검색"></i>
        </div>
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="검색 "></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="개요보기 "></i>
        </div>        
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Algorithm Complexity</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Big-O</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Computer Architecture</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Computer Science</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Data structure</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>DeepLearning Framework</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Math Basic</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>OS(Operating System)</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>System Programming</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>밑바닥 부터 시작하는 딥러닝 3</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class="All ComputerScience Bagic "
           href="/2021/04/12/ComputerScience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/"
           data-tag="Computer Science,Computer Architecture"
           data-author="" >
            <span class="post-title" title="컴퓨터 구조">컴퓨터 구조</span>
            <span class="post-date" title="2021-04-12 10:12:00">2021/04/12</span>
        </a>
        
        <a  class="All ComputerScience Bagic "
           href="/2021/04/05/ComputerScience/%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"
           data-tag="Computer Science,System Programming"
           data-author="" >
            <span class="post-title" title="시스템 프로그래밍">시스템 프로그래밍</span>
            <span class="post-date" title="2021-04-05 23:12:00">2021/04/05</span>
        </a>
        
        <a  class="All DeepLearning 밑바닥 3 "
           href="/2021/03/27/DeepLearning/Mit3/mitdeep4/"
           data-tag="DeepLearning Framework,밑바닥 부터 시작하는 딥러닝 3"
           data-author="" >
            <span class="post-title" title="밑바닥 딥러닝 3 (4고지)">밑바닥 딥러닝 3 (4고지)</span>
            <span class="post-date" title="2021-03-27 19:23:00">2021/03/27</span>
        </a>
        
        <a  class="All Unity "
           href="/2021/03/25/Unity/unity_bagic/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity 기본">Unity 기본</span>
            <span class="post-date" title="2021-03-25 12:03:00">2021/03/25</span>
        </a>
        
        <a  class="All DeepLearning 밑바닥 3 "
           href="/2021/03/24/DeepLearning/Mit3/mitdeep3/"
           data-tag="DeepLearning Framework,밑바닥 부터 시작하는 딥러닝 3"
           data-author="" >
            <span class="post-title" title="밑바닥 딥러닝 3 (3고지)">밑바닥 딥러닝 3 (3고지)</span>
            <span class="post-date" title="2021-03-24 23:07:00">2021/03/24</span>
        </a>
        
        <a  class="All DeepLearning 밑바닥 3 "
           href="/2021/03/21/DeepLearning/Mit3/mitdeep2/"
           data-tag="DeepLearning Framework,밑바닥 부터 시작하는 딥러닝 3"
           data-author="" >
            <span class="post-title" title="밑바닥 딥러닝 3 (2고지)">밑바닥 딥러닝 3 (2고지)</span>
            <span class="post-date" title="2021-03-21 13:48:00">2021/03/21</span>
        </a>
        
        <a  class="All Unity "
           href="/2021/03/19/Unity/unity_install/"
           data-tag="Unity"
           data-author="" >
            <span class="post-title" title="Unity 설치">Unity 설치</span>
            <span class="post-date" title="2021-03-19 08:53:00">2021/03/19</span>
        </a>
        
        <a  class="All DeepLearning 밑바닥 3 "
           href="/2021/03/18/DeepLearning/Mit3/mitdeep1/"
           data-tag="DeepLearning Framework,밑바닥 부터 시작하는 딥러닝 3"
           data-author="" >
            <span class="post-title" title="밑바닥 딥러닝 3 (1고지)">밑바닥 딥러닝 3 (1고지)</span>
            <span class="post-date" title="2021-03-18 10:22:00">2021/03/18</span>
        </a>
        
        <a  class="All DeepLearning 밑바닥 3 "
           href="/2021/03/15/DeepLearning/Mit3/mitdeep0/"
           data-tag="DeepLearning Framework,밑바닥 부터 시작하는 딥러닝 3"
           data-author="" >
            <span class="post-title" title="밑바닥 딥러닝 3 (개요)">밑바닥 딥러닝 3 (개요)</span>
            <span class="post-date" title="2021-03-15 15:11:00">2021/03/15</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/11/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"
           data-tag="Algorithm"
           data-author="" >
            <span class="post-title" title="기본 핵심 알고리즘 (정렬, 탐색)">기본 핵심 알고리즘 (정렬, 탐색)</span>
            <span class="post-date" title="2021-03-11 22:43:00">2021/03/11</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/10/CodeAlgorithm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%B3%B5%EC%9E%A1%EB%8F%84/"
           data-tag="Algorithm,Algorithm Complexity,Big-O"
           data-author="" >
            <span class="post-title" title="알고리즘 복잡도">알고리즘 복잡도</span>
            <span class="post-date" title="2021-03-10 20:26:00">2021/03/10</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/09/DataScience/Math/Bagic/%EC%84%A0%ED%98%95%EB%8F%85%EB%A6%BD_%EC%84%A0%ED%98%95%EC%A2%85%EC%86%8D_%EB%9E%AD%ED%81%AC/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="선형독립,선형종속,랭크">선형독립,선형종속,랭크</span>
            <span class="post-date" title="2021-03-09 20:35:00">2021/03/09</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/08/DataScience/Math/Bagic/%ED%96%89%EB%A0%AC/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="행렬">행렬</span>
            <span class="post-date" title="2021-03-08 20:38:35">2021/03/08</span>
        </a>
        
        <a  class="All Algorithm Basic "
           href="/2021/03/08/CodeAlgorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"
           data-tag="Data structure,Algorithm"
           data-author="" >
            <span class="post-title" title="자료구조">자료구조</span>
            <span class="post-date" title="2021-03-08 19:24:00">2021/03/08</span>
        </a>
        
        <a  class="All ComputerScience Bagic "
           href="/2021/03/07/ComputerScience/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"
           data-tag="Computer Science,OS(Operating System)"
           data-author="" >
            <span class="post-title" title="운영체제">운영체제</span>
            <span class="post-date" title="2021-03-07 21:18:00">2021/03/07</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/05/DataScience/Math/Bagic/%EB%B2%A1%ED%84%B0/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="벡터">벡터</span>
            <span class="post-date" title="2021-03-05 20:33:00">2021/03/05</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/03/DataScience/Math/Bagic/%EC%88%98%EC%97%B4%EC%A7%91%ED%95%A9%EC%9D%98_%ED%95%A9%EA%B3%BC%EA%B3%B1/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="수열 집합의 합과 곱">수열 집합의 합과 곱</span>
            <span class="post-date" title="2021-03-03 14:29:00">2021/03/03</span>
        </a>
        
        <a  class="All DataScience Math Bagic "
           href="/2021/03/02/DataScience/Math/Bagic/%EC%88%98%ED%95%99%EA%B8%B0%ED%98%B8/"
           data-tag="Math Basic"
           data-author="" >
            <span class="post-title" title="수학 기호">수학 기호</span>
            <span class="post-date" title="2021-03-02 07:25:00">2021/03/02</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-ComputerScience/컴퓨터구조" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">컴퓨터 구조</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="ComputerScience">ComputerScience</a> > 
            
            <a  data-rel="ComputerScience&lt;---&gt;Bagic">Bagic</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">Computer Science</a>
            
            <a class="color2">Computer Architecture</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2021-04-14 14:25:18'>2021-04-12 10:12</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EB%AA%A9%EC%B0%A8"><span class="toc-text">목차</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01-%EC%99%9C-%EB%B0%B0%EC%9A%B8%EA%B9%8C"><span class="toc-text">01. 왜 배울까?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9D%B4%ED%95%B4"><span class="toc-text">컴퓨터의 이해</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A0%95%EB%B3%B4%ED%99%94-%EC%82%AC%ED%9A%8C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4"><span class="toc-text">정보화 사회에 대한 이해</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%84%B1"><span class="toc-text">컴퓨터 하드웨어의 구성</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%ED%91%9C%ED%98%84"><span class="toc-text">데이터의 표현</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%91%9C%ED%98%84-%EB%B0%8F-%EB%8B%A8%EC%9C%84"><span class="toc-text">데이터 표현 및 단위</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EA%B5%AC%EC%A1%B0%EB%A1%9C-%EB%B3%B8-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84%EC%9D%98-%EB%B3%80%ED%99%94"><span class="toc-text">컴퓨터의 구조로 본 패러다임의 변화</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%ED%83%9C%EB%8F%99"><span class="toc-text">컴퓨터의 태동</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%82%AC%EB%AC%B4%ED%99%94-%EC%9E%90%EB%8F%99%EA%B8%B0%EA%B3%84"><span class="toc-text">사무화 자동기계</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%86%B5%EC%8B%A0%EA%B8%B0%EA%B8%B0"><span class="toc-text">통신기기</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%ED%98%84%EC%9E%AC%EC%99%80-%EB%AF%B8%EB%9E%98"><span class="toc-text">컴퓨터의 현재와 미래</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C"><span class="toc-text">02. 컴퓨터 구성요소</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU"><span class="toc-text">CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MPU"><span class="toc-text">MPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%82%AC%EB%AC%BC-%EC%9D%B8%ED%84%B0%EB%84%B7-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-H-W-%ED%94%8C%EB%9E%AB%ED%8F%BC"><span class="toc-text">사물 인터넷 디바이스 H&#x2F;W 플랫폼</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A3%BC%EB%B3%80%EC%9E%A5%EC%B9%98"><span class="toc-text">주변장치</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Unit"><span class="toc-text">Memory Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Auxiliary-Memory-Device"><span class="toc-text">Auxiliary Memory Device</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%99%80-%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%EB%B9%84%EA%B5%90"><span class="toc-text">주기억장치와 보조기억장치 비교</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%99%80-%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B4%80%EA%B3%84"><span class="toc-text">주기억장치와 보조기억장치의 관계</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%B5%9C%EA%B7%BC-%EB%B6%80%EA%B0%81%EB%90%98%EB%8A%94-%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98"><span class="toc-text">최근 부각되는 보조기억장치</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0"><span class="toc-text">참고</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-Device"><span class="toc-text">I&#x2F;O Device</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-%EC%BB%B4%ED%93%A8%ED%84%B0-%ED%86%B5%EC%8B%A0"><span class="toc-text">03. 컴퓨터 통신</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%86%B5%EC%8B%A0%EA%B3%BC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9"><span class="toc-text">통신과 네트워킹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%96%91%EC%9E%90-%EC%BB%B4%ED%93%A8%ED%84%B0"><span class="toc-text">양자 컴퓨터</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%96%91%EC%9E%90-%EB%B3%91%EB%A0%AC%EC%84%B1"><span class="toc-text">양자 병렬성</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B8%80%EB%A1%9C%EB%B2%8C-%EC%9D%B8%ED%84%B0%EB%84%B7"><span class="toc-text">글로벌 인터넷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%A2%85%EB%A5%98"><span class="toc-text">04. 데이터의 종류</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B8%B0%EC%B4%88%EC%A7%80%EC%8B%9D"><span class="toc-text">기초지식</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A7%84%EB%B2%95-number-system"><span class="toc-text">진법(number system)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A7%84%EB%B2%95%EC%9D%98-%EB%B3%80%ED%99%98"><span class="toc-text">진법의 변환</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B3%B4%EC%88%98-Complement"><span class="toc-text">보수(Complement)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B3%B4%EC%88%98%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1"><span class="toc-text">보수의 중요성</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%A4%EC%88%98%ED%91%9C%ED%98%84"><span class="toc-text">실수표현</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EC%88%98-%ED%91%9C%ED%98%84-%EA%B3%A0%EC%A0%95-%EC%86%8C%EC%88%98%EC%A0%90-%EB%B0%A9%EC%8B%9D"><span class="toc-text">정수 표현 : 고정 소수점 방식</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Signeagnitude-MSB%EC%97%90-%EB%B3%B4%EA%B4%80"><span class="toc-text">Signeagnitude MSB에 보관</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%EA%B3%BC-0"><span class="toc-text">+0 과 -0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%EC%A7%84%EC%88%98-%ED%91%9C%ED%98%84-%EB%B0%A9%EC%8B%9D"><span class="toc-text">10진수 표현 방식</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unpacked-decimal"><span class="toc-text">unpacked decimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#packed-decimal"><span class="toc-text">packed decimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%A4%EC%88%98-%ED%91%9C%ED%98%84-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EB%B0%A9%EC%8B%9D"><span class="toc-text">실수 표현 : 부동 소수점 방식</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%94%94%EC%A7%80%ED%84%B8-%EC%BD%94%EB%93%9C"><span class="toc-text">디지털 코드</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BCD-%EC%BD%94%EB%93%9C"><span class="toc-text">BCD 코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#excess-3-%EC%BD%94%EB%93%9C"><span class="toc-text">excess-3 코드</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%97%90%EB%9F%AC-%EA%B2%80%EC%B6%9C-%EC%BD%94%EB%93%9C"><span class="toc-text">에러 검출 코드</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fality-bit"><span class="toc-text">fality bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%95%B4%EB%B0%8D-%EB%B9%84%ED%8A%B8"><span class="toc-text">해밍 비트</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%91%9C%ED%98%84"><span class="toc-text">05. 논리회로와 데이터 표현</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC-%EA%B2%8C%EC%9D%B4%ED%8A%B8-logical-gate"><span class="toc-text">논리 게이트 (logical gate)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8A%A4%EC%9C%84%EC%B9%AD-%EC%9D%B4%EB%A1%A0"><span class="toc-text">스위칭 이론</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC%EA%B3%B1-AND"><span class="toc-text">논리곱 : AND</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC%ED%95%A9-OR"><span class="toc-text">논리합 : OR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC%EB%B6%80%EC%A0%95-NOT"><span class="toc-text">논리부정 : NOT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B0%B0%ED%83%80%EC%A0%81%EB%85%BC%EB%A6%AC%ED%95%A9-XOR"><span class="toc-text">배타적논리합 : XOR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%A4%EB%AC%B4-%EC%A0%81%EC%9A%A9-%EC%82%AC%EB%A1%80"><span class="toc-text">실무 적용 사례</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-%EB%B6%80%EC%9A%B8-%EB%8C%80%EC%88%98%EC%99%80-%EB%85%BC%EB%A6%AC%EC%8B%9D%EC%9D%98-%EA%B0%84%ED%8E%B8%ED%99%94"><span class="toc-text">06. 부울 대수와 논리식의 간편화</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B6%80%EC%9A%B8-%EB%8C%80%EC%88%98-Boolean-Algebra"><span class="toc-text">부울 대수(Boolean Algebra)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B6%80%EC%9A%B8-%EB%8C%80%EC%88%98%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EB%B2%95%EC%B9%99"><span class="toc-text">부울 대수의 기본 법칙</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B5%90%ED%99%98%EB%B2%95%EC%B9%99-Commutative-Law"><span class="toc-text">교환법칙(Commutative Law)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99-Associative-Law"><span class="toc-text">결합법칙(Associative Law)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B6%84%EB%B0%B0%EB%B2%95%EC%B9%99-Distributive-Law"><span class="toc-text">분배법칙(Distributive Law)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84%EC%9D%98-%EB%B2%95%EC%B9%99-De-Morgam%E2%80%99s-theorm"><span class="toc-text">드모르간의 법칙(De Morgam’s theorm)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC%EC%8B%9D%EC%9D%98-%EA%B0%84%ED%8E%B8%ED%99%94"><span class="toc-text">논리식의 간편화</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B6%80%EC%9A%B8-%EB%8C%80%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B0%84%EB%9E%B5%ED%99%94"><span class="toc-text">부울 대수를 이용한 간략화</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Karnaugh-Map"><span class="toc-text">Karnaugh Map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-%EC%A1%B0%ED%95%A9-%EA%B8%B0%EC%96%B5-%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C"><span class="toc-text">07. 조합&#x2F;기억 논리회로</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A1%B0%ED%95%A9%EB%85%BC%EB%A6%AC-%ED%9A%8C%EB%A1%9C"><span class="toc-text">조합논리 회로</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A1%B0%ED%95%A9%ED%9A%8C%EB%A1%9C-%EC%84%A4%EA%B3%84-%EC%A0%88%EC%B0%A8"><span class="toc-text">조합회로 설계 절차</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8C%80%ED%91%9C%EC%A0%81-%EC%A1%B0%ED%95%A9%ED%9A%8C%EB%A1%9C"><span class="toc-text">대표적 조합회로</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Adder"><span class="toc-text">Adder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multiplexer"><span class="toc-text">Multiplexer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Demultiplexer"><span class="toc-text">Demultiplexer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B8%B0%EC%96%B5%ED%9A%8C%EB%A1%9C"><span class="toc-text">기억회로</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A2%85%EB%A5%98%EB%B3%84-%EC%A7%84%EB%A6%AC-%ED%91%9C-%EC%97%AC%EA%B8%B0%ED%91%9C"><span class="toc-text">종류별 진리 표, 여기표</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R-S-%EB%9E%98%EC%B9%98-Latch"><span class="toc-text">R-S 래치(Latch)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JK-%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD"><span class="toc-text">JK 플립플롭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD"><span class="toc-text">D 플립플롭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#T-%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD"><span class="toc-text">T 플립플롭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%88%9C%EC%B0%A8%ED%9A%8C%EB%A1%9C"><span class="toc-text">순차회로</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%88%9C%EC%B0%A8%ED%9A%8C%EB%A1%9C%EC%9D%98-%EC%83%81%ED%83%9C%ED%91%9C%EC%99%80-%EC%83%81%ED%83%9C%EB%8F%84"><span class="toc-text">순차회로의 상태표와 상태도</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%A0%95%EB%A6%AC"><span class="toc-text">정리</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-CPU-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0"><span class="toc-text">08. CPU 내부 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C"><span class="toc-text">CPU 구성요소</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0"><span class="toc-text">CPU 내부 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CU-Control-Unit"><span class="toc-text">CU (Control Unit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IR-ID-Encoder-CAR-CBR-CM-SM-SC"><span class="toc-text">IR, ID, Encoder, CAR, CBR, CM, SM, SC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ALU-Arithmetic-and-Logic-Unit"><span class="toc-text">ALU (Arithmetic and Logic Unit)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Register"><span class="toc-text">Register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bus"><span class="toc-text">Bus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD-%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EC%8B%A4%ED%96%89-%EC%98%88"><span class="toc-text">ADD 명령어의 실행 예</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%AA%85%EB%A0%B9%EC%96%B4-%EA%B5%AC%EC%84%B1%EA%B3%BC-%EC%8B%A4%ED%96%89"><span class="toc-text">명령어 구성과 실행</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%BD%94%EB%93%9C"><span class="toc-text">명령어 코드</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EC%A0%84%EC%86%A1-%EC%96%B8%EC%96%B4"><span class="toc-text">레지스터 전송 언어</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%83%9D%EA%B0%81-%ED%95%B4%EB%B3%BC-%EC%A0%90"><span class="toc-text">생각 해볼 점</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9E%91%EC%84%B1-%EA%B7%9C%EC%B9%99-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EC%A0%84%EC%86%A1"><span class="toc-text">[작성 규칙] 레지스터 전송</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%EB%94%94%EC%9E%90%EC%9D%B8"><span class="toc-text">CPU 디자인</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B3%B5%EC%9A%A9%EC%84%A0%EC%97%90-%EC%9D%98%ED%95%9C-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EC%83%81%ED%98%B8-%EC%97%B0%EA%B2%B0-%EC%98%88-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8A%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9"><span class="toc-text">공용선에 의한 레지스터 상호 연결 예 - 멀티플렉스를 이용</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EC%83%81%ED%83%9C-%EB%B2%84%EC%8A%A4-%EB%B2%84%ED%8D%BC"><span class="toc-text">3 상태 버스 버퍼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8A%A4%ED%83%9D-%ED%81%90-%EB%8D%B0%ED%81%AC"><span class="toc-text">스택, 큐, 데크</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EB%AA%85%EB%A0%B9%EA%B3%BC-ALU"><span class="toc-text">09. 마이크로 명령과 ALU</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%97%B0%EC%82%B0"><span class="toc-text">마이크로 연산</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALU%EC%97%90%EC%84%9C-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%97%B0%EC%82%B0"><span class="toc-text">ALU에서 마이크로 연산</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%B0%EC%82%B0-%EA%B3%BC%EC%A0%95"><span class="toc-text">연산 과정</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0"><span class="toc-text">산술 연산</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0-%EB%B0%8F-%EC%8B%9C%ED%94%84%ED%8A%B8-%EC%97%B0%EC%82%B0"><span class="toc-text">논리 연산 및 시프트 연산</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0-%EC%98%88%EC%8B%9C"><span class="toc-text">논리 연산 예시</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%9C%ED%94%84%ED%8A%B8-%EC%97%B0%EC%82%B0-%EC%98%88%EC%8B%9C"><span class="toc-text">시프트 연산 예시</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EB%AA%85%EB%A0%B9%EC%96%B4"><span class="toc-text">10. 마이크로 명령어</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%AA%85%EB%A0%B9%EC%96%B4-instruction-%EC%A7%91%ED%95%A9"><span class="toc-text">명령어(instruction) 집합</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%AA%85%EB%A0%B9%EC%96%B4-%EA%B5%AC%EB%AC%B8-%ED%98%95%EC%8B%9D"><span class="toc-text">명령어 구문 형식</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%AA%A8%EB%93%9C-Addressing-Mode"><span class="toc-text">주소 지정 모드 (Addressing Mode)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%AA%A8%EB%93%9C-%EC%A2%85%EB%A5%98"><span class="toc-text">주소 지정 모드 종류</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%AA%A8%EB%93%9C-%EC%98%88%EC%8B%9C"><span class="toc-text">주소 지정 모드 예시</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A7%91%ED%95%A9%EC%9D%98-%EC%84%A4%EA%B3%84"><span class="toc-text">명령어 집합의 설계</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%98%84%EC%97%85%EC%97%90%EC%84%9C-%ED%99%9C%EC%9A%A9%EB%90%98%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%B9%84%EC%9C%A8"><span class="toc-text">현업에서 활용되는 명령어 비율</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9E%85%EC%B6%9C%EB%A0%A5-Input-Output-%EA%B5%AC%EC%84%B1"><span class="toc-text">입출력(Input&#x2F;Output) 구성</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-Interrupt"><span class="toc-text">인터럽트(Interrupt)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEN"><span class="toc-text">IEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%9D%90%EB%A6%84%EB%8F%84"><span class="toc-text">인터럽트 사이클 흐름도</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%EA%B8%B0%EB%B3%B8-%EC%BB%B4%ED%93%A8%ED%84%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D"><span class="toc-text">11. 기본 컴퓨터 프로그래밍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%A2%85%EB%A5%98"><span class="toc-text">프로그램 종류</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%98%EB%A6%AC%EA%B3%BC%EC%A0%95"><span class="toc-text">프로그램처리과정</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4"><span class="toc-text">프로그래밍 언어</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B8%B0%EA%B3%84%EC%96%B4"><span class="toc-text">기계어</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4"><span class="toc-text">어셈블리어</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B3%A0%EA%B8%89%EC%96%B8%EC%96%B4-High-level-Language"><span class="toc-text">고급언어(High level Language)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%8B%A4%ED%96%89"><span class="toc-text">프로그래밍 언어의 실행</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EA%B5%AC%ED%98%84-architecture"><span class="toc-text">프로그래밍의 구현 architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%99%98%EA%B2%BD"><span class="toc-text">컴퓨터 네트워크 환경</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Pipeline-%EA%B3%BC-%EB%B2%A1%ED%84%B0%EC%B2%98%EB%A6%AC"><span class="toc-text">12. Pipeline 과 벡터처리</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%B3%91%EB%A0%AC-%EC%B2%98%EB%A6%AC"><span class="toc-text">병렬 처리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B5%AC%EB%B6%84"><span class="toc-text">복잡도에 따른 구분</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8B%A4%EC%A4%91-%EA%B8%B0%EB%8A%A5-%EC%9E%A5%EC%B9%98-%EC%98%88%EC%8B%9C"><span class="toc-text">다중 기능 장치 예시</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-J-Flynn%EC%9D%98-%EB%B6%84%EB%A5%98"><span class="toc-text">M.J Flynn의 분류</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline-%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%84%B1%EB%8A%A5"><span class="toc-text">Pipeline 구조의 성능</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B9%84-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98-%EA%B2%BD%EC%9A%B0"><span class="toc-text">비 파이프라인의 경우</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline-%EA%B5%AC%ED%98%84"><span class="toc-text">Pipeline 구현</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%8C%8C%EC%9D%B4%ED%94%84-%EB%9D%BC%EC%9D%B8-%EA%B5%AC%ED%98%84-%EC%98%88%EC%A0%9C"><span class="toc-text">파이프 라인 구현 예제</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline-%EA%B3%A0%EC%B0%B0"><span class="toc-text">Pipeline 고찰</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-%ED%8C%8C%EC%9D%B4%ED%94%84-%EB%9D%BC%EC%9D%B8"><span class="toc-text">4 세그먼트 파이프 라인</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#S-frac-kt-p-t-p-k"><span class="toc-text">$S&#x3D;\frac{kt_p}{t_p}&#x3D;k$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%98%84%EC%8B%A4%EC%A0%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%A1%B0"><span class="toc-text">현실적 파이프라인 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%95%B4%EA%B2%B0%EB%B2%95-%EB%B3%91%EB%A0%AC%EC%A0%81-%EB%8B%A4%EC%A4%91-%EA%B8%B0%EB%8A%A5%EC%9E%A5%EC%B9%98"><span class="toc-text">해결법 : 병렬적 다중 기능장치</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline-%EC%A2%85%EB%A5%98"><span class="toc-text">Pipeline 종류</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Arithmetic-Pipeline"><span class="toc-text">Arithmetic Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EB%8D%A7%EC%85%88%EA%B3%BC-%EB%BA%84%EC%85%88%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8"><span class="toc-text">부동 소수점 덧셈과 뺄셈을 위한 파이프라인</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%82%B0%EC%88%A0-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98-%ED%9A%A8%EC%9C%A8%EC%84%B1"><span class="toc-text">산술 파이프라인의 효율성</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instruction-Pipeline"><span class="toc-text">Instruction Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%9A%A8%EC%9C%A8%EC%A0%81-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%8B%A4%ED%96%89%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%A1%B0"><span class="toc-text">효율적 명령어 실행을 위한 파이프라인 구조</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline-%EB%B6%84%EA%B8%B0-%EC%98%88%EC%B8%A1"><span class="toc-text">Pipeline 분기 예측</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Instruction-Pipeline-%EC%98%A4%EC%9E%91%EB%8F%99-%EC%9A%94%EC%9D%B8"><span class="toc-text">Instruction Pipeline 오작동 요인</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%98%EC%A1%B4%EC%84%B1-Data-Dependency"><span class="toc-text">데이터 의존성 (Data Dependency)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9D%98%EC%A1%B4%EC%84%B1-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95"><span class="toc-text">데이터 의존성 해결 방법</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B6%84%EA%B8%B0-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%B2%98%EB%A6%AC"><span class="toc-text">분기 명령어 처리</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B6%84%EA%B8%B0-%EC%98%88%EC%B8%A1-branch-prediction"><span class="toc-text">분기 예측(branch prediction)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC-Processor"><span class="toc-text">RISC Processor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8"><span class="toc-text">RISC 파이프라인</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-CPU-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%B4-%EA%B3%A0%EB%A0%A4%ED%95%A0-%EC%82%AC%ED%95%AD"><span class="toc-text">파이프라인 CPU 성능 향상을 위해 고려할 사항</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Memory-System"><span class="toc-text">13. Memory System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5"><span class="toc-text">메모리 계층</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98%EC%9D%98-%EB%B6%84%EB%A5%98"><span class="toc-text">기억장치의 분류</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5"><span class="toc-text">컴퓨터 시스템의 메모리 계층</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Main-Memory-Unit"><span class="toc-text">Main Memory Unit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A2%85%EB%A5%98"><span class="toc-text">종류</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAM%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC"><span class="toc-text">RAM의 동작 원리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDR"><span class="toc-text">DDR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Auxiliary-Memory-Unit"><span class="toc-text">Auxiliary Memory Unit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSD-Solid-State-Drive"><span class="toc-text">SSD(Solid State Drive)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SSD%EC%9D%98-%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90"><span class="toc-text">SSD의 특징 및 장점</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID"><span class="toc-text">RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-Universal-Serial-Bus"><span class="toc-text">USB(Universal Serial Bus)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Associative-Memory-unit"><span class="toc-text">Associative Memory unit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Associative-memory%EC%9D%98-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EA%B5%AC%EC%84%B1%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC"><span class="toc-text">Associative memory의 하드웨어 구성과 메모리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-Memory"><span class="toc-text">Cache Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Locality-of-reference"><span class="toc-text">Locality of reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-memory-%EB%8F%99%EC%9E%91"><span class="toc-text">Cache memory 동작</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-memory-%EC%84%B1%EB%8A%A5"><span class="toc-text">Cache memory 성능</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-memory-%EB%A7%A4%ED%95%91-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4"><span class="toc-text">Cache memory 매핑 프로세스</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-memory-%EB%A7%A4%ED%95%91-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%9E%90%EC%84%B8%ED%9E%88"><span class="toc-text">Cache memory 매핑 프로세스 [자세히]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Direct-mapping"><span class="toc-text">Direct mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%BA%90%EC%8B%9C-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94-%EC%98%88%EC%8B%9C"><span class="toc-text">캐시 상태 변화 예시</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Associative-mapping"><span class="toc-text">Associative mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-asociative-mapping"><span class="toc-text">Set-asociative mapping</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Memory-vs-Cache-Momory"><span class="toc-text">Virtual Memory vs Cache Momory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">메모리 관리 시스템</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1"><span class="toc-text">메모리 관리 하드웨어의 필요성</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0"><span class="toc-text">14. 입출력 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1"><span class="toc-text">시스템 버스의 필요성</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4%EC%9D%98-%EC%A0%9C%EC%96%B4"><span class="toc-text">시스템 버스의 제어</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4%EC%99%80-I-O-%EB%B2%84%EC%8A%A4-%EA%B0%84-%EC%83%81%ED%98%B8-%EC%A4%91%EC%9E%AC-1"><span class="toc-text">시스템 버스와 I&#x2F;O 버스 간 상호 중재 1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IEEE-%ED%91%9C%EC%A4%80-796-%EB%8B%A4%EC%A4%91-%EB%B2%84%EC%8A%A4-%EC%8B%A0%ED%98%B8"><span class="toc-text">IEEE 표준 796 다중 버스 신호</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4%EC%99%80-I-O-%EB%B2%84%EC%8A%A4-%EA%B0%84-%EC%83%81%ED%98%B8-%EC%A4%91%EC%9E%AC-2"><span class="toc-text">시스템 버스와 I&#x2F;O 버스 간 상호 중재 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4%EC%9D%98-%ED%99%9C%EC%9A%A9"><span class="toc-text">시스템 버스의 활용</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A7%81%EB%A0%AC-%EC%A4%91%EC%9E%AC-%EC%A0%88%EC%B0%A8"><span class="toc-text">직렬 중재 절차</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B3%91%EB%A0%AC-%EC%A4%91%EC%9E%AC-%EB%85%BC%EB%A6%AC"><span class="toc-text">병렬 중재 논리</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95"><span class="toc-text">입출력 주소 지정</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%B2%84%EC%8A%A4-%ED%95%A0%EB%8B%B9"><span class="toc-text">입출력 버스 할당</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A4%91%EC%95%99-%EC%A0%9C%EC%96%B4-%EB%B2%84%EC%8A%A4-vs-%EB%B6%84%EC%82%B0-%EC%A0%9C%EC%96%B4-%EB%B2%84%EC%8A%A4"><span class="toc-text">중앙 제어 버스 vs 분산 제어 버스</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%A4%91%EC%95%99-%EC%A0%9C%EC%96%B4-%EB%B2%84%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">중앙 제어 버스 시스템</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%B6%84%EC%82%B0-%EC%A0%9C%EC%96%B4-%EB%B2%84%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="toc-text">분산 제어 버스 시스템</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8F%99%EC%A0%81-%EC%A4%91%EC%9E%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="toc-text">동적 중재 알고리즘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%88%98%ED%96%89%EC%9D%98-%EB%B6%84%EB%A5%98"><span class="toc-text">입출력 수행의 분류</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%8F%99%EA%B8%B0-%EB%B2%84%EC%8A%A4%EC%97%90-%EC%9D%98%ED%95%9C-%EC%88%98%ED%96%89"><span class="toc-text">동기 버스에 의한 수행</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B2%84%EC%8A%A4%EC%97%90-%EC%9D%98%ED%95%9C-%EC%88%98%ED%96%89"><span class="toc-text">비동기 버스에 의한 수행</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interrupt%EC%97%90-%EC%9D%98%ED%95%9C-I-O"><span class="toc-text">Interrupt에 의한 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%9E%A5%EC%B9%98%EC%99%80-CPU%EA%B0%84-%EC%A0%84%EC%86%A1-%EB%AA%A8%EB%93%9C-%EC%B8%A1%EB%A9%B4"><span class="toc-text">입출력 장치와 CPU간 전송 모드 측면</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-%EC%9E%A5%EC%B9%98%EC%99%80-CPU%EA%B0%84-%EC%A0%84%EC%86%A1%EC%97%90-%EB%8C%80%ED%95%9C-S-W-%EC%A0%81-%EA%B3%A0%EC%B0%B0"><span class="toc-text">I&#x2F;O 장치와 CPU간 전송에 대한 S&#x2F;W 적 고찰</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">우선 순위 인터럽트</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%9E%A5%EC%B9%98%EC%99%80-CPU%EA%B0%84-intterupt-%EB%85%BC%EB%A6%AC"><span class="toc-text">입출력 장치와 CPU간 intterupt 논리</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Daisy-chain-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">Daisy chain 우선 순위 인터럽트</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B3%91%EB%A0%AC-%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8"><span class="toc-text">병렬 우선 순위 인터럽트</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%EB%B3%91%EB%A0%AC-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%84%B1%EB%8A%A5-%EB%B6%84%EC%84%9D"><span class="toc-text">15. 병렬 컴퓨터 구조와 성능 분석</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%B3%91%EB%A0%AC-%EC%B2%98%EB%A6%AC"><span class="toc-text">시스템의 병렬 처리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-process-system"><span class="toc-text">Serial process system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-process-system"><span class="toc-text">Parallel process system</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8B%A4%EC%A4%91-%EC%9E%A5%EC%B9%98-amp-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B5%AC%EC%A1%B0"><span class="toc-text">다중 장치 &amp; 파이프라인 구조</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C"><span class="toc-text">멀티프로세서</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%83%81%ED%98%B8-%EC%97%B0%EA%B2%B0-%EA%B5%AC%EC%A1%B0"><span class="toc-text">상호 연결 구조</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%9C%EB%B6%84%ED%95%A0-%EA%B3%B5%ED%86%B5-%EB%B2%84%EC%8A%A4"><span class="toc-text">시분할 공통 버스</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8B%A4%EC%A4%91-%ED%8F%AC%ED%8A%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC"><span class="toc-text">다중 포트 메모리</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EB%8B%A4%EB%8B%A8-%EA%B5%90%ED%99%98%EB%A7%9D"><span class="toc-text">다단 교환망</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%ED%95%98%EC%9D%B4%ED%8D%BC%ED%81%90%EB%B8%8C-%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0"><span class="toc-text">하이퍼큐브 상호연결</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EA%B0%84-%EC%A4%91%EC%9E%AC"><span class="toc-text">프로세서 간 중재</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4-vs-%EB%A1%9C%EC%BB%AC-%EB%B2%84%EC%8A%A4"><span class="toc-text">시스템 버스 vs 로컬 버스</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%B5%EC%9C%A0-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4-%EA%B5%AC%EC%A1%B0"><span class="toc-text">메모리 공유 멀티 프로세서를 위한 시스템 버스 구조</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%A4%91%EC%9E%AC-Algorithm"><span class="toc-text">중재 Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EA%B0%84-%ED%86%B5%EC%8B%A0%EA%B3%BC-%EB%8F%99%EA%B8%B0%ED%99%94"><span class="toc-text">프로세서 간 통신과 동기화</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EA%B0%84-%ED%86%B5%EC%8B%A0"><span class="toc-text">프로세서 간 통신</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EA%B0%84-%EB%8F%99%EA%B8%B0%ED%99%94"><span class="toc-text">프로세서 간 동기화</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9D%BC%EA%B4%80%EC%84%B1"><span class="toc-text">캐시의 일관성</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-%EA%B4%80%EB%A0%A8-%EC%A0%95%EC%B1%85"><span class="toc-text">Cache 관련 정책</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-%EB%B9%84-%EC%9D%BC%EA%B4%80%EC%84%B1"><span class="toc-text">Cache 비 일관성</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-coherence-%ED%95%B4%EA%B2%B0%EC%B1%85"><span class="toc-text">Cache coherence 해결책</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%EA%B3%BC%EC%A0%9C"><span class="toc-text">과제</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>FAST CAMPUS ONLINE 컴퓨터 구조<br>강사 : 이승주</p>
<!-- # 01. 컴퓨터 시스템의 이해 -->

<!-- #### 여집합과 two`s complement (나중에 찾아보기) 
Invert('), NEG (~)  -->

<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><p><code>w/W</code> : <strong>글 목차 확인</strong> 또는 글 목록 보기<br><code>s/S</code> : <strong>디렉토리 숨기기</strong> 또는 열기</p>
<h1 id="01-왜-배울까"><a href="#01-왜-배울까" class="headerlink" title="01. 왜 배울까?"></a>01. 왜 배울까?</h1><ul>
<li><p>현대의 컴퓨터란?</p>
</li>
<li><p>상태 머신(State Machine)과 소프트웨어</p>
<ul>
<li><p>State Machine : 자료 입력받고, 프로세스 처리하고 저장하고 결과내고 등 기본적인 상태</p>
<ul>
<li><p>(인강 그대로 받아 적었는데 무슨말인지 모르겠음. <a target="_blank" rel="noopener" href="https://greatkim91.tistory.com/152">이 블로그 글</a> 참고.)</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BD%94%EB%93%9C%EC%83%81%ED%83%9C%EB%A8%B8%EC%8B%A0%EA%B5%AC%ED%98%84.png" alt="코드를 상태머신으로 구현한 것"></p>
<p>출처 : <a target="_blank" rel="noopener" href="https://greatkim91.tistory.com/152">https://greatkim91.tistory.com/152</a></p>
</li>
</ul>
</li>
<li><p>인터넷 서핑 등 다양한 기능(소프트웨어)을 상태 머신으로 볼 때, 즉, 기기에 얼마나 효율적으로 일을 시킬까와 같은 고민은 컴퓨터 구조와 밀접한 관계를 가짐</p>
</li>
</ul>
</li>
<li><p>우리의 목표! 고성능, 저전력</p>
</li>
<li><p>결론 : 도메인(Domain)의 문제</p>
<ul>
<li>컴퓨터 도메인 지식의 시작은 컴퓨터 구조 부터!</li>
</ul>
</li>
</ul>
<h2 id="컴퓨터의-이해"><a href="#컴퓨터의-이해" class="headerlink" title="컴퓨터의 이해"></a>컴퓨터의 이해</h2><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%84%B1.png"></p>
<h3 id="정보화-사회에-대한-이해"><a href="#정보화-사회에-대한-이해" class="headerlink" title="정보화 사회에 대한 이해"></a>정보화 사회에 대한 이해</h3><ul>
<li>인류사회학적 측면    <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">산업혁명</th>
</tr>
</thead>
<tbody><tr>
<td align="center">18세기</td>
<td align="center">1차 산업혁명</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">2차 산업혁명(전기와 생산라인)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">3차 산업혁명(컴퓨터 통신)</td>
</tr>
<tr>
<td align="center">21세기</td>
<td align="center">4차 산업혁명(IoT, 공장 자동화, AI, Big data, ML/DL)</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>사회 발전적인 측면  </p>
<ol>
<li>  필요한 재화, 서비스의 생산, 소비, 축적이 일정 수준 이상 도달</li>
<li>  주 평균 노동 시간 35시간 이하, 주 2일의 휴무제, 생애 노동시간은 5만 시간 이내</li>
<li>  국민 총 생산고의 30% 이상이 정보산업의 총 생산</li>
<li>  동일 연령층의 30% 이상이 고등 교육을 받은 사람, 전문직$\cdot$기술직$\cdot$관리직이 차지하는 비율이 20% 이상</li>
<li>  Computer, Telephone, Television 보유 대수 고려</li>
</ol>
<ul>
<li><p>산업생산의 패턴의 변화</p>
<ul>
<li>소 품종 대량생산 $\rightarrow$ 다품종 소량생산</li>
<li>획일적, 일방적 $\rightarrow$ 개별적, 선택적 Computopia의 세계   </li>
</ul>
<p>출처 : 다니엘 벨(D, Bell)의 저서 “The meurement of knowledge and Technology”</p>
</li>
</ul>
</li>
</ul>
<h2 id="컴퓨터-하드웨어의-구성"><a href="#컴퓨터-하드웨어의-구성" class="headerlink" title="컴퓨터 하드웨어의 구성"></a>컴퓨터 하드웨어의 구성</h2><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BB%B4%ED%93%A8%ED%84%B0%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EA%B8%B0%EB%B3%B8%EA%B5%AC%EC%84%B1.png"></p>
<h2 id="데이터의-표현"><a href="#데이터의-표현" class="headerlink" title="데이터의 표현"></a>데이터의 표현</h2><ul>
<li>정보(information)<ul>
<li>  어떤 사물에 대한 소식이나 자료</li>
<li>  가공된 데이터</li>
</ul>
</li>
<li>데이터(data)<ul>
<li>  정보를 작성하기 위해 필요한 자료나 정보를 처리하거나 전송할 때 이진(binary)이나 디지털과 같은 좀 더 편리한 형태로 바뀌어진 자료</li>
<li>  정보의 원재료</li>
</ul>
</li>
</ul>
<blockquote>
<p>데이터는 날것이고, 이걸 가공한게 정보(우리의 선택에 도움을 줌)</p>
</blockquote>
<h3 id="데이터-표현-및-단위"><a href="#데이터-표현-및-단위" class="headerlink" title="데이터 표현 및 단위"></a>데이터 표현 및 단위</h3><ul>
<li>  수치 데이터(Numerical data) : 연산용 데이터</li>
<li>  비수치 데이터(Alphanumerical data) : 입출력용 데이터</li>
<li>  특수문자(Special Character) : 입출력/연산용 데이터</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8B%A8%EC%9C%84.png"></p>
<h2 id="컴퓨터의-구조로-본-패러다임의-변화"><a href="#컴퓨터의-구조로-본-패러다임의-변화" class="headerlink" title="컴퓨터의 구조로 본 패러다임의 변화"></a>컴퓨터의 구조로 본 패러다임의 변화</h2><ul>
<li>사무자동화 기계 $\rightarrow$ 통신기기 (네트워크 단말)<ul>
<li>유비쿼터스(Ubiquitous) 시대</li>
<li>Mobile &amp; Wireless 전성 시대</li>
<li>IoT</li>
<li>AI (ML/DL) ..</li>
</ul>
</li>
</ul>
<h3 id="컴퓨터의-태동"><a href="#컴퓨터의-태동" class="headerlink" title="컴퓨터의 태동"></a>컴퓨터의 태동</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B3%84%EC%82%B0%EA%B8%B0%EC%97%90%EC%84%9C%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B9%8C%EC%A7%80.png"></p>
<ul>
<li>ENIAC : 폰 노이만식 기계 (데이터+프로그래밍 시스템 함께 들어감 = auto 느낌 물씬)</li>
</ul>
<h3 id="사무화-자동기계"><a href="#사무화-자동기계" class="headerlink" title="사무화 자동기계"></a>사무화 자동기계</h3><p>사무 자동화 기기 정보처리 유형에 따른 분류</p>
<ul>
<li>자료 준비기기<ul>
<li>워드 프로세서, 복사기, 프린터</li>
</ul>
</li>
<li>자료 처리기기<ul>
<li>워드 프로세서, 개인용 컴퓨터</li>
</ul>
</li>
<li>자료 전송기기<ul>
<li>팩스, 이메일, 원격 회의 시스템</li>
</ul>
</li>
<li>자료 저장기기<ul>
<li>마이크로 필름, COM $\rightarrow$ CAR, 광디스크 $\rightarrow$ 하드디스크</li>
</ul>
</li>
</ul>
<h3 id="통신기기"><a href="#통신기기" class="headerlink" title="통신기기"></a>통신기기</h3><p>네트워크 단말로, 공식 통신기기로 인식</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%86%B5%EC%8B%A0%EA%B8%B0%EA%B8%B0.png"></p>
<ul>
<li>access net : U+, KT</li>
<li>ISP A, B, C : 전 세계 12개 (구글이나 아마존은 자체적으로 요정도 급)</li>
<li>IXP : 틈새 시장 공략자들</li>
<li>regional net : (굳이 없어도 되지만..) 원활한 서비스를 위함 </li>
</ul>
<h3 id="컴퓨터의-현재와-미래"><a href="#컴퓨터의-현재와-미래" class="headerlink" title="컴퓨터의 현재와 미래"></a>컴퓨터의 현재와 미래</h3><ul>
<li><p>유비쿼터스<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9C%A0%EB%B9%84%EC%BF%BC%ED%84%B0%EC%8A%A4.png"></p>
<ul>
<li>유비쿼터스랑 컴퓨터 구조가 뭔 상관이냐면<ul>
<li>병렬 프로세싱, CPU 여러개(옥타코어 등) 사용</li>
</ul>
</li>
</ul>
</li>
<li><p>Mobile &amp; Wireless 전성 시대</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Mobile%EA%B3%BCWireless.png"></p>
<pre><code>headend or central office : 전화국, 기지국 
cable or DSL modem : 여기에 이젠 54 Mbps 무선 연결함 
</code></pre>
  <details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > 교양 </summary>
  <div>  
    - 피처폰과 스마트폰의 차이점
    - 유선 사업자와 스마트폰 사업자의 위상 변화
    - 컴퓨터 구성 요소(병렬 프로세싱)의 변화
    - 세대별 진화의 정도        
  </div>
  </details>

</li>
<li><p>IoT(Internet of Thing)<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/IoT.png"></p>
</li>
<li><p>AI<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/AI.png"></p>
</li>
<li><p>2021년 기준 4차 산업혁명:</p>
<p>  로봇 공학, 인공 지능, 나노 기술, 양자 프로그래밍, 생명 공학, IoT, 3D 인쇄 및 자율주행 차량</p>
</li>
</ul>
<h1 id="02-컴퓨터-구성요소"><a href="#02-컴퓨터-구성요소" class="headerlink" title="02. 컴퓨터 구성요소"></a>02. 컴퓨터 구성요소</h1><p>컴퓨터 구성요소의 기능을 살펴보고 이해해보자.</p>
<ul>
<li><p>인지와 기능의 조합 : CPU와 주변장치</p>
<ul>
<li><p>CPU (Central Processing Unit)</p>
<ul>
<li>CPU/MPU</li>
<li>사물 인터넷 디바이스 H/W 플랫폼</li>
</ul>
</li>
<li><p>주변장치(Peripheral Device)</p>
<ul>
<li>기억장치 (Memory unit)</li>
<li>보조기억장치(Auxiliary memory device)</li>
<li>입출력장치(Input/Output device)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>중앙처리장치(Central Processing Unit, CPU)</p>
<ul>
<li>위치 : 마더 보드<ul>
<li>마더보드 : 데이터의 전달 통로가 디자인 되어있는 메인 보드<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/mother_board.png"></li>
</ul>
</li>
<li>역할 : 실행 프로그램의 명령을 해석하여 실행, 장치 제어</li>
<li>구성 : ALU, CU, 각종 레지스터<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU.png"></li>
</ul>
<h3 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h3><p>MPU(Micro Processor Unit)</p>
<ul>
<li>CPU를 LSI(고밀도 집적회로)화 한 일종의 통합장치</li>
<li>분류 (2가지)<ul>
<li>CISC (Complex Instruction Set Computer)<ul>
<li>  반복적이고 동일한 명령을 하드웨어 처리로 함</li>
</ul>
</li>
<li>RISC (Reduced Instruction Set Computer)<ul>
<li>  CISC 반대 개념</li>
</ul>
</li>
</ul>
</li>
<li>Bit Slice MPU 등 존재</li>
</ul>
<h3 id="사물-인터넷-디바이스-H-W-플랫폼"><a href="#사물-인터넷-디바이스-H-W-플랫폼" class="headerlink" title="사물 인터넷 디바이스 H/W 플랫폼"></a>사물 인터넷 디바이스 H/W 플랫폼</h3><p>대표적 오픈소스 H/W 플랫폼</p>
<ul>
<li>Arduino<ul>
<li>2005년, 이탈리아</li>
</ul>
</li>
<li>Atmel사 마이크로 컨트롤러 보드<ul>
<li>AVR</li>
<li>Coretex-M3</li>
</ul>
</li>
<li>Raspberry Pi</li>
<li>Galileo</li>
<li>Edison</li>
</ul>
<h2 id="주변장치"><a href="#주변장치" class="headerlink" title="주변장치"></a>주변장치</h2><h3 id="Memory-Unit"><a href="#Memory-Unit" class="headerlink" title="Memory Unit"></a>Memory Unit</h3><p>주기억장치<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/memory_unit.png"></p>
<ul>
<li>RAM(Random Access Memory)<ul>
<li>DRAM(Dynamic RAM)</li>
<li>SRAM(Static RAM)</li>
</ul>
</li>
<li>ROM(Read Only Memory)</li>
</ul>
<h3 id="Auxiliary-Memory-Device"><a href="#Auxiliary-Memory-Device" class="headerlink" title="Auxiliary Memory Device"></a>Auxiliary Memory Device</h3><p>보조기억장치</p>
<ul>
<li>종류 : 하드디스크, 플래시메모리 등</li>
<li>동작 속도 : 느림, 가격 : 저렴 $\rightarrow$ 다량의 데이터를 저장</li>
</ul>
<h4 id="주기억장치와-보조기억장치-비교"><a href="#주기억장치와-보조기억장치-비교" class="headerlink" title="주기억장치와 보조기억장치 비교"></a>주기억장치와 보조기억장치 비교</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Memory_unit_and_Auxiliary_memory_device.png"></p>
<h4 id="주기억장치와-보조기억장치의-관계"><a href="#주기억장치와-보조기억장치의-관계" class="headerlink" title="주기억장치와 보조기억장치의 관계"></a>주기억장치와 보조기억장치의 관계</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Memory_unit_and_Auxiliary_memory_device2.png"></p>
<h4 id="최근-부각되는-보조기억장치"><a href="#최근-부각되는-보조기억장치" class="headerlink" title="최근 부각되는 보조기억장치"></a>최근 부각되는 보조기억장치</h4><ul>
<li>플래시 기억장치 - EEPROM 의 한 종류(RAM과 ROM의 중간 위치)<ul>
<li>  CF(Compact Flash) Memory</li>
<li>  SSD(Solid State Drive)</li>
</ul>
</li>
<li>  USB 기억장치</li>
<li>  SD card(Secure Digital Card)</li>
<li>  Memory Stick</li>
</ul>
<h5 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h5><ul>
<li>디스크 성능과 파라미터<ol>
<li>헤드를 해당 트랙으로 이동 : 탐색 시간</li>
<li>데이터가 포함된 섹터가 회전되어 헤드 아래로 올 때까지 대기 : 회전 지연</li>
<li>데이터 전송 : 데이터 전송 시간</li>
</ol>
</li>
</ul>
<blockquote>
<p>디스크 접근 시간 = 탐색시간 + 회전 지연 + 데이터 전송 시간</p>
</blockquote>
<h3 id="I-O-Device"><a href="#I-O-Device" class="headerlink" title="I/O Device"></a>I/O Device</h3><ul>
<li>  키보드(Key board)</li>
<li>  마우스(Mouse)</li>
<li>  스캐너(Scanner)</li>
<li>  터치스크린, 조이스틱, 광학 마스크 판독기(OMR)</li>
<li>  바코드 판독기(Barcode reader)</li>
</ul>
<h1 id="03-컴퓨터-통신"><a href="#03-컴퓨터-통신" class="headerlink" title="03. 컴퓨터 통신"></a>03. 컴퓨터 통신</h1><ul>
<li>비즈니스 환경에서의 통신과 네트워킹의 역할</li>
<li>양자 컴퓨터</li>
<li>웹의 진화 - 글로벌 인터넷</li>
</ul>
<h2 id="통신과-네트워킹"><a href="#통신과-네트워킹" class="headerlink" title="통신과 네트워킹"></a>통신과 네트워킹</h2><ul>
<li><p>정보통신기술의 발전 $\rightarrow$ 컴퓨터 구조의 변화, 시장 구도 변화<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/NOS%EC%9D%98%EC%97%AD%ED%95%A0%ED%99%95%EB%8C%80.png" alt="Network Operating System"></p>
<ul>
<li><p>NOS 에서 N : network, new technology, next generation 등 다 맞는 말</p>
</li>
<li><p>네트워크 장비는 4차 산업혁명을 실현하기 위한 핵심인프라</p>
</li>
<li><p>유/무선, 통신/방송, 컴퓨터의 융합이 가능할 것</p>
</li>
</ul>
</li>
<li><p>5G네트워크</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/5G%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC.png"></p>
</li>
</ul>
<h2 id="양자-컴퓨터"><a href="#양자-컴퓨터" class="headerlink" title="양자 컴퓨터"></a>양자 컴퓨터</h2><ul>
<li>양자 컴퓨터는 중첩(superposition), 얽힘(entanglement) 등 양자 고유 물리적 특성을 이용하여, 다수의 정보를 <strong>동시 처리</strong>할 수 있는 새로운 개념의 컴퓨터<ul>
<li>정보처리의 기본 단위 : 양자비트 또는 큐비트(qubit) (양자적 정보 단위)</li>
</ul>
</li>
<li>현대 반도체 칩의 미세회로에서 발생하는 누설전류로 인한 고전컴퓨터 성능 한계 돌파를 위한 대안으로 양자컴퓨터 필요성이 대두</li>
<li>양자 병렬처리를 통해 정보처리 및 연산 속도가 지수 함수적으로 증가하여 빠른 속도로 문제 해결이 가능</li>
</ul>
<h3 id="양자-병렬성"><a href="#양자-병렬성" class="headerlink" title="양자 병렬성"></a>양자 병렬성</h3><p>Quantum parallelism : 단 한번의 모든 숫자의 연산을 수행할 수 있는 성질<br>    <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%96%91%EC%9E%90%EB%B3%91%EB%A0%AC%EC%84%B1.png"></p>
<h2 id="글로벌-인터넷"><a href="#글로벌-인터넷" class="headerlink" title="글로벌 인터넷"></a>글로벌 인터넷</h2><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9B%B9%EC%9D%98%EB%AF%B8%EB%9E%98.png"></p>
<table>
<thead>
<tr>
<th align="center">연도</th>
<th align="center">웹</th>
<th align="center">기능</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1990-2000</td>
<td align="center">Web 1.0</td>
<td align="center">디렉토리 검색</td>
</tr>
<tr>
<td align="center">2000-2010</td>
<td align="center">Web 2.0 - Social Web</td>
<td align="center">개방, 참여정신의 쌍방향</td>
</tr>
<tr>
<td align="center">2005-2020</td>
<td align="center">Web3.0 - Semantic Web</td>
<td align="center">개인 맞춤형, 지능형 웹</td>
</tr>
<tr>
<td align="center">2015-2030</td>
<td align="center">Web 4.0 - Ubiquitous Web</td>
<td align="center">초연결(현실과 가상의 연결), 지능화 웹</td>
</tr>
</tbody></table>
<h1 id="04-데이터의-종류"><a href="#04-데이터의-종류" class="headerlink" title="04. 데이터의 종류"></a>04. 데이터의 종류</h1><p>데이터 종류</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9E%90%EB%A3%8C%EC%9D%98%ED%91%9C%ED%98%84.png"></p>
<p>출처 : <a target="_blank" rel="noopener" href="https://0verc10ck.tistory.com/3">https://0verc10ck.tistory.com/3</a>  </p>
<p>데이터 단위</p>
<!-- ![](/media/컴퓨터구조_files/byte_bit_nibble.png) -->
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8B%A8%EC%9C%840.png"><br>출처 : <a target="_blank" rel="noopener" href="https://0verc10ck.tistory.com/3">https://0verc10ck.tistory.com/3</a></p>
<!-- - 1byte = 8bit =2nibble -->
<ul>
<li>1byte = 1문자(character), 한글은 2byte 필요</li>
<li>1 워드 : 특정 CPU에서 취급하는 명령어나 데이터의 길이에 해당하는 비트 수<ul>
<li>워드 길이는 8, 16, 32, 64 비트 등 8의 배수</li>
</ul>
</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8B%A8%EC%9C%842.png"></p>
<h2 id="기초지식"><a href="#기초지식" class="headerlink" title="기초지식"></a>기초지식</h2><h3 id="진법-number-system"><a href="#진법-number-system" class="headerlink" title="진법(number system)"></a>진법(number system)</h3><ul>
<li><p>2진법 : 0과 1 두가지 기호로 표현하는 수의 체계</p>
</li>
<li><p>8진법 : 0,1,2,… ,7 의 8가지 기호로 표현하는 수의 체계</p>
</li>
<li><p>8진법 : 0,1,… ,8,9 의 10가지 기호로 표현하는 수의 체계</p>
</li>
<li><p>16진법 : 0,1,… ,9,A,B,C,D,E,F 의 16가지 기호로 표현하는 수의 체계</p>
</li>
<li><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/number_system.png"></p>
<ul>
<li>컴퓨터는 on/off로 표기할 수 있는 2진법 체계를 택함</li>
<li>너무 길어지니까 8진수, 16진수로 표현<ul>
<li>2진수를 4자리씩 짤라서 표현하면 16진수임</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="진법의-변환"><a href="#진법의-변환" class="headerlink" title="진법의 변환"></a>진법의 변환</h3><ul>
<li><p>10진법의 수 $\rightarrow$ 2진법의 수<br> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/10%EC%A7%84%EC%88%982%EC%A7%84%EC%88%98%EB%B3%80%ED%99%98.png"></p>
</li>
<li><p>2진법의 수 $\rightarrow$ 10진법의 수<br> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/2%EC%A7%84%EC%88%9810%EC%A7%84%EC%88%98%EB%B3%80%ED%99%98.png"> </p>
</li>
<li><p>8/16진수 $\rightarrow$ 2진법의 수<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/8_16%EC%A7%84%EC%88%982%EC%A7%84%EC%88%98%EB%B3%80%ED%99%98.png"> </p>
</li>
</ul>
<h3 id="보수-Complement"><a href="#보수-Complement" class="headerlink" title="보수(Complement)"></a>보수(Complement)</h3><ul>
<li><p>one’s complement : 최대값(해당 bit의 가장 큰 표현형)을 형성하는데 서로 보완 관계에 있는 두 수 사이의 관계</p>
</li>
<li><p>two’s complement : MODULUS(최대표현자리수)를 형성하는데 서로 보완관계에 있는 두 수 사이의 관계</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/2sComplement1.png"></p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/2sComplement2.png"> </p>
</li>
</ul>
<pre><code>출처 : http://programmingansic.blogspot.com/2014/11/1s-and-2s-complement.html     

![](/media/컴퓨터구조_files/2sComplement_ex.png) 

출처 : https://medium.com/@934/how-integers-are-stored-in-memory-using-twos-complement-3e9f6320fa63
</code></pre>
<!-- #### 여집합과 two`s complement (나중에 찾아보기)   -->

<!-- #### 예시
- 10진수에서의 보수
    - 1의 보수 : A+B=9, A+B=99
    - 2의 보수 : A+B=10, A+B=100

- 2진수  
    - 1의 보수 : A+B=1, A+B=11  
    > 자신의 수를 반대(1↔0)로 바꿈
    - 2의 보수 : A+B=10, A+B=100
    > 2의 보수는 1의 보수에 +1  
    > 또는  
    > 최초의 유효 BIT 까지 그대로 두고, 나머지를 모두 반대(1↔0)로 바꿈       -->

<h4 id="보수의-중요성"><a href="#보수의-중요성" class="headerlink" title="보수의 중요성"></a>보수의 중요성</h4><blockquote>
<p>계산을 편하게 하기위해 고안된게 보수 개념</p>
</blockquote>
<ol>
<li><p>양/음수로 활용<br> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%B4%EC%88%98%EC%9D%98%EC%A4%91%EC%9A%94%EC%84%B1.png" alt="4bit로 표현 가능한 수"> </p>
</li>
<li><p>연산에 활용</p>
<ul>
<li><p>뺄셈의 연산을 덧셈으로 처리 가능</p>
<p>예시 : $-95 + 256$<br>   $= 255 -95 + 1$<br>   $=160+1$<br>   $=161$</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/addition_with_complement.png"> </p>
</li>
</ul>
</li>
</ol>
<!-- ![10진연산과 2진연산 비교](/media/컴퓨터구조_files/보수의중요성2.png) -->

<!-- 계산 예시 -->

<h2 id="실수표현"><a href="#실수표현" class="headerlink" title="실수표현"></a>실수표현</h2><ul>
<li><p>소수점 아래의 값들을 2씩 곱하여 나오는 몫을 차용하여 표기<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%A4%EC%88%98%EC%9D%98%EB%B3%80%ED%99%98.png"> </p>
<ul>
<li>헷갈리니까 하나 더<ul>
<li>0.25는 0.01<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%EC%88%AB%EC%A0%90%EC%95%84%EB%9E%98%EA%B0%92%ED%91%9C%ED%98%84.png"> </li>
<li>0.3 처럼 순환 반복되는 애는, 유효한 부분까지만 표현<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%EC%88%98%EC%A0%90%ED%91%9C%ED%98%84_%EC%88%9C%ED%99%98%EB%B0%98%EB%B3%B5.png"> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="정수-표현-고정-소수점-방식"><a href="#정수-표현-고정-소수점-방식" class="headerlink" title="정수 표현 : 고정 소수점 방식"></a>정수 표현 : 고정 소수점 방식</h2><p>정수형 : 고정 소숫점, Fixed point number</p>
<h3 id="Signeagnitude-MSB에-보관"><a href="#Signeagnitude-MSB에-보관" class="headerlink" title="Signeagnitude MSB에 보관"></a>Signeagnitude MSB에 보관</h3><ul>
<li><p>정수의 부호화 절대치(Signeagnitude)를 따로 보관</p>
<ul>
<li><p>MSB가 부호가 됨</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A0%95%EC%88%98%ED%91%9C%ED%98%84.png"></p>
<ul>
<li>표현 범위 (n bit 사용): $-(2^{n-1}-1)~+(2^{n-1}-1)$</li>
<li>+0 과 -0이 공존한다는 문제점!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="0-과-0"><a href="#0-과-0" class="headerlink" title="+0 과 -0"></a>+0 과 -0</h3><p>보수를 취해서 문제를 해결!</p>
<ul>
<li>R의 보수 R-1의 보수가 존재</li>
<li>양수의 표현은 절대값 표현 방식과 동일</li>
<li>표현 범위(n bit 사용)<ul>
<li>1의 보수 :  $-(2^{n-1}-1)\leq N \leq +(2^{n-1}-1)$</li>
<li><strong>2의 보수 :  $-2^{n-1}\leq N \leq +(2^{n-1}-1)$</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Binary</th>
<th align="center">One`s compliment</th>
<th align="center">Two`s complement</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/binary.png"></td>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/ones_complement.png"></td>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/twos_complement.png"></td>
</tr>
</tbody></table>
<!-- 출처: http://pages.cpsc.ucalgary.ca/~tamj/2007/231P/notes/acrobat/number_representations.pdf -->

<!-- ![](/media/컴퓨터구조_files/정수형2의보수표현범위.png)

[참고 블로그](http://blog.naver.com/PostView.nhn?blogId=paydma&logNo=50176084087) -->

<blockquote>
<p>2의 보수를 취해주면, 0의 보수 즉, 1111에 1을 더해주기 때문에 날라감.<br>즉, +0,-0 모순해결!</p>
</blockquote>
<h2 id="10진수-표현-방식"><a href="#10진수-표현-방식" class="headerlink" title="10진수 표현 방식"></a>10진수 표현 방식</h2><p>입력출력용은 굳이 연산이 가능하도록 이진수화(2로 나눠가면서 수치데이터로 바꿀)할 필요없음.</p>
<blockquote>
<p>즉, 입출력시 효율적인, Zoned Decimal (10진수형 정수 표현) 사용 </p>
</blockquote>
<!-- 비수치데이터로 -->

<h3 id="unpacked-decimal"><a href="#unpacked-decimal" class="headerlink" title="unpacked decimal"></a>unpacked decimal</h3><ul>
<li><p>연산에는 이용 불가/ 입출력</p>
</li>
<li><p>zoned decimal 이라하며 EBCDIC 의 숫자 표현과 동일</p>
<ul>
<li>EBCDIC : 다른데서 설명할꺼임</li>
</ul>
</li>
<li><p>한자리당 1byte 공간이 필요<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zone_digit.png"></p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zonetype_ex2.png"></p>
<!-- ![](/media/컴퓨터구조_files/zonetype.png) -->
</li>
<li><p>마지막 byte만 sign을 포함<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/unpacked_decimal.png"></p>
</li>
<li><p>예시</p>
<ul>
<li><p>+231, -231</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zonetype_ex.png"></p>
</li>
<li><p>345, +345, -345  </p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zoned_ex.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="packed-decimal"><a href="#packed-decimal" class="headerlink" title="packed decimal"></a>packed decimal</h3><ul>
<li><p>연산에 이용되고 입출력이 불가  </p>
</li>
<li><p>1byte에 2자리의 10진수를 표현<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zoned2packed.png"></p>
</li>
<li><p>마지막 4개의 비트로 부호를 표현<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/packed_decimal.png"></p>
</li>
<li><p>예시</p>
<ul>
<li>zoned decimal to packed decimal<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/zoned2packed_ex.png"></li>
<li>packed to zoned type<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/decimal_ex.png"></li>
</ul>
<h3 id="실수-표현-부동-소수점-방식"><a href="#실수-표현-부동-소수점-방식" class="headerlink" title="실수 표현 : 부동 소수점 방식"></a>실수 표현 : 부동 소수점 방식</h3></li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B3%A0%EC%A0%95%EC%86%8C%EC%88%98%EC%A0%90_%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90.png"></p>
<p>출처 : <a target="_blank" rel="noopener" href="https://yoostudy.tistory.com/entry/1%EC%9E%90%EB%A3%8C%ED%98%95%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%EA%B3%BC-%EA%B3%A0%EC%A0%95%EC%86%8C%EC%88%98%EC%A0%90">https://yoostudy.tistory.com/entry/1%EC%9E%90%EB%A3%8C%ED%98%95%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%EA%B3%BC-%EA%B3%A0%EC%A0%95%EC%86%8C%EC%88%98%EC%A0%90</a></p>
<!-- 가장 간단히는 부호, 정수부, 소수부를 나눠서 표현 가능

그러나, 실용성이 떨어짐 -->

<p>: 지수(e)와 기수(m)를 사용하여 소수점의 위치를 이동시켜 표기할 수 있는 표현한다.</p>
<p>(표현의 범위가 정수에 비해 훨씬 넓음)</p>
<table>
<thead>
<tr>
<th align="center">타입</th>
<th align="center">크기<br/>(비트)</th>
<th align="center">범위</th>
<th align="center">유효 자리수<br/>(십진수)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center">$3.4<em>10^{-38} ~ 3.4</em>10^{38}$</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td align="center">$1.7<em>10^{-308}~1.7</em>10^{308}$</td>
<td align="center">15</td>
</tr>
</tbody></table>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%A4%EC%88%98%ED%91%9C%ED%98%842.png"></p>
<p>1bit는 부호, 8bit는 지수, 다음 23bit는 기수를 표현</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%A4%EC%88%98%ED%91%9C%ED%98%84.png"></p>
<!-- - 예시
    0.9x10^5
    
    ![](https://media.vlpt.us/images/underlier12/post/7e9a93c5-3405-4191-9ff4-946ba9c4abed/image.png) -->

<p>양의 부호를 가지며 10진수로 5의 지수를 가지고 0.9의 기수를 가지기 때문에 0.9x10^5의 값을 표현한 것이다.</p>
<h2 id="디지털-코드"><a href="#디지털-코드" class="headerlink" title="디지털 코드"></a>디지털 코드</h2><h3 id="BCD-코드"><a href="#BCD-코드" class="headerlink" title="BCD 코드"></a>BCD 코드</h3><p>Binary Coded Decimal code : 2진화 10진 코드, 8421 코드</p>
<p>packed decimal 표기시 BCD code를 사용함</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/BCD%EC%BD%94%EB%93%9C.png"></p>
<h3 id="excess-3-코드"><a href="#excess-3-코드" class="headerlink" title="excess-3 코드"></a>excess-3 코드</h3><p>sleep 모드를 만들어 주도록 보완한 코드체계</p>
<p>3을 더해서 자체적으로 보수 체계를 갖도록 만듦</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/excess-3%EC%BD%94%EB%93%9C.png"></p>
<h2 id="에러-검출-코드"><a href="#에러-검출-코드" class="headerlink" title="에러 검출 코드"></a>에러 검출 코드</h2><h3 id="fality-bit"><a href="#fality-bit" class="headerlink" title="fality bit"></a>fality bit</h3><p>데이터의 진위여부를 검사</p>
<ul>
<li>짝수 패리티<ul>
<li>총 1의 개수를 짝수로 맞춤<ul>
<li>해당 데이터의 1의 개수가 짝수이면 최상단에 0, 홀수이면 1을 삽입</li>
</ul>
</li>
</ul>
</li>
<li>홀수 패리티<ul>
<li><p>총 1의 개수를 홀수로 맞춤</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%A8%EB%A6%AC%ED%8B%B0%EB%B9%84%ED%8A%B8.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="해밍-비트"><a href="#해밍-비트" class="headerlink" title="해밍 비트"></a>해밍 비트</h3><p>8비트 데이터의 에러 정정 코드</p>
<p>어느 부분에 어디가 있나 확인</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%95%B4%EB%B0%8D%EB%B9%84%ED%8A%B8.png"></p>
<h1 id="05-논리회로와-데이터-표현"><a href="#05-논리회로와-데이터-표현" class="headerlink" title="05. 논리회로와 데이터 표현"></a>05. 논리회로와 데이터 표현</h1><hr>
<h2 id="논리-게이트-logical-gate"><a href="#논리-게이트-logical-gate" class="headerlink" title="논리 게이트 (logical gate)"></a>논리 게이트 (logical gate)</h2><ul>
<li>논리 연산을 수행하는 전자 소자(하드웨어)</li>
<li>주어진 입력 변수 값에 대해 정해진 논리 함수를 수행하여 그 함수의 연산 결과와 동일한 값을 출력</li>
</ul>
<h3 id="스위칭-이론"><a href="#스위칭-이론" class="headerlink" title="스위칭 이론"></a>스위칭 이론</h3><ul>
<li><p>1983년 미국의 C.E. Shannon 가 만든 논리 연산의 실행을 가능하도록 구성된 이론</p>
</li>
<li><p>스위치(파워on/off)로 이진 정보 표현</p>
<ul>
<li>스위치가 연결된 상태 : 1(X) $\rightarrow$ <code>______</code></li>
<li>스위치가 연결되지 않은 상태 : 0(X’) $\rightarrow$ <code>__/__</code></li>
</ul>
</li>
<li><p>스위치이론에 논리적 구현 기능 추가</p>
<ul>
<li><p>AND 논리 : 직렬 연결 스위치와 동치</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A7%81%EB%A0%AC%EC%97%B0%EA%B2%B0%EC%8A%A4%EC%9C%84%EC%B9%98.png"></p>
</li>
<li><p>OR 논리 : 병렬 연결 스위치와 동치</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%91%EB%A0%AC%EC%97%B0%EA%B2%B0%EC%8A%A4%EC%9C%84%EC%B9%98.png"></p>
<h4 id="논리곱-AND"><a href="#논리곱-AND" class="headerlink" title="논리곱 : AND"></a>논리곱 : AND</h4></li>
</ul>
</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%EA%B3%B1.png"></p>
<h4 id="논리합-OR"><a href="#논리합-OR" class="headerlink" title="논리합 : OR"></a>논리합 : OR</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%ED%95%A9.png"></p>
<h4 id="논리부정-NOT"><a href="#논리부정-NOT" class="headerlink" title="논리부정 : NOT"></a>논리부정 : NOT</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%EB%B6%80%EC%A0%95.png"></p>
<h4 id="배타적논리합-XOR"><a href="#배타적논리합-XOR" class="headerlink" title="배타적논리합 : XOR"></a>배타적논리합 : XOR</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B0%B0%ED%83%80%EC%A0%81%EB%85%BC%EB%A6%AC%ED%95%A9.png"></p>
<h2 id="실무-적용-사례"><a href="#실무-적용-사례" class="headerlink" title="실무 적용 사례"></a>실무 적용 사례</h2><ul>
<li><p>예제 : 1 bit 덧셈을 구현</p>
</li>
<li><p>해석 : 논리 회로를 이용한 반 가산기(Half adder)를 구현</p>
</li>
<li><p>예시 : a + b = S 와 같은 기본 연산 구현</p>
<ol>
<li><p>단일 비트에 의해 예측 가능한 연산 결과에 대한 <strong>진리 표</strong> 구하기</p>
<p> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/harf_adder_%EC%A7%84%EB%A6%AC%ED%91%9C.png"></p>
</li>
</ol>
</li>
</ul>
<pre><code>2. 작성된 **진리 표**를 구현 할 수 있는 부울대수식 구현
    
    S : Sum, C : Carry
    
    $S = a&#39;b + ab&#39; = a \oplus b$

    $C = ab$

3. 논리 게이트를 이용한 회로를 구성

    ![](/media/컴퓨터구조_files/논리게이트로회로구성.png)
</code></pre>
<h1 id="06-부울-대수와-논리식의-간편화"><a href="#06-부울-대수와-논리식의-간편화" class="headerlink" title="06. 부울 대수와 논리식의 간편화"></a>06. 부울 대수와 논리식의 간편화</h1><p>부울대수 : 논리게이트의 수학적 활용을 위함</p>
<p>카노 맵 : 논리식의 간편화</p>
<h2 id="부울-대수-Boolean-Algebra"><a href="#부울-대수-Boolean-Algebra" class="headerlink" title="부울 대수(Boolean Algebra)"></a>부울 대수(Boolean Algebra)</h2><ul>
<li>1854년 영국의 수학자 부울</li>
<li>논리적 명제(참, 거짓 판별)의 수학적 표현</li>
<li>즉, 논리적 명제를 논리 전개식으로 나타냄</li>
<li>논리 회로의 형태와 구조를 기술하는데 필요한 수학적 이론</li>
<li>변수들의 진리 표 관계를 대수식으로 표현하기에 용이</li>
<li>동일한 성능을 갖는 더 간단한 회로를 만들기 편리</li>
</ul>
<h3 id="부울-대수의-기본-법칙"><a href="#부울-대수의-기본-법칙" class="headerlink" title="부울 대수의 기본 법칙"></a>부울 대수의 기본 법칙</h3><h4 id="교환법칙-Commutative-Law"><a href="#교환법칙-Commutative-Law" class="headerlink" title="교환법칙(Commutative Law)"></a>교환법칙(Commutative Law)</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Commutative_Law.png"></p>
<h4 id="결합법칙-Associative-Law"><a href="#결합법칙-Associative-Law" class="headerlink" title="결합법칙(Associative Law)"></a>결합법칙(Associative Law)</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_Law.png"></p>
<h4 id="분배법칙-Distributive-Law"><a href="#분배법칙-Distributive-Law" class="headerlink" title="분배법칙(Distributive Law)"></a>분배법칙(Distributive Law)</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Distributive_Law.png"></p>
<h4 id="드모르간의-법칙-De-Morgam’s-theorm"><a href="#드모르간의-법칙-De-Morgam’s-theorm" class="headerlink" title="드모르간의 법칙(De Morgam’s theorm)"></a>드모르간의 법칙(De Morgam’s theorm)</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84%EB%B2%95%EC%B9%99.png"></p>
<p>출처 : <a target="_blank" rel="noopener" href="https://bite-sized-learning.tistory.com/358">https://bite-sized-learning.tistory.com/358</a></p>
<ul>
<li>논리합 $\rightarrow$ 논리곱</li>
</ul>
<!-- 또는 보수를 취해주면 -->

<ul>
<li><p>논리곱 $\rightarrow$ 논리합</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/De_Morgam's_theorm.png"></p>
</li>
</ul>
<h2 id="논리식의-간편화"><a href="#논리식의-간편화" class="headerlink" title="논리식의 간편화"></a>논리식의 간편화</h2><h3 id="부울-대수를-이용한-간략화"><a href="#부울-대수를-이용한-간략화" class="headerlink" title="부울 대수를 이용한 간략화"></a>부울 대수를 이용한 간략화</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%80%EC%9A%B8%EB%8C%80%EC%88%98%EB%A1%9C%EA%B0%84%EB%9E%B5%ED%99%94.png"></p>
<h3 id="Karnaugh-Map"><a href="#Karnaugh-Map" class="headerlink" title="Karnaugh Map"></a>Karnaugh Map</h3><p>부울 함수를 바로 간소화 할 수 있는 map 방법으로 널리 쓰임</p>
<ul>
<li><p>신경쓸 점</p>
<ol>
<li>  만약 변수가 n개라면 카노맵은 $2^n$개의 minterm으로 구성</li>
<li>  각 인접 민텀은 하나의 변수만이 변경되야 함</li>
<li>  출력이 1인 기본곱에 해당하는 minterm은 1로, 나머지는 0으로 표시</li>
</ol>
</li>
<li><p>카노맵 표현 방법</p>
<ul>
<li><p>이변수 카노 맵</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B4%EB%B3%80%EC%88%98%EC%B9%B4%EB%85%B8%EB%A7%B5.png"></p>
</li>
<li><p>삼변수 카노 맵</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%82%BC%EB%B3%80%EC%88%98%EC%B9%B4%EB%85%B8%EB%A7%B5.png"></p>
</li>
<li><p>사변수 카노 맵</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%82%AC%EB%B3%80%EC%88%98%EC%B9%B4%EB%85%B8%EB%A7%B5.png"></p>
</li>
</ul>
</li>
<li><p>카노맵을 이용한 간편화</p>
<ul>
<li><p>예제<br>$ E = a’b + abc + bc$ 삼변수 부울 식을 간편화 해보자!</p>
<ol>
<li><p>주어진 식에서 민텀을 찾아 1로 표시</p>
<p> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%B9%B4%EB%85%B8%EB%A7%B5step1.png"></p>
</li>
<li><p>인접 민텀 끼리 묶기</p>
<p> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%B9%B4%EB%85%B8%EB%A7%B5step2.png"></p>
<h1 id="07-조합-기억-논리회로"><a href="#07-조합-기억-논리회로" class="headerlink" title="07. 조합/기억 논리회로"></a>07. 조합/기억 논리회로</h1></li>
</ol>
</li>
</ul>
</li>
<li><p>조합 논리 회로 결과를 저장해야해</p>
<ul>
<li>기억시키는 곳을 Flip-Flop (1bit 를 기억)</li>
</ul>
</li>
<li><p>Flip-Flop 여러개 묶으면 레지스터</p>
</li>
</ul>
<h2 id="조합논리-회로"><a href="#조합논리-회로" class="headerlink" title="조합논리 회로"></a>조합논리 회로</h2><ul>
<li>조합 회로 (combinational logic circuit) : 입력과 출력을 가진 논리 게이트의 집합</li>
<li>출력 : 현재의 입력(0, 1)에 의해서 결정됨</li>
</ul>
<h3 id="조합회로-설계-절차"><a href="#조합회로-설계-절차" class="headerlink" title="조합회로 설계 절차"></a>조합회로 설계 절차</h3><ol>
<li> 문제 제시</li>
<li> 입력/출력 변수 명칭 부여</li>
<li> 입력/출력 사이 관계 정의 진리표 유도</li>
<li> 각 출력에 대해 간소화된 부울 함수를 얻음</li>
<li> 논리도 작성</li>
</ol>
<h3 id="대표적-조합회로"><a href="#대표적-조합회로" class="headerlink" title="대표적 조합회로"></a>대표적 조합회로</h3><h4 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h4><p>: 두 개 이상의 입력을 받아 결과물을 출력하는 조합논리회로</p>
<ul>
<li><p>Harlf Adder, Full Adder 차이점</p>
<ul>
<li> Full Adder 는 carry bit 처리 가능</li>
</ul>
</li>
<li><p>반 가산기(Half Adder)</p>
  <details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > 복습 </summary>
  <div>  
  
  1bit 덧셈 구현    
  : a + b = S 와 같은 기본 연산 구현
  
  1. 단일 비트에 의해 예측 가능한 연산 결과에 대한 **진리 표** 구하기

<pre><code>  ![](/media/컴퓨터구조_files/harf_adder_진리표.png)
</code></pre>
<ol start="2">
<li><p>작성된 <strong>진리 표</strong>를 구현 할 수 있는 부울대수식 구현</p>
<p> $S = a’b + ab’ = a \oplus b$</p>
<p> $C = ab$</p>
</li>
<li><p>논리 게이트를 이용한 회로를 구성</p>
</div>
</details>

<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8%EB%A1%9C%ED%9A%8C%EB%A1%9C%EA%B5%AC%EC%84%B1.png"></p>
</li>
</ol>
</li>
<li><p>전 가산기(Full Adder)</p>
<ul>
<li><p>진리표</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/full_adder_%EC%A7%84%EB%A6%AC%ED%91%9C.png"></p>
</li>
<li><p>논리 회로 :<br>  Harl Adder + Harl Adder + AND gate</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/fulladder.png"></p>
</li>
<li><p>부울 함수 식</p>
<p>$S = A\overline{B}\overline{C_{0}} + \overline{A}\overline{B}C_{0} + {ABC_{0}} + \overline{A}B\overline{C_{0}}$</p>
<p>$C = AC_0 + AB + BC_0$</p>
</li>
</ul>
</li>
</ul>
<h4 id="Multiplexer"><a href="#Multiplexer" class="headerlink" title="Multiplexer"></a>Multiplexer</h4><p>: 다수의 입력 중 하나만을 선별적으로 출력하는 조합논리회로</p>
<table>
<thead>
<tr>
<th align="center">$S_0$</th>
<th align="center">$S_1$</th>
<th align="center">Output</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">Input 0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">Input 1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">Input 2</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">Input 3</td>
</tr>
</tbody></table>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/multiplexer.png"></p>
<h4 id="Demultiplexer"><a href="#Demultiplexer" class="headerlink" title="Demultiplexer"></a>Demultiplexer</h4><p>: 하나의 입력을 통해 다수의 출력으로 분해하는 기능의 조합회로</p>
<p>예시) 10진수를 2진수로 분해</p>
<table>
<thead>
<tr>
<th align="center">$S_0$</th>
<th align="center">$S_1$</th>
<th align="center">Output</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">Output 0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">Output 1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">Output 2</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">Output 3</td>
</tr>
</tbody></table>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/demultiplexer.png"></p>
<h2 id="기억회로"><a href="#기억회로" class="headerlink" title="기억회로"></a>기억회로</h2><ul>
<li><p>플립플롭(Flip-Flop) : 순차 회로의 기본요소, 1bit 의 정보를 기억(보관 및 유지)할 수 있는 회로 </p>
<ul>
<li>클럭 입력을 갖는 2진 기억소자(쌍안정회로)<br>: 클럭 입력이 있는 동기식 순서논리회로의 기본 소자</li>
</ul>
</li>
<li><p>왜 배울까?</p>
<ul>
<li>대부분의 디지털 시스템들의 기본은 조합회로</li>
<li>그 중에서도 대다수인 <strong>순차회로</strong>는 정보의 <strong>기억</strong>이 필요</li>
<li>즉, 순서논리회로에서 가장 기본적으로 사용되는 기억 요소인 플립플롭이 필요</li>
</ul>
</li>
<li><p> 구성  :  <code>클럭</code> 입력 및 <code>래치</code> 소자로 만들어짐</p>
</li>
</ul>
<details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > 왜 present state를 Q라고 표기할까? </summary>
  <div>  
  결론 : 1950년 부터 그렇게 표기해 옴  
  아래처럼 여러가지 의견이 있음.

<ol>
<li><p>상태머신(finite states machines)에서 상태유지(status quo) 때문에 나온 것</p>
</li>
<li><p>present state라고 할 시, p는 이미 다른데 쓰였기 때문에 q라 함</p>
<p>1951년 S.C. Kleene이 각 상태를 표현하는데 q1, …  , qn 사용 </p>
<p>1955년 George Mealy 가 Q 를 “present state” 를 디자인 하는데 사용</p>
</li>
</ol>
<ol start="2">
<li><p>앨런튜링이 튜링머신에 Q를 상태를 표시하는데 사용함 </p>
<p>Alan Turing used the letter q to denote states in what came to be known as Turing machines. Presumably the q stood for quanta, emphasizing a state’s discrete rather than continuous nature. This happened in the 30s when quantum theory was permeating the scientific æther. </p>
</li>
<li><p>트랜지스터의 동작점(Q, quiescent point) 와 연관 </p>
<p>I was under the impression it had to do with the q-point (quiescent point) of a transistor, and that Q started referring to all transistor based components somehow.</p>
</li>
<li><p>German for Output or Source is Quelle</p>
</li>
<li><p>Q Output 표시의 O와 닮아서  </p>
<p>출처 : <a target="_blank" rel="noopener" href="https://electronics.stackexchange.com/questions/51625/why-is-the-output-of-stateful-elements-often-named-q">Why is the output of stateful elements often named Q?</a></p>
<p>현재 상태(present state, Q)</p>
<p>다음 상태(next state, Q+)</p>
</div>
</details>


</li>
</ol>
<h3 id="종류별-진리-표-여기표"><a href="#종류별-진리-표-여기표" class="headerlink" title="종류별 진리 표, 여기표"></a>종류별 진리 표, 여기표</h3><ul>
<li><p>진리표 : 조합회로의 입력과 출력과의 관계</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD_%EC%A7%84%EB%A6%AC%ED%91%9C.png"></p>
<p>  출처 : <a target="_blank" rel="noopener" href="http://www.ktword.co.kr/abbr_view.php?nav=&amp;m_temp1=4714&amp;id=1433">http://www.ktword.co.kr/abbr_view.php?nav=&amp;m_temp1=4714&amp;id=1433</a></p>
</li>
<li><p>여기표 : 상태의 변화에 대해 주어져야할 플립플롭의 입력을 나타냄</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%84%A4%EA%B0%80%EC%A7%80%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png"></p>
</li>
</ul>
<details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > 진리표, 상태표, 특성표, 여기표? </summary>
  <div>  

<p>진리표 : 조합회로의 입력과 출력과의 관계</p>
<p>상태표 : 순차회로의 현재상태와 입력에 대한 상태</p>
<p>특성표 : OOOO 의 동작을 나타내는 표</p>
<p>여기표 : 상태의 변화에 대해 주어져야할 OOOO의 입력을 나타냄<br>  </div></p>
</details>

<h3 id="R-S-래치-Latch"><a href="#R-S-래치-Latch" class="headerlink" title="R-S 래치(Latch)"></a>R-S 래치(Latch)</h3><p>상태값이 변하는지 안변하는지에 따라 정보를 기억</p>
<!-- > 안 변할 때는 기억, 변하면 중간결과값에 따라 변함 -->

<ul>
<li>진리표  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/SR%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%A7%84%EB%A6%AC%ED%91%9C.png"></li>
</ul>
<!-- |S|R|Q(t)|Q(t+1)|
|:-:|:-:|:-:|:-:|
|0|0|불변|Q(t) (불변)|
|0|1|1|0|
|1|0|0|1|
|1|1|불능|불능| -->



<ul>
<li>구성  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/R-S_Latch.png"></li>
</ul>
<ul>
<li>여기표   여기표는 순서논리회로를 설계할 때 자주 사용<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/SR%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png"></li>
</ul>
<ul>
<li>SR 플립플롭, RS 플립플롭<ul>
<li> 이론적으로 동일하지만, <em>S=R=1인 경우의 S입력과 R입력 사이의 우선순위 차이</em>로 둘을 구분하기도 한다 </li>
</ul>
</li>
</ul>
<h3 id="JK-플립플롭"><a href="#JK-플립플롭" class="headerlink" title="JK 플립플롭"></a>JK 플립플롭</h3><ul>
<li><p>진리표</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/JK%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%A7%84%EB%A6%AC%ED%91%9C.png"></p>
</li>
<li><p>여기표</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/JK%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png"></p>
</li>
</ul>
<h3 id="D-플립플롭"><a href="#D-플립플롭" class="headerlink" title="D 플립플롭"></a>D 플립플롭</h3><table>
<thead>
<tr>
<th align="center">Q</th>
<th align="center">D</th>
<th align="center">Q(t+1)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">Q</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<ul>
<li><p>구성</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/DFlipFlop.png"></p>
</li>
<li><p>여기표</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/D%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png"></p>
<h3 id="T-플립플롭"><a href="#T-플립플롭" class="headerlink" title="T 플립플롭"></a>T 플립플롭</h3></li>
<li><p>여기표</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/T%ED%94%8C%EB%A6%BD%ED%94%8C%EB%A1%AD%EC%97%AC%EA%B8%B0%ED%91%9C.png"></p>
</li>
</ul>
<h2 id="순차회로"><a href="#순차회로" class="headerlink" title="순차회로"></a>순차회로</h2><ul>
<li>순차 논리회로 (sequential logic circuit) : <ul>
<li>현재의 입력과 <strong>이전의 출력상태</strong>에 의해서 출력이 결정됨<ul>
<li><strong>이전의 출력상태</strong> 를 기억할 필요가 있음</li>
</ul>
</li>
<li>구성 : 조합논리회로 + 메모리소자(Flip-Flop)<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A1%B0%ED%95%A9%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C.png"></li>
</ul>
</li>
</ul>
<details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > 순서논리회로의 해석과정 </summary>
  <div>  

<ol>
<li>회로 입력/출력에 대한 변수 명칭 부여</li>
<li>조합논리회로가 있으면, 조합논리회로의 불대수식 유도</li>
<li>회로의 상태표 작성</li>
<li>상태표를 이용하여 상태도 작성</li>
<li>상태방정식 유도</li>
<li>상태표와 상태도를 분석하여 회로의 동작 설명</li>
</ol>
<p>출처 : <a target="_blank" rel="noopener" href="https://slidesplayer.org/slide/16789275/">https://slidesplayer.org/slide/16789275/</a><br>  </div></p>
</details>


<h3 id="순차회로의-상태표와-상태도"><a href="#순차회로의-상태표와-상태도" class="headerlink" title="순차회로의 상태표와 상태도"></a>순차회로의 상태표와 상태도</h3><ul>
<li>순차회로의 특성 $\leftarrow$ 입력,출력 및 플립플롭의 상태</li>
<li>출력과 다음 상태(next state) $\leftarrow$ 입력과 현 상태(present state, Q)의 함수</li>
<li>상태표 : 순차회로의 현재상태와 입력에 대한 상태</li>
<li>상태도 : 상태표를 그림으로 도시한 것</li>
</ul>
<table>
<thead>
<tr>
<th align="center">상태표</th>
<th align="center">$\leftrightarrow$</th>
<th align="center">상태도</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%83%81%ED%83%9C%ED%91%9C.png"></td>
<td align="center"></td>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%83%81%ED%83%9C%EB%8F%84.png"></td>
</tr>
</tbody></table>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li><p>데이터의 표현(상태) $\rightarrow$ 조합회로의 근간</p>
<ul>
<li>데이터를 실제로 컴퓨터 내부에서 어떻게 표현하는지 $\rightarrow$ 게이트로 표현</li>
<li>게이트의 표현 $\rightarrow$ 부울 대수에 의함 <ul>
<li>진리표를 만들어서 설계도로 활용, 개선필요 $\rightarrow$ 카노맵</li>
</ul>
</li>
</ul>
</li>
<li><p>조합회로 + 플립플롭 $\rightarrow$ 순차회로 (진정한 형태의 회로)</p>
<ul>
<li>조합회로 : 입력과 출력을 가진 논리 게이트의 집합, 출력은 현재의 입력(0, 1)에 의해서 결정됨</li>
<li>순차회로 : 현재의 입력과 <strong>이전의 출력상태</strong>에 의해서 출력이 결정됨<ul>
<li><strong>이전의 출력상태</strong> 를 기억할 필요가 있음 $\rightarrow$ 메모리 소자가 필요함</li>
<li>구성 : 조합논리회로 + 메모리소자(<strong>Flip-Flop</strong>)</li>
</ul>
</li>
</ul>
</li>
<li><p>순차회로의 상태를 표시 $\rightarrow$ 상태표, 상태도</p>
</li>
</ul>
<h1 id="08-CPU-내부-구조"><a href="#08-CPU-내부-구조" class="headerlink" title="08. CPU 내부 구조"></a>08. CPU 내부 구조</h1><h2 id="CPU-구성요소"><a href="#CPU-구성요소" class="headerlink" title="CPU 구성요소"></a>CPU 구성요소</h2><ul>
<li><p>CPU(Central Processing Unit) : 컴퓨터에서 데이터 처리 동작을 수행하는 부분 (motherboard 에 위치)</p>
</li>
<li><p>CPU 구성 요소 </p>
<ul>
<li><p>Control Unit : RS간 정보전송 감시, ALU에게 수행할 동작 지시</p>
</li>
<li><p>Register Set : 명령을 실행하는데 필요한 데이터를 보관</p>
</li>
<li><p>Arithmetic Logic Unit : 명령어를 실행하기위한 마이크로 연산 수행</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Major_components_of_CPU.png" alt="Major components of CPU"></p>
<p>출처 : <a target="_blank" rel="noopener" href="https://slideplayer.com/slide/3336960/11/images/2/Major+components+of+CPU.jpg">https://slideplayer.com/slide/3336960/11/images/2/Major+components+of+CPU.jpg</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="CPU-내부-구조"><a href="#CPU-내부-구조" class="headerlink" title="CPU 내부 구조"></a>CPU 내부 구조</h2><ul>
<li><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0_re.png" alt="CPU내부구조"></li>
</ul>
<!-- 1. MAR(Memory Address Register) : 메모리 상태 체크
2. 메모리 : 임시 저장소
3. MBR(Memory Buffer Register)  

- Register Set(IR, SR, WR, GR, ...)과 ALU(PC, Decoder) 그리고 Control Unit이 다음과 같이 관계를 형성하는 것을 볼 수 있고 PC(Program Counter)에 의해 해당되는 코드를 해독하여 MAR(Memory Address Register)에 R/W를 위해 해당되는 기억장치 주소를 저장한다. 이후 MBR(Memory Buffer Register)에서 메모리 전달 직전 기억장치에 R/W에 활용될 데이터를 저장하는데 사용한다. -->

<h3 id="CU-Control-Unit"><a href="#CU-Control-Unit" class="headerlink" title="CU (Control Unit)"></a>CU (Control Unit)</h3><ul>
<li><p>ID로부터 보내진 신호에 따라 장치들에게 동작을 명령(제어신호를 전송)함</p>
<ul>
<li>clock에 의해 발생 = 순서제어(Sequencing)</li>
</ul>
</li>
<li><p>다양한 마이크로 오퍼레이션이 실행(Execution)되도록 해줌</p>
<ul>
<li>명령(연산)을 해석(decoding)하고 그에 따른 필요한 각종 제어 신호를 발생하는 것</li>
</ul>
</li>
<li><p>구성 : 명령어 레지스터(IR), 제어 주소 레지스터(CAR), 제어 버퍼 레지스터(CBR), ID, 제어신호 발생기, 제어 기억장치(CM), 순서 제어 모듈(SM), 순차 카운터</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CU%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0.png" alt="CU내부구조"></p>
<p>  출처(+ 자세한 설명) : <a target="_blank" rel="noopener" href="https://blog.naver.com/PostView.nhn?blogId=ljh0326s&amp;logNo=220850753876&amp;parentCategoryNo=&amp;categoryNo=7&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postView">https://blog.naver.com/PostView.nhn?blogId=ljh0326s&amp;logNo=220850753876&amp;parentCategoryNo=&amp;categoryNo=7&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postView</a></p>
</li>
</ul>
<h4 id="IR-ID-Encoder-CAR-CBR-CM-SM-SC"><a href="#IR-ID-Encoder-CAR-CBR-CM-SM-SC" class="headerlink" title="IR, ID, Encoder, CAR, CBR, CM, SM, SC"></a>IR, ID, Encoder, CAR, CBR, CM, SM, SC</h4><ul>
<li>명령어 레지스터(IR) : 현재 수행하는 명령어를 기억하는 레지스터</li>
<li>ID (Instruction Decoder) :IR에 들어있는 명령코드의 해석을 담당하는 논리회로 (해석 : 각종 명령코드 $\rightarrow$ 제어 신호로 변환하여 기계 사이클로 전송)</li>
<li>제어신호 발생기(Encoder) : 해독한 명령어에 따라 제어 신호를 생성하는 회로</li>
<li>제어 주소 레지스터(CAR) : 다음 실행할 마이크로 명령어의 주소를 저장하는 레지스터</li>
<li>제어 버퍼 레지스터(CBR) : 읽어온 마이크로 명령어를 일시적으로 저장하는 레지스터</li>
<li>제어 기억장치(CM) : 마이크로명령어들로 이루어진 마이크로 프로그램을 저장하는 내부 기억장치</li>
<li>순서 제어 모듈(SM) : 마이크로 명령어의 수행 순서를 결정하는 회로들의 집합</li>
<li>순차 카운터(SC): Decoder가 해독한 명령에 따라 선택된 번호에 해당하는 타이밍 신호를 생성<ul>
<li>타이밍 신호 : 마이크로 오퍼레이션이 순서대로 실행될 수 있도록 보내는 신호</li>
</ul>
</li>
</ul>
<h3 id="ALU-Arithmetic-and-Logic-Unit"><a href="#ALU-Arithmetic-and-Logic-Unit" class="headerlink" title="ALU (Arithmetic and Logic Unit)"></a>ALU (Arithmetic and Logic Unit)</h3><ul>
<li>산술과 논리 연산을 하는 장치 </li>
<li>구성 : 가산기, 누산기, 보수기, 오버플로우 검출기, 쉬프트 레지스터, 데이터 레지스터 </li>
</ul>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><ul>
<li><p>CPU내에서 데이터를 기억하는 메모리 장치</p>
<ul>
<li>Flip-Flop 즉, 메모리소자가 여러개 모인 것</li>
</ul>
</li>
<li><p>CPU내에서 처리할 명령어나 연산에 사용할 값이나 연산 결과를 일시적으로 기억함</p>
</li>
<li><p>대표적인 레지스터</p>
<table>
<thead>
<tr>
<th align="center">종류</th>
<th align="center">기능</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PC<br/>(Program Counter)</td>
<td align="center">다음 인출(Fetch) 될 명령어(주기억장치에 있음)의 주소를 가지고 있는 레지스터 <br/> IC(instruction counter), LC(location counter) 라고도 부름</td>
</tr>
<tr>
<td align="center">AC<br/>(Accumulator)</td>
<td align="center">연산 결과 데이터를 일시적으로 저장하는 레지스터</td>
</tr>
<tr>
<td align="center">IR<br/>(Instruction Register)</td>
<td align="center">PC가 지정하는 주소에 기억되어 있는 명령어를 해독하기 위해 임시로 기억하는 레지스터 (가장 최근에 인출된 명령어 = 현재 실행 중인 명령어가 저장됨)</td>
</tr>
<tr>
<td align="center">(M)SR/PSWR/FR<br/>((Major) Status Register)<br/>(Program Status Word Register)<br/>(Flag Register)</td>
<td align="center">현재 CPU 의 상태를 나타내는 특수목적의 레지스터 <br/>연산 중간값/결과의 상태 (= 시스템 내부의 순간순간의 상태 = PWD)를 기록 <br/>PWD : Z (zero), S (sign, 부호), V (overflow), C (carry), I (interrupt)</td>
</tr>
<tr>
<td align="center">MAR<br/>(Memory Address Register)</td>
<td align="center">PC 에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터</td>
</tr>
<tr>
<td align="center">MBR<br/>(Memory Buffer Register)</td>
<td align="center">기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터</td>
</tr>
<tr>
<td align="center">범용 레지스터(General purpose Register)</td>
<td align="center">작업 레지스터에서 DATA가 용이하게 처리되도록 임시로 자료를 저장하는 경우 사용</td>
</tr>
<tr>
<td align="center">작업 레지스터(Working Register)</td>
<td align="center">산술논리연산을 실행할 수 있도록 자료를 저장하고 그 결과를 저장</td>
</tr>
</tbody></table>
<ul>
<li>GPR과 WR의 차이점<ul>
<li>ALU에 연결되어 있는지의 여부</li>
</ul>
</li>
</ul>
</li>
<li><p>기타 레지스터</p>
<table>
<thead>
<tr>
<th align="center">종류</th>
<th align="center">기능</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AC(Accumulator)</td>
<td align="center">연산 결과를 임시로 저장하는 레지스터로 누산기</td>
</tr>
<tr>
<td align="center">MSR(Major Status Register)</td>
<td align="center">CPU의 주 상태를 저장하는 레지스터</td>
</tr>
<tr>
<td align="center">BR(Base Register)</td>
<td align="center">명령의 시작 주소를 기억하는 레지스터</td>
</tr>
<tr>
<td align="center">인덱스 레지스터</td>
<td align="center">프로그래머가 내용을 변경할 수 있으며 주소의 변경, 서브루틴 연결 및 반복 연산의 횟수에 사용</td>
</tr>
<tr>
<td align="center">데이터 레지스터</td>
<td align="center">연산에 사용할 데이터를 기억</td>
</tr>
<tr>
<td align="center">쉬프트 레지스터</td>
<td align="center">자리 이동 레지스터</td>
</tr>
</tbody></table>
</li>
</ul>
<!-- - SR (Status Register)

    |명칭|축약어|설명|
    |:-:|:-:|:-:|
    |영|Z|**Z**ero|
    |부호|S|**S**ign|
    |오버플로우|V|O**v**erflow|
    |캐리|C|**C**arry|
    |인터럽트|I|**I**nterrupt| -->

<h3 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h3><ul>
<li>장치와 장치사이에 정보를 주고받기 위한 전송선<ul>
<li>주소, 자료, 제어 정보를 보냄</li>
</ul>
</li>
<li>내부 버스 : CPU 와 메모리 내에 구성하는 버스</li>
<li>외부 버스 : 주변 입출력 장치에 구성하는 버스</li>
</ul>
<h3 id="ADD-명령어의-실행-예"><a href="#ADD-명령어의-실행-예" class="headerlink" title="ADD 명령어의 실행 예"></a>ADD 명령어의 실행 예</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/ADD%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98%EC%8B%A4%ED%96%89%EC%98%88.png"></p>
<ul>
<li><p>Fetch : 명령어 인출 : 실제 명령(연산)이 일어나기전 어떤 명령(연산)인지 파악</p>
<ol>
<li><p>MAR ← PC <br/>: 실행할 명령어 주소값을 PC에서 읽어 MAR 에 넣음 </p>
<ul>
<li><p>즉, PC에는 다음 인출(Fetch) 될 명령어의 주소가 저장되어 있고,</p>
</li>
<li><p>이 주소가 사용되기 전에, MAR에 일시적으로 저장</p>
</li>
</ul>
</li>
<li><p>MBR ← 기억장치[MAR] <br/>: MAR이 지정하는 주소의 내용을 기반으로 Memory 에서 명령어를 읽어 MBR에 넣음 </p>
<ul>
<li>즉, 기억장치에 저장될 혹은 읽혀진 데이터가, MBR에 일시적으로 저장됨</li>
</ul>
</li>
<li><p>IR ← MBR <br/>: MBR의 내용을 IR에 넣음</p>
<ul>
<li>가장 최근에 인출된 명령어가 MBR에서 얻어져서, IR로 들어감 <ul>
<li>PC가 주소를 지정했을 때, 주소에 기억되어 있는 명령어를 해독하기 위해 임시로 기억이 필요하기 때문</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>EXECUTE : 실제 연산이 일어남</p>
<ol start="4">
<li><p>MAR ← IR[OPRD] <br/>: IR 레지스터의 주소 부분을 MAR로 이동</p>
<ul>
<li>주소가 사용되기 전엔 항상 MAR에 일시적으로 저장됨</li>
</ul>
</li>
<li><p>MBR ← 기억장치[MAR]  <br/>: ADD 할 내용을 MBR로 이동</p>
<ul>
<li>ADD 할 내용(기억장치에 저장될 혹은 읽혀진 데이터가)이, MBR에 일시적으로 저장됨</li>
</ul>
</li>
<li><p>WR ← GR[IR] <br/>: IR에서 지정하는 GR의 내용을 WR로 이동</p>
<ul>
<li>작업 레지스터에서 DATA가 용이하게 처리되도록, GR에 임시로 자료를 저장함</li>
<li>산술논리연산(지금 상황에선 ADD)을 실행할 수 있도록, WR에 자료를 저장</li>
</ul>
</li>
<li><p>WR ← WR + MBR  <br/>: ADD 작업 WR + MBR 을 WR로 이동</p>
<ul>
<li>ADD 결과(WR에 있는 데이터 + MBR에 있는 데이터)를 WR 저장함</li>
</ul>
</li>
<li><p>GR[IF] ← WR <br/>: WR의 결과를 GR로 이동</p>
</li>
<li><p>PC ← PC + 1 <br/>: 다음 명령어를 수행하기 위해 PC 값을 증가시킴</p>
</li>
</ol>
</li>
</ul>
<h2 id="명령어-구성과-실행"><a href="#명령어-구성과-실행" class="headerlink" title="명령어 구성과 실행"></a>명령어 구성과 실행</h2><h3 id="명령어-코드"><a href="#명령어-코드" class="headerlink" title="명령어 코드"></a>명령어 코드</h3><ul>
<li>기본 컴퓨터의 각 연산이 동작하기 위해서, 컴퓨터 구조(CPU…)는 (1)내부 레지스터, (2)클럭(=타이밍), (3)제어구조 명령어 집합에 의해 정의되어야 한다. <ul>
<li>기본 컴퓨터의 연산이란? <ul>
<li>Micro Command Operation (또는 Instruction Operation) : 인접해있는 레지스터 끼리, 필요한 데이터를 주고 받으면서 결과를 도출 하는 행위<ul>
<li>레지스터 전송문으로 나타내어짐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>레지스터가 상호간에 데이터를 주고 받을 때, 타이밍과 제어구조 명령어 집합이 필요함<ul>
<li>타이밍 : 시그널을 줌 (지금 시작! 끝! 이런식으로)</li>
<li>제어구조 : 데이터를 줄 때, 그냥 주면 된다 / 한번 건너 뛰어야 한다 / 더해서 준다 / 빼서 준다 </li>
</ul>
</li>
</ul>
<h3 id="레지스터-전송-언어"><a href="#레지스터-전송-언어" class="headerlink" title="레지스터 전송 언어"></a>레지스터 전송 언어</h3><ul>
<li><p><strong>마이크로 연산(Micro-operation)</strong> : 레지스터(Register)에 저장된 데이터의 조작을 위해 실행되는 동작. 하나의 클럭 펄스 내에서 실행되는 기본 동작.</p>
<ul>
<li><p>예시 : 시프트(shift), 카운트(count), 클리어(crear), 로드(road) $\cdots$</p>
</li>
<li><p>컴퓨터에서 마이크로 연산은 내부적 연산이고, 매크로 연산은 외부적 연산임 (메모리 접근 속도 차이)</p>
</li>
</ul>
</li>
</ul>
<h3 id="생각-해볼-점"><a href="#생각-해볼-점" class="headerlink" title="생각 해볼 점"></a>생각 해볼 점</h3><blockquote>
<p>명령어가 어떻게 구성되고, 작동하는지! </p>
</blockquote>
<p>디지털 컴퓨터의 구조를 정의하기 위해 필요한 지식</p>
<ul>
<li>레지스터의 종류와 그 기능</li>
<li>레지스터에 저장된 이진 정보를 가지고 수행되는 일련의 마이크로 연산들</li>
<li>일련의 마이크로 동작을 온/오프 시킬 수 있는 제어 기능</li>
</ul>
<blockquote>
<p>설계도, 플로우 차트(청사진) 만들어야 해 $\rightarrow$ 작성 <strong>규칙</strong> 필요</p>
</blockquote>
<h3 id="작성-규칙-레지스터-전송"><a href="#작성-규칙-레지스터-전송" class="headerlink" title="[작성 규칙] 레지스터 전송"></a>[작성 규칙] 레지스터 전송</h3><table style="text-align: center">
    <th> 가장 일반적인 표현 </th>
    <tr>
        <td>
            <img src="/media/컴퓨터구조_files/RegisterR.png"/>
            Register R
        </td>
        <td>
            <img src="/media/컴퓨터구조_files/가장일반적비트표현.png"/>
            가장 일반적 비트 표현
        </td>
    </tr>
    <tr>
        <td>
            <img src="/media/컴퓨터구조_files/16비트레지스터의번호표현.png"/>
            비트 레지스터의 번호 표현
        </td>
        <td>
            <img src="/media/컴퓨터구조_files/상위비트와하위비트의표현.png"/>
            상위 비트와 하위 비트의 표현
        <td>
    </tr>
</table>

<hr>
<p>$R_2\leftarrow R_1$ : 치환 연산자(replacement)를 이용한 레지스터간 정보 전송</p>
<p>$P:R_2\leftarrow R_1$ : 앞에 <code>P:</code> 는 조건 연산자로, $If (P=1) then (R_2\leftarrow R_1 )$ 를 뜻함. 소스(source) 레지스터로 부터 목적(target) 레지스터로의 연결과 목적 레지스터에는 조건부 처리가 가능 할 수 있도록 병렬 로드 기능이 있어야 함</p>
<blockquote>
<p>레지스터 전송을 나타내는 각 문장들은 그 전송을 수행 하는 하드웨어가 구성되어 있음을 의미 함</p>
</blockquote>
<blockquote>
<p>즉, 하드웨어는 레지스터 전송을 나타내는 명령어들이 어떻게 구성되어 있는 냐에 따라서, 어떻게 만들어야 할 지 알 수 있음</p>
</blockquote>
<blockquote>
<p>하드웨어를 먼저 구성하기 전에, 어떤 영역을 어떻게 쓰겠다라는 것이 먼저 생각되어야 함</p>
</blockquote>
<blockquote>
<p>마이크로 커맨드의 구성에 따라서 CPU가 만들어 짐</p>
</blockquote>
<blockquote>
<p><strong>어떤 커맨드를 만들까, 커맨드와 커맨드 사이 어떤 연결을 해주면 좋을까?</strong></p>
</blockquote>
<!-- ![](/media/컴퓨터구조_files/레지스터전송_가장일반적표현들.png) -->

<hr>
<p>레지스터 전송의 기본 기호</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EC%A0%84%EC%86%A1_%EA%B8%B0%EB%B3%B8%EA%B8%B0%ED%98%B8.png" alt="레지스터 전송의 기본기호"></p>
<p>두 연산을 분리 했다는 것은 서로 parallel 함, 동시에 연산이 이루어 지지만 영향을 미치지 않는 다는 것을 의미</p>
<h2 id="CPU-디자인"><a href="#CPU-디자인" class="headerlink" title="CPU 디자인"></a>CPU 디자인</h2><p>CPU 내 다양한 디바이스 간 상호연결 존재</p>
<ul>
<li><p>직접 연결 : 복잡도가 장치수의 제곱에 비례 ($\rightarrow$ 확장성이 떨어짐, <strong>부적합</strong>)</p>
<ul>
<li><p>또한 하드웨어 소프트웨어 서로의 영향을 최소화 해야 함 </p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0_%EC%A7%81%EC%A0%91%EC%97%B0%EA%B2%B0.png"></p>
</li>
</ul>
</li>
<li><p>버스 연결 : 공용선(Common Line)에 의한 연결</p>
<ul>
<li><p>가장 가성비 높은 연결 방식</p>
</li>
<li><p>관리를 위한 다양한 방법이 제시됨</p>
<ul>
<li>토큰 발생 처리 등</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/CPU%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0_%EB%B2%84%EC%8A%A4%EC%97%B0%EA%B2%B0.png"></p>
</li>
</ul>
</li>
</ul>
<!-- ### 버스에 의한 레지스터 상호 연결 -->

<h3 id="공용선에-의한-레지스터-상호-연결-예-멀티플렉스를-이용"><a href="#공용선에-의한-레지스터-상호-연결-예-멀티플렉스를-이용" class="headerlink" title="공용선에 의한 레지스터 상호 연결 예 - 멀티플렉스를 이용"></a>공용선에 의한 레지스터 상호 연결 예 - 멀티플렉스를 이용</h3><ul>
<li><p>멀티플렉서 특징 : 여러 신호중에서 하나만 선택해서 내보냄</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A1%B0%ED%95%A9%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C_%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%84%9C.png"></p>
</li>
<li><p>버스, 공용선의 기본 컨셉이 바로 멀티플렉스</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0_%EC%83%81%ED%98%B8_%EC%97%B0%EA%B2%B0_%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%84%9C.png"></p>
<p>  원하는 레지스터를 선택적으로 결정할 수 있으며 출력은 공통버스를 통해 나감</p>
</li>
</ul>
<h3 id="3-상태-버스-버퍼"><a href="#3-상태-버스-버퍼" class="headerlink" title="3 상태 버스 버퍼"></a>3 상태 버스 버퍼</h3><!-- 참고 : https://slideplayer.com/slide/3336960 -->

<ul>
<li><p>3-상태버스버퍼</p>
<p>  버퍼 : 연산의 중간 결과값을 기억</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/three-state_buffer.png"></p>
</li>
</ul>
<ul>
<li><p>3 상태 버퍼를 사용한 버스 구성</p>
<ul>
<li><p>Enable 이 0 이면 부하(저항)이 커져서, 신호가 못나감</p>
</li>
<li><p>Enable 되면 선택을 줘서 원하는 레지스터를 사용함</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0_%EC%83%81%ED%98%B8%EC%97%B0%EA%B2%B0_3-%EC%83%81%ED%83%9C%EB%B2%84%EC%8A%A4%EB%B2%84%ED%8D%BC.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="스택-큐-데크"><a href="#스택-큐-데크" class="headerlink" title="스택, 큐, 데크"></a>스택, 큐, 데크</h3><p>CPU에서 자주 활용되는 자료구조의 특징을 비교해보자!</p>
<table>
<thead>
<tr>
<th align="center">이름</th>
<th align="center">특징</th>
<th align="center">디자인</th>
<th align="center">사용예</th>
</tr>
</thead>
<tbody><tr>
<td align="center">스택(Stack)</td>
<td align="center">LIFO(Last in First Out)<br/>입력 : push(), 출력 : pop()</td>
<td align="center"><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/stack2.png"></td>
<td align="center">- Call Stack - 주함수에서 서브루틴을 호출할 경우 <br/> - 문자열의 역순 출력 <br/> 연산자 후위 표기법</td>
</tr>
<tr>
<td align="center">큐(Queue)</td>
<td align="center">FIFO(First In First Out)<br/> 입력 : put(), 출력 : get()</td>
<td align="center"><img src="/media/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0_files/queue.png"></td>
<td align="center">- 버퍼(Buffer)와 같이 순차적 처리를 요하는 자료이 대기 시 활용</td>
</tr>
<tr>
<td align="center">데크(Deque)</td>
<td align="center">스택과 큐의 동작을 동시에 가능하도록 디자인 된 자료구조</td>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/deque.png"></td>
<td align="center">- scroll : 입력 제한 데크<br/> - shelf : 출력 제한 데크</td>
</tr>
</tbody></table>
<h1 id="09-마이크로-명령과-ALU"><a href="#09-마이크로-명령과-ALU" class="headerlink" title="09. 마이크로 명령과 ALU"></a>09. 마이크로 명령과 ALU</h1><h2 id="마이크로-연산"><a href="#마이크로-연산" class="headerlink" title="마이크로 연산"></a>마이크로 연산</h2><p>: 레지스터에 저장된 데이터에 대해 수행되는 기본적인 연산</p>
<ul>
<li><p>분류 (4 가지)</p>
<ul>
<li>레지스터 전송(Move) : 레지스터 사이에서 이진 정보를 전송   <!-- *   참고 : https://goodmilktea.tistory.com/126 --></li>
<li>  산술(Arithmetic) : 레지스터에 저장된 수치 데이터에 대해 산술 연산 수행</li>
<li>  논리(Logic) : 레지스터에 저장된 비수치 데이터에 대해 비트 조작 연산 수행</li>
<li>  시프트(shift) : 레지스터에 저장된 데이터에 대해 시프트 연산 수행</li>
</ul>
</li>
</ul>
<h2 id="ALU에서-마이크로-연산"><a href="#ALU에서-마이크로-연산" class="headerlink" title="ALU에서 마이크로 연산"></a>ALU에서 마이크로 연산</h2><p>산술 논리 연산 장치(Arithmetic Logic Unit, ALU)</p>
<ul>
<li>산술 연산과 논리 연산을 주로 처리하며 </li>
<li>주로 정수 연산을 처리</li>
<li>최근(2019)에는 ALU가 부동 소수 연산(Floating-Point Unit, FPU)까지 처리</li>
</ul>
<ul>
<li>  산술 연산 :  덧셈(+), 뺼셈(-), 곱셈(*), 나눗셈(/), 증가(++), 감소(–), 보수(~)</li>
<li>  논리 연산 : AND, OR, NOT, XOR, SHIFT</li>
</ul>
<h3 id="연산-과정"><a href="#연산-과정" class="headerlink" title="연산 과정"></a>연산 과정</h3><ol>
<li>제어신호에 따라 데이터를 가져와 연산을 수행</li>
<li>필요시 AC(Accumulator)에 임시 저장<ul>
<li>AC(Accumulator) : 연산 결과를 임시로 저장하는 레지스터로 누산기</li>
</ul>
</li>
<li>결과를 SR(Status Register)에 저장<ul>
<li>시스템 내부의 순간순간의 상태, PWD(Program Status Word)를 기록<br>: Z (zero), S (sign, 부호), V (overflow), C (carry), I (interrupt)</li>
</ul>
</li>
</ol>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/ALU.png"></p>
<!-- 대상 커맨드 소속이 ALU -->

<h3 id="산술-연산"><a href="#산술-연산" class="headerlink" title="산술 연산"></a>산술 연산</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%97%B0%EC%82%B0_%EC%82%B0%EC%88%A0%EC%97%B0%EC%82%B0.png"></p>
<!-- |연산|동작|기능|
|:-:|:-:|:-:|
|ADD|$X \leftarrow A + B$|A와 B를 더한다|
|SUB|$X \leftarrow A + (~B +1) $|A에 B의 two`s complement 를 더한다|
|MUL|$X \leftarrow A \times B$|A와 B를 곱한다|
|DIV|$X \leftarrow A \div B$|A와 B를 나눈다|
|INC|$X \leftarrow A + 1$|A를 1 증가 시킨다|
|DEC|$X \leftarrow A - 1$|A를 1 감소 시킨다|
|NEG|$X \leftarrow ~A + 1$|A의 two`s complement| -->


<h3 id="논리-연산-및-시프트-연산"><a href="#논리-연산-및-시프트-연산" class="headerlink" title="논리 연산 및 시프트 연산"></a>논리 연산 및 시프트 연산</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%97%B0%EC%82%B0_%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0%EA%B3%BC_%EC%82%B0%EC%88%A0%EC%8B%9C%ED%94%84%ED%8A%B8%EC%97%B0%EC%82%B0.png"></p>
<h4 id="논리-연산-예시"><a href="#논리-연산-예시" class="headerlink" title="논리 연산 예시"></a>논리 연산 예시</h4><p>A=46$=00101110_{(2)}$, B=-75$=10110101_{(2)}$<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC_%EC%97%B0%EC%82%B0_%EC%98%88%EC%8B%9C1.png"></p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%85%BC%EB%A6%AC_%EC%97%B0%EC%82%B0_%EC%98%88%EC%8B%9C2.png"></p>
<ul>
<li><p>Masking 예시 (AND 연산)</p>
<ul>
<li>10진수 표현법, 언패킹-&gt;패킹 시 FFFF 떼어버릴 때, 마스킹해서 떼어버림</li>
</ul>
</li>
<li><p>Insert 예시 (OR 연산)</p>
<ul>
<li>수치만 남기고 INSERT</li>
</ul>
</li>
</ul>
<h4 id="시프트-연산-예시"><a href="#시프트-연산-예시" class="headerlink" title="시프트 연산 예시"></a>시프트 연산 예시</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%9C%ED%94%84%ED%8A%B8%EC%97%B0%EC%82%B0%EC%98%88%EC%8B%9C.png"></p>
<h1 id="10-마이크로-명령어"><a href="#10-마이크로-명령어" class="headerlink" title="10. 마이크로 명령어"></a>10. 마이크로 명령어</h1><ul>
<li>마이크로 명령어의 집합과 구성</li>
<li>입출력과 인터럽트  <!-- 왜 CPU가 이런구조를 가져야하는지 명령어의 입출력과 인터럽트를 알아보자 --></li>
<li></li>
</ul>
<h2 id="명령어-instruction-집합"><a href="#명령어-instruction-집합" class="headerlink" title="명령어(instruction) 집합"></a>명령어(instruction) 집합</h2><ul>
<li>실행 순서에 따른 명령어 분류</li>
</ul>
<ul>
<li>  순차적 실행 명령어 (전체 실행 명령어의 70~80% 차지)</li>
<li>  분기 명령어</li>
<li>  부함수 호출 명령어</li>
<li>  복귀 명령어</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%A2%85%EB%A5%98.png"></p>
<h2 id="명령어-구문-형식"><a href="#명령어-구문-형식" class="headerlink" title="명령어 구문 형식"></a>명령어 구문 형식</h2><p>명령어 구문은 다음과 같은 형식으로 구성됨</p>
<ul>
<li><p>Direct Mode (기본)</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%AA%85%EB%A0%B9%EC%96%B4%EA%B5%AC%EC%84%B1.png"></p>
<ul>
<li>명령코드를 해석한 후, 명령어가 적용될 대상(통상적으로 주소, 여기서는 Operand)가 바로 뒤에오는 경우</li>
</ul>
</li>
<li><p>Indirect Mode (조금 더 복잡해진 구조)</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%AA%85%EB%A0%B9%EC%96%B4%EA%B5%AC%EC%84%B12.png"></p>
<ul>
<li>하드웨어와 소프트웨어의 <strong>독립성</strong> 을 유지하기 위해, <strong>2.주소지정모드</strong> 가 추가 됨</li>
<li>Addressing mode에 의해 정해진 인덱싱 룰을 따름<ul>
<li>하드웨어 짜는 사람은 소프트웨어를 생각할 필요가 없고, 소프트웨어를 짜는 사람은 하드웨어를 신경 쓸 필요가 없음</li>
<li>하드웨어 위치가 바뀐다 해도 찾아갈 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>정리하자면, </p>
<ul>
<li> 명령 코드 : CPU가 실행할 수 있도록 디자인 된 연산</li>
<li> 주소 지정 모드(addressing mode) : Operand가 저장된 위치를 인덱싱(지정)하는 방법</li>
<li> 주소 필드(Operand) : 연산에 사용되는 자료 값, 자료가 저장 된 주소에 관한 정보</li>
</ul>
<h3 id="주소-지정-모드-Addressing-Mode"><a href="#주소-지정-모드-Addressing-Mode" class="headerlink" title="주소 지정 모드 (Addressing Mode)"></a>주소 지정 모드 (Addressing Mode)</h3><ul>
<li><p>명령어의 수와 길이를 줄이기 위한 세계적 표준화 기법</p>
<ul>
<li>목적 : 하드웨어와 소프트웨어의 독립성을 유지! <ul>
<li>독립성이 유지되면, 프로그램의 유연성(pointer, indexing 등…)을 가능</li>
</ul>
</li>
<li>즉, 명령어의 구조상 자료가 저장되어 있는 장소를 지정하는 방법이 필요했고, 이게 Addressing Mode</li>
</ul>
<h4 id="주소-지정-모드-종류"><a href="#주소-지정-모드-종류" class="headerlink" title="주소 지정 모드 종류"></a>주소 지정 모드 종류</h4></li>
</ul>
<ul>
<li><p>묵시적 모드(Implied Mode) : 주소 필드(Operand)가 명령어에 미포함 (특수 모드)</p>
<ul>
<li>대신, 누산기나 스택의 데이터를 묵시적으로 지정하여 사용</li>
<li>레지스터의 값을 초기화할 때 주로 사용</li>
</ul>
<ul>
<li>  <code>NOP</code> : No operation, 오퍼랜드가 필요없는 명령어</li>
<li>  <code>INC</code> : 묵시적 오퍼랜드인 누산기(AC)의 연산 명령어</li>
<li><code>ADD</code> : 스택 구조의 명령어(스택에 오퍼랜드가 저장)</li>
</ul>
</li>
<li><p>Immediate Mode (직접 값 모드) : 주소 필드(Operand) 자체가 명령어에 포함</p>
<ul>
<li>  자료의 표현 범위가 제한적임</li>
<li><code>MOV R1, #100;</code>   : 십진수 값 100이 두번째 오퍼랜드로 직접 명령문에 포함 됨</li>
</ul>
</li>
<li><p>레지스터 모드(Register Mode) : 주소 필드(Operand)가 레지스터에 저장됨</p>
<ul>
<li><code>ADD R1, R2;</code>  : 레지스터 R1, R2에 보유하고 값이 operand 임</li>
</ul>
</li>
<li><p>메모리 직접 주소 모드(Direct Mode) : 주소 필드(Operand)가 저장된 메모리 주소를 나타냄</p>
<ul>
<li><p><code>MOV R1, 100;</code> </p>
<p>  : R1에 100번지의 내용을 이동, 결국 100번지 내용이 두번째 오퍼랜드가 됨</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A7%81%EC%A0%91%EB%AA%A8%EB%93%9C.png" alt="출처: https://ehpub.co.kr/tag/%EB%AC%B5%EC%8B%9C%EC%A0%81-%EB%AA%A8%EB%93%9C/"></p>
</li>
</ul>
</li>
<li><p>메모리 간접 주소 모드(Indirect Mode) : 메모리를 이용하여 간접적으로 주소를 지정</p>
<ul>
<li><p><code>MOV R1, @100;</code></p>
<p>  : R1 $\leftarrow$ M[100]</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B0%84%EC%A0%91%EB%AA%A8%EB%93%9C%EC%98%88%EC%8B%9C.png"></p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EA%B0%84%EC%A0%91%EB%AA%A8%EB%93%9C.png" alt="출처: https://ehpub.co.kr/tag/%EB%AC%B5%EC%8B%9C%EC%A0%81-%EB%AA%A8%EB%93%9C/"></p>
</li>
</ul>
</li>
</ul>
<h4 id="주소-지정-모드-예시"><a href="#주소-지정-모드-예시" class="headerlink" title="주소 지정 모드 예시"></a>주소 지정 모드 예시</h4><p>각 모드의 역할을 알기 위해, 마이크로 명령을 수행시의 변화를 확인해보자!<br>(R1 = 100, R2 = 200 의 초기값을 가진다고 가정)</p>
<p> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A3%BC%EC%86%8C%EC%A7%80%EC%A0%95%EB%AA%A8%EB%93%9C%EC%98%88%EC%8B%9C.png"></p>
<h3 id="명령어-집합의-설계"><a href="#명령어-집합의-설계" class="headerlink" title="명령어 집합의 설계"></a>명령어 집합의 설계</h3><p>명령어 집합을 설계할 때 설계 관점에 따라 주의할 점이 달라짐</p>
<table>
<thead>
<tr>
<th align="center">설계 관점</th>
<th align="center">자연어에 가까운 명령 코드</th>
<th align="center">기계 중심의 명령 코드</th>
</tr>
</thead>
<tbody><tr>
<td align="center">프로그램의 관점</td>
<td align="center">프로그램이 용이<br/> 전체 프로그램의 길이 감소<br/> 번역기 설계 용이</td>
<td align="center">프로그래밍 규칙이 많아 짐<br/> 프로그램의 길이 증가<br/> 번역기의 설계가 복잡해짐</td>
</tr>
<tr>
<td align="center">CPU 구조 설계 측면</td>
<td align="center">사용 언어(한국어, 독일어)에 따른 구조적 차이로 인한 오동작 및 예외 처리가 어려움<br/> 명령어 길이 증가<br/> 제어장치(ALU, Register 등)의 제어가 매우 복잡해짐</td>
<td align="center">다양한 업체 별 국가별 프로그래밍의 표준화가 가능<br/> 명령어의 종류 및 길이 등 간편화 될 수 있음<br/> 제어장치(ALU, Register 등)의 <strong>제어가 용이</strong>해짐</td>
</tr>
</tbody></table>
<!-- 명령어 집합을 설계할 때 설계 관점에 따라 주의할 점이 달라진다.
* 프로그램의 관점 
1. 자연어에 가까울 수록 프로그램이 용이
2. 자연어에 가까울 수록 전체 프로그램의 길이 감소
3. 자연어에 가까울 수록 번역기 설계 용이
4. 기계 중심일 수록 프로그래밍 규칙이 많아 짐
5. 기계 중심일 수록 프로그램의 길이 증가
6. 기계 중심일 수록 번역기의 설계가 복잡해짐

* CPU 구조 설계 측면
1. 자연어에 가까울 수록 사용 언어에 따른 구조적 차이로 예외 처리가 어려움
2. 자연어에 가까울 수록 명령어 길이 증가
3. 자연어에 가까울 수록 제어장치의 제어가 복잡해진다.
4. 기계 중심일 수록 다양한 업체 별 국가별 프로그래밍의 표준화가 가능
5. 기계 중심일 수록 명령어의 종류 및 길이 등 간편화 될 수 있음
6. 기계 중심일 수록 제어장치의 제어가 용이해짐
 -->

<h3 id="현업에서-활용되는-명령어-비율"><a href="#현업에서-활용되는-명령어-비율" class="headerlink" title="현업에서 활용되는 명령어 비율"></a>현업에서 활용되는 명령어 비율</h3><table>
<thead>
<tr>
<th align="center">명령 코드</th>
<th align="center">실행 비율</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Load, Store, Move</td>
<td align="center">38% $\rightarrow$ 자료전송 명령어</td>
</tr>
<tr>
<td align="center">Compare, Add, And, Sub</td>
<td align="center">35% $\rightarrow$ 산술/논리 연산 명령어</td>
</tr>
<tr>
<td align="center">Condition blench, Call, Return</td>
<td align="center">22% $\rightarrow$ 실행제어 명령어</td>
</tr>
</tbody></table>
<blockquote>
<p>위의 명령어가, 전체 실행 명령어의 90% 이상<br>결론 : ALU, CPU의 구조를 개선하기 위해선, 역으로 저 명령어들에 대해 면밀히 알 필요가 있음</p>
</blockquote>
<h2 id="입출력-Input-Output-구성"><a href="#입출력-Input-Output-구성" class="headerlink" title="입출력(Input/Output) 구성"></a>입출력(Input/Output) 구성</h2><ul>
<li>* 외부 장치 : 컴퓨터가 사용자와 통신할 수 있게 해주는 장치 - 키보드, 모니터, 프린터 등<ul>
<li>입력장치(input-device) : 데이터와 명령어를 메모리로 읽어들임</li>
<li>출력장치(output-device) : 계산결과를 사용자에게 표시</li>
</ul>
</li>
</ul>
<p>간단히 단말장치(terminal device - 키보드, 프린터 등)의 입출력 구성을 알아보자!</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B5%AC%EC%84%B1.png"></p>
<ol>
<li>키보드 입력</li>
<li>-시리얼 통신 인터페이스$\rightarrow$ INPR (Input Register)</li>
<li>해당 레지스터의 값이 차면 FGI의 플래그 활성화 (0$\rightarrow$1)<ul>
<li>INPR의 값이 AC에서 처리될때까지 INPR을 불변</li>
</ul>
</li>
<li>-병렬전송$\rightarrow$ AC <ul>
<li>FGO 플래그가 0 이여야, AC에서 OUTR로 병렬전송 </li>
</ul>
</li>
<li>-병렬전송$\rightarrow$ OUTR (Output Register)<ul>
<li>여기서 병렬전송이란, 데이터 여러개가 한꺼번에 올라간다는 뜻! (12. 데이터의 종속성 - 병렬처리에서 이게 더 발전함)<blockquote>
<p>즉, 정보를 담는 Register 와 그 레지스터를 관리하는 제어 플립플롭(Flag 사용)으로 이루어졌고, 정보가 다니는 구조가, Serial과 parallel 로 됨</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="인터럽트-Interrupt"><a href="#인터럽트-Interrupt" class="headerlink" title="인터럽트(Interrupt)"></a>인터럽트(Interrupt)</h2><p><code>입출력(Input/Output) 구성</code>에서 설명한, <strong>프로그램 제어 전송(program controlled transfer)</strong> (=플래그를 사용한 통신 방법)은 프로세스와 입출력 장치와의 속도차이 때문에 비효율적이다.</p>
<p><em>컴퓨터 실행 속도</em>와 <em>입출력 장치 속도</em> 비교</p>
<ul>
<li><p>[조건1] 컴퓨터의 프로세스 처리 속도 : 10 us-fetch and excute cycle time</p>
</li>
<li><p>[조건2] 입출력 장치의 처리속도 : 10 문자/초</p>
</li>
<li><p>[결과] 입출력 속도 : 1문자 당 100,000 us (=0.1 sec) 의 시간이 소요 됨</p>
<blockquote>
<p>매 전송 시 입/출력 각각 5000번의 플래그 체크가 필요</p>
</blockquote>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%B4%88%EB%8B%A8%EC%9C%84.png" alt="참고 - 초단위"></p>
</li>
</ul>
<blockquote>
<p>따라서, 인터럽트라는 개념이 도입!!!</p>
</blockquote>
<h3 id="IEN"><a href="#IEN" class="headerlink" title="IEN"></a>IEN</h3><p>Interrupt Enable flip-flop </p>
<ul>
<li><p><strong>프로그램 제어 전송 대신 사용</strong></p>
<ul>
<li>외부 장치가 전송 준비가 되었을 경우 컴퓨터에 알릴 수 있는 플립플롭</li>
</ul>
</li>
<li><p>다른 점</p>
<p>: 프로그램 실행 도중 플래그를 체크 X</p>
<ol>
<li>플래그가 set (이걸 IEN이 알려줌)</li>
<li>즉시 실행 중이던 프로그램을 중지 (즉, Interrupt 걸림)</li>
<li>플래그의 set 정보를 받아 입출력을 실행</li>
<li>원 프로그램으로 복귀</li>
</ol>
</li>
</ul>
<h3 id="인터럽트-사이클-흐름도"><a href="#인터럽트-사이클-흐름도" class="headerlink" title="인터럽트 사이클 흐름도"></a>인터럽트 사이클 흐름도</h3><ul>
<li><p>인터럽트 사이클 흐름도<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/interrupt_cycle_flow_chart.png"></p>
<ul>
<li>R : 인터럽트 인에이블의 레지스터의 값 (1:참)</li>
<li>IEN : 인터럽트 인에이블 플립플롭</li>
<li>FGI : 제어 플립플롭의 flag bit(IN)</li>
<li>FGO : 제어플립플롭의 flag bit(OUT)</li>
</ul>
</li>
<li><p>인터럽트 전 후 메모리 상태 비교<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/interrupt_cycle_flow_chart_%EC%84%A4%EB%AA%85.png" alt="왼쪽 : 인터럽트 사이클 흐름도 설명, 오른쪽 : 인터럽트 전 후 메모리 상태 비교"></p>
<ul>
<li>  메모리 주소 255에 있는 명령이 실행 중 R=1이고 인터럽트가 발생</li>
<li>  현재 PC &lt;- 256 (복귀 주소)</li>
<li>  [before interrupt]에서와 같이 프로그래머는 입출력 서비스 프로그램을 주소 1120번지에 로드, 주소 1 &lt;- BUN 1120 로드</li>
<li>  [interrupt excute] M[0] &lt;- 256, PC &lt;- 1, R &lt;- 0 (clear)</li>
<li>  Execute M[1]은 1120번지로 분기하여 I/O program 실행</li>
<li>  ION instruction에 의해 IEN을 1로 세트하고 프로그램 복귀</li>
</ul>
</li>
</ul>
<h1 id="11-기본-컴퓨터-프로그래밍"><a href="#11-기본-컴퓨터-프로그래밍" class="headerlink" title="11. 기본 컴퓨터 프로그래밍"></a>11. 기본 컴퓨터 프로그래밍</h1><ul>
<li>컴퓨터 구성 : 하드웨어와 소프트웨어<ul>
<li>소프트웨어 : 하드웨어를 잘 동작 시킬 수 있도록 제어하고 지시하는 모든 종류의 프로그램</li>
</ul>
</li>
<li>소프트웨어 구분: 시스템 소프트웨어와 응용 소프트웨어</li>
</ul>
<h2 id="프로그램-종류"><a href="#프로그램-종류" class="headerlink" title="프로그램 종류"></a>프로그램 종류</h2><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%A2%85%EB%A5%98.png"></p>
<p>언어번역 프로그램 : 사용자 위주 프로그래밍 언어(고급언어)를 기계가 이해할 수 있는 언어(이진 프로그램으)로 옮기는 것</p>
<h2 id="프로그램처리과정"><a href="#프로그램처리과정" class="headerlink" title="프로그램처리과정"></a>프로그램처리과정</h2><ul>
<li>프로그램: 컴퓨터가 우리가 원하는 대로 데이터 처리 업무를 하도록 작성한 명령어 또는 문장으로 구성된 리스트<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%98%EB%A6%AC%EA%B3%BC%EC%A0%95.png" alt="프로그램처리과정"></li>
</ul>
<!-- 프로그래밍 언어 -->


<h2 id="프로그래밍-언어"><a href="#프로그래밍-언어" class="headerlink" title="프로그래밍 언어"></a>프로그래밍 언어</h2><h3 id="기계어"><a href="#기계어" class="headerlink" title="기계어"></a>기계어</h3><p>: 컴퓨터 내부, 이진 형태 (의미 파악 힘든 형태로 구성)</p>
<ul>
<li><p>종류</p>
<ul>
<li>이진 코드 : 메모리상에 나타나는 형태의 명령어로 이진수 명령어와 피연산자의 시퀀스</li>
<li>8/16 진수 : 이진수 코드를 편의상 8/16진수 형태로 표현</li>
<li>기호 코드 : 연산, 주소에 대해 기호(문자, 숫자, 특수 문자 등)를 사용함. 각 기호 명령어는 하나의 이진 코드로 번역됨(이것은 어셈블러가 담당)</li>
</ul>
</li>
<li><p>프로그래밍 언어간 관계 : 이진/16진 프로그램</p>
<table>
<thead>
<tr>
<th align="center">두 수를 가산하는 이진 프로그램</th>
<th align="center">$\rightarrow$</th>
<th align="center">두 수를 가산하는 16진 프로그램</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_%EC%9D%B4%EC%A7%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png"></td>
<td align="center"></td>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_16%EC%A7%84%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png"></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="어셈블리어"><a href="#어셈블리어" class="headerlink" title="어셈블리어"></a>어셈블리어</h3><p>: 마이크로 연산을 염두에 둠</p>
<ul>
<li><p>니모닉(mnemonic) : 기억하기 용이한 형태로 이름을 나타내는 기호, AND, ADD, LDA 등이 있음</p>
</li>
<li><p>어셈블리어의 언어 규칙</p>
<p> : 모든 컴퓨터는 각 어셈블리어를 가지고 있으며 해당 규칙들은 제조 업체로부터 출판됨</p>
<p> : 프로그래밍 언어는 일정한 규칙에 의해 정의되므로 해당 언어의 형식 규정을 잘 지켜야 함</p>
<ul>
<li>라벨 필드 : 기호 주소를 나타내거나 빈칸이 될 수 있음<ul>
<li>기호 주소는 세 개 이하의 영문/숫자들로 구성, 첫자는 문자</li>
</ul>
</li>
<li>명령어 필드 : 기계 명령어나 sudo 명령어를 기술<ul>
<li>  메모리 참조 명령어(MRI)</li>
<li>  레지스터 참조 또는 입출력 명령(non-MRI)</li>
<li>  sudo 명령어</li>
</ul>
</li>
<li>코멘트 필드 : 명령어에 대한 주석 혹은 해설 하는 곳 (불필요한 경우 생략 가능)</li>
</ul>
</li>
<li><p>프로그래밍 언어간 관계 예시 : 기호연산/어셈블리어 프로그램</p>
<p>  마이크로 연산의 결과들</p>
<table>
<thead>
<tr>
<th align="center">기호연산 코드를 가진 프로그램</th>
<th align="center">$\rightarrow$</th>
<th align="center">두 수를 가산하는 어셈블리언어 프로그램</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_%EA%B8%B0%ED%98%B8%EC%97%B0%EC%82%B0%EC%BD%94%EB%93%9C%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png"></td>
<td align="center"></td>
<td align="center"><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%96%B8%EC%96%B4%EA%B0%84%EA%B4%80%EA%B3%84_%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B8%EC%96%B4%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8.png"></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="고급언어-High-level-Language"><a href="#고급언어-High-level-Language" class="headerlink" title="고급언어(High level Language)"></a>고급언어(High level Language)</h3><p>: 프로그래머 사용 언어, 영자 숫자 형태</p>
<ul>
<li><p>목적 : 편리성, 하드웨어와 소프트웨어의 독립성 보장</p>
<ul>
<li>즉, 컴퓨터 하드웨어의 동작을 염두하지 않고 문제 해결의 관점에 맞춰 개발한 것</li>
</ul>
</li>
<li><p>종류 : </p>
<ul>
<li><p>Compile Language : C, C++, C#, Java </p>
<ul>
<li>Code -한번에$\rightarrow$ Compile $\rightarrow$ Binary</li>
<li>전체 소스코드 번역에는 시간이 소요되지만, 전체 실행 시간이 빠름</li>
<li>번역 후에 오류를 알려줌, 디버깅 어려움</li>
</ul>
</li>
<li><p>Interpreted Language : Python, Ruby, Perl, PHP, JavaScript</p>
<ul>
<li>한줄 번역하여 실행</li>
<li>소스코드 한줄 한줄 번역하기 때문에 적은 시간 소요, 전체 실행 시간이 비교적 느림</li>
<li>사용수정 및 디버깅 쉬움    </li>
</ul>
</li>
</ul>
</li>
<li><p>예시 : C언어 프로그램</p>
<p>  두 수를 가산하는 C언어 프로그램</p>
<pre><code class="c"># include &lt;stdio.h&gt;
# include &lt;conio.h&gt;

Void main()
&#123;
    int a,b,c;
    a = 83, b = -23;
    c = a + b;
    // printf(&quot; a + b = %d&quot;, c);
&#125;
</code></pre>
</li>
</ul>
<h2 id="프로그래밍-언어의-실행"><a href="#프로그래밍-언어의-실행" class="headerlink" title="프로그래밍 언어의 실행"></a>프로그래밍 언어의 실행</h2><ul>
<li><p>프로그램 처리과정</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%B2%98%EB%A6%AC%EA%B3%BC%EC%A0%952.png"></p>
<ul>
<li><p>문제중심이란?  하드웨어에 대한 생각을 안하는 것</p>
<p>  내가 어떤 컴퓨터를 쓰고 있는지, 어떤계열의 CPU (ARM, Intel 등)를 사용하고 있는지 (각 업체마다 자기만의 룰을 갖고 있음)</p>
</li>
</ul>
</li>
</ul>
<h3 id="프로그래밍의-구현-architecture"><a href="#프로그래밍의-구현-architecture" class="headerlink" title="프로그래밍의 구현 architecture"></a>프로그래밍의 구현 architecture</h3><ul>
<li><p>소프트웨어 위기 현상 (1960~1970) <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EC%9C%84%EA%B8%B0">자세히</a></p>
</li>
<li><p>소프트웨어 개발 패러다임<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EA%B0%9C%EB%B0%9C%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84.png"></p>
</li>
<li><p>파이프라인처리, 병렬처리 등</p>
<h3 id="컴퓨터-네트워크-환경"><a href="#컴퓨터-네트워크-환경" class="headerlink" title="컴퓨터 네트워크 환경"></a>컴퓨터 네트워크 환경</h3></li>
<li><p>Wireshark 를 이용한 패킷 분석</p>
<ul>
<li><p>Explorer(Internet web borowser 중 하나) 가 운영체제의 한 축을 담당하게 된 순간 부터 컴퓨터는 통신기계로 분류 됨</p>
<ul>
<li>Explorer 가 Windows의 NOS(New technology Operating System) 로 들어가게되면서</li>
</ul>
</li>
<li><p>통신기계로서의 hexadecimal 표현(=기계어)은 더욱 더 그 진가를 발휘</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/capturing_from_Wi-Fi.png"></p>
<ul>
<li><p>패킷 : 통신을 할 때, 묶여져서 나가는 단위</p>
</li>
<li><p>프로토콜 : TCP, UDP 등 어떤 경로인지</p>
<ul>
<li>TCP : shake hand 라 해서 서로 주고 받는거</li>
<li>UDP : 걍 무조건 뿌리는 거 (메일의 특징)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.wireshark.org/download.html">패킷 분석 툴, 와이어 샤크(WireShark) Download</a></p>
<!-- 나중에 해보기!

## 직접 확인해보기

Dev C++, Diassembler 를 사용해서 직접 확인해보자!

0. 필요 툴 다운로드
   - compiler : Dev C++ (고급언어 프로그래밍 툴)
       
       https://sourceforge.net/projects/orwelldevcpp/

   - Disassembler(고급 언어로 작성 된 소스를 어셈블리어 언어로 확인 가능한 툴)
       
       https://sourceforge.net/projects/x64dbg/files/latest/download

1. 코드작성 - .cpp 소스파일
    ```c
    # include <stdio.h>
    # include <conio.h>

    Void main()
    {
        int a,b,c;
        a = 83, b = 234;
        c = a + b;
        printf(" a + b = %5.2d", c);

        return 0;
    }
    ```
2. 컴파일 (실행프로그램 생성)
3. 실행화면

4. Disassembler 툴로 실행프로그램이 어떻게 생겼는지 확인
   - .../release/x64/x64dbg -->

<h1 id="12-Pipeline-과-벡터처리"><a href="#12-Pipeline-과-벡터처리" class="headerlink" title="12. Pipeline 과 벡터처리"></a>12. Pipeline 과 벡터처리</h1><p>데이터의 종속성에 대해 알아보자</p>
<p>파이프라인과 벡터처리에 대해 알아보자</p>
<h2 id="병렬-처리"><a href="#병렬-처리" class="headerlink" title="병렬 처리"></a>병렬 처리</h2><p>parallel processing은 컴퓨터 시스템의 계산 속도 향상을 목적으로 하여 동시 데이터 처리기능을 제공하는 광범위한 개념의 기술을 의미한다.</p>
<h3 id="복잡도에-따른-구분"><a href="#복잡도에-따른-구분" class="headerlink" title="복잡도에 따른 구분"></a>복잡도에 따른 구분</h3><p>복잡도에 따른 병렬 처리의 다양한 단계를 구분하면 다음과 같다</p>
<ul>
<li>사용 레지스터의 형태에 따른 병렬성 구현<ul>
<li> 예시 : 시프트 레지스터 vs 워드당 동시에 전송이 가능한 <em>병렬성을 갖는 레지스터</em> (입출력(Input/Output) 구성에 나와있는 병렬처리)</li>
</ul>
</li>
<li>동일한 또는 서로 다른 동작을 동시에 수행하는 여러 개의 기능 장치(Fuctional unit)를 가지고 데이터를 각각 장치에 분산시켜 작업 수행<ul>
<li>  예시 : 산술, 논리, 시프트 동작을 세 개의 장치로 분류하고, 제어장치의 관리에 따라 피연산자를 각 장치들 사이에서 전환시킴</li>
</ul>
</li>
</ul>
<h3 id="다중-기능-장치-예시"><a href="#다중-기능-장치-예시" class="headerlink" title="다중 기능 장치 예시"></a>다중 기능 장치 예시</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A4%EC%A4%91%EA%B8%B0%EB%8A%A5%EC%9E%A5%EC%B9%98%EC%98%88.png"></p>
<blockquote>
<p>하지만 각 기능이 시리얼하게 연산이 필요한 경우 대기 필요</p>
</blockquote>
<h3 id="M-J-Flynn의-분류"><a href="#M-J-Flynn의-분류" class="headerlink" title="M.J Flynn의 분류"></a>M.J Flynn의 분류</h3><p>동시에 처리되는 명령어와 데이터 항목 수에 의해 컴퓨터 시스템의 구조를 파악하려는 분류 방법을 제안 </p>
<ul>
<li>I : instruction stream<ul>
<li>명령어 흐름 = 메모리로 부터 읽어온 명령어의 순서</li>
</ul>
</li>
<li>D : data stream<ul>
<li>데이터 흐름 = 데이터에 대해 수행 되는 동작</li>
</ul>
</li>
<li>S : single / M : Multiple</li>
</ul>
<ul>
<li>SISD : 단일 명령어 흐름, 단일 데이터 흐름<ul>
<li>  제어장치, 처리장치, 메모리 장치를 가지는 <strong>단일 컴퓨터 구조</strong></li>
<li>  명령어들은 순차적으로 실행되고, 병렬처리는 다중 기능 장치나 <strong>파이프라인 처리에 의하여 구현</strong>됨</li>
</ul>
</li>
<li>SIMD : 단일 명령어 흐름, 다중 데이터 흐름<ul>
<li>  공통의 제어장치 아래에 <strong>여러 개의 처리 장치</strong>를 두는 구조</li>
<li>  모든 프로세서는 동일한 명령어를 서로 다른 데이터 항목에 대하여 실행 시킬 수 있음</li>
<li>  모든 프로세서가 <strong>동시에 메모리에 접근</strong> 할 수 있도록 <em>다중 모듈을 가진 공유 메모리 장치</em>가 필요</li>
</ul>
</li>
<li>MISD : 다중 명령어 흐름, 단일 데이터 흐름<ul>
<li>  이론적으로만 연구 되고 있음</li>
</ul>
</li>
<li>MIMD : 다중 명령어 흐름, 다중 데이터 흐름<ul>
<li>여러 프로그램을 동시에 수행하는 능력을 가진 컴퓨터 시스템</li>
<li>대부분의 다중 프로세서와 다중 컴퓨터 시스템이 이 범주에 속함</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>외양적 행동 양식을 강조한 분류 방식</code>으로 파이프라인은 예외</p>
</blockquote>
<h2 id="Pipeline-구조의-성능"><a href="#Pipeline-구조의-성능" class="headerlink" title="Pipeline 구조의 성능"></a>Pipeline 구조의 성능</h2><p>파이프라인 구조란</p>
<ul>
<li>프로세스를 갔다가 세그먼트 단위로 나누고, 타임펄스를 주면서, 가능한한 리소스(유효시간)가 없도록 타이트하게 프로세스를 세그먼트로 진행시킴</li>
</ul>
<p>파이프라인의 동작은 공간/시간표에 의해 설명되는데 이것은 시간에 대한 함수로서 세그먼트의 사용 상황을 보여준다.</p>
<ul>
<li><p>$t_p$ (클럭 사이클 시간), k개의 세그먼트 파이프 라인에서 n개의 task를 수행하는 경우</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EC%8B%9C%EA%B0%84%EA%B3%B5%EA%B0%84%ED%91%9C.png"></p>
<ul>
<li><p>$kt_p$ : $T_1$(첫번째 task) 동작을 완료하기 위해 필요한 시간</p>
</li>
<li><p>(n-1)$t_p$ : 나머지 (n-1) task의 소요시간</p>
</li>
<li><p>즉, n개의 task를 k 개의 세그먼트 파이프라인에서 완료하려면 걸리는 총시간은 다음과 같음</p>
<p>  $=kt_p + (n-1)t_p$<br>  $=(k + (n-1))t_p$<br>  이므로,  </p>
<blockquote>
<p><strong>$k + (n-1)$클럭 사이클</strong>을 한다는 사실을 알 수 있음</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="비-파이프라인의-경우"><a href="#비-파이프라인의-경우" class="headerlink" title="비 파이프라인의 경우"></a>비 파이프라인의 경우</h3><ul>
<li><p>각 Task를 완료하기 위한 시간 : $t_n$</p>
</li>
<li><p>n Task에 대한 전체 수행시간 : $nt_n$</p>
</li>
<li><p>파이프라인 처리에 따른 속도의 증가율</p>
<ul>
<li><p>Task가 무한이 많아진다 가정 하면</p>
<p>: ($k + n - 1 \rightarrow n$)</p>
<ul>
<li>$S=\frac{nt_n}{(k+n-1)t_p}$ $\rightarrow$ $S\approx \frac{nt_n}{nt_p}, S = \frac{t_n}{t_p}$</li>
</ul>
</li>
<li><p>$t_n = kt_p$  </p>
<p>: 비 파이프라인에서 한 Task 수행 시간</p>
<p>$S= \frac{kt_p}{t_p} = k$</p>
<blockquote>
<p><strong>파이프라인의 이론적 최대 속도 증가율은 세그먼트 수와 같음</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Pipeline-구현"><a href="#Pipeline-구현" class="headerlink" title="Pipeline 구현"></a>Pipeline 구현</h2><ul>
<li><p>하나의 프로세스를 서로 다른 기능(Function)을 가진 여러 개의 서브프로세스(Subprocess)로 나누어 각 프로세스가 동시에 서로 다른 데이터를 취급하도록 하는 기법</p>
</li>
<li><p>각 세그먼트(segment)에서 수행된 연산 결과는 다음 세그먼트로 연속적으로 넘어가고, 데이터가 마지막 세그먼트를 통과하게 되면 최종 연산 결과를 얻게 됨</p>
<ul>
<li>각 세그먼트에 존재하는 레지스터가 하나의 프로세스를 다양한 연산으로 중복 시킬 수 있게 함<ul>
<li>레지스터에 Clock pulse 라는 signal을 줌</li>
<li>signal을 받은 레지스터는 기억하고있는 정보를 그 다음 레지스터로 전달 = 다음 프로세스로 넘어갈 수 있음</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="파이프-라인-구현-예제"><a href="#파이프-라인-구현-예제" class="headerlink" title="파이프 라인 구현 예제"></a>파이프 라인 구현 예제</h3><ul>
<li><p>파이프 라인 처리 예</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EC%B2%98%EB%A6%AC%EC%98%88%EC%A0%9C.png"></p>
<ul>
<li>Segment 1 : 기억장치에 있는 데이터(여기선 $A_i$, $B_i$)를 가져다가 R1, R2에 Load</li>
<li>Segment 2 : $A_i$ 와 $B_i$를 곱하고 R3 레지스터에 넣음, 동시에 $C_i$를 R4에 Load</li>
<li>Segment 3 : R3, R4의 값을 더해서 R5에 넣음</li>
</ul>
</li>
</ul>
<ul>
<li><p>파이프 라인 구현 예</p>
<p>  <em>곱셈과 덧셈이 섞여있는 다항식 연산</em>을 파이프라인으로 구현해보자.</p>
<ul>
<li><p>i는 1~7 즉, 7개의 signal pulse를 가짐<br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EA%B5%AC%ED%98%84%EC%98%88%EC%A0%9C1_1.png"></p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_%EA%B5%AC%ED%98%84%EC%98%88%EC%A0%9C1_2.png"></p>
</li>
</ul>
</li>
</ul>
<h2 id="Pipeline-고찰"><a href="#Pipeline-고찰" class="headerlink" title="Pipeline 고찰"></a>Pipeline 고찰</h2><p>파이프라인이 무조건 좋을까?</p>
<p>적용시키기 위한 준비와 문제점에 대해 알아보자!</p>
<ul>
<li><p>동일한 복잡도의 부 연산들로 나뉘어지는 어떠한 연산 동작도 파이프 라인 프로세서에 의해 구현될 수 있다. </p>
<ul>
<li>비슷한 업무량/업무강도에 대해 효율적</li>
<li>한 segment의 시간이 오래걸린다면, 거기에 속도를 맞춰야하기 때문에 유효리소스가 발생 = 비효과적</li>
</ul>
</li>
<li><p>파이프라인 기술은 매번 다른 데이터 집합을 동일한 Task에 적용시켜 여러 번 반복하는 응용에 효과적이다.</p>
<ul>
<li>예시 : 인공지능, 딥러닝이 파이프라인 구조에 적합한 업무</li>
</ul>
</li>
</ul>
<h3 id="4-세그먼트-파이프-라인"><a href="#4-세그먼트-파이프-라인" class="headerlink" title="4 세그먼트 파이프 라인"></a>4 세그먼트 파이프 라인</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%84%A4_%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8_%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8.png"></p>
<h3 id="S-frac-kt-p-t-p-k"><a href="#S-frac-kt-p-t-p-k" class="headerlink" title="$S=\frac{kt_p}{t_p}=k$"></a>$S=\frac{kt_p}{t_p}=k$</h3><p>파이프라인의 이론적 최대속도 증가율은 세그먼트 수와 같다.</p>
<ul>
<li><p>[sample]</p>
<ul>
<li><p>각 세그먼트에서 부연산을 수행하는데 소요 되는 시간 : $t_p$ = 20 $ns$</p>
</li>
<li><p>파이프라인은 $k = 4$ 세그먼트로 구성</p>
</li>
<li><p>Task의 수 : $n=100$ 이라고 할 경우</p>
<blockquote>
<p>$\rightarrow$ 파이프라인 구조를 활용시의 총 소요시간 : $(K+n-1)t_p=(4+100-1)\times 20=2060ns$</p>
</blockquote>
<blockquote>
<p>$\rightarrow$ 비 파이프라인 시스템의 소요시간 </p>
</blockquote>
<ul>
<li><p>각 Task의 완료 시간 : $t_n$ = $kt_p$ = 4 \times 20 = 80 $ns$</p>
</li>
<li><p>전체 Task의 완료 시간 : $nkt_p$ = 100 \times 80 = 8000 $ns$</p>
<blockquote>
<p>$\rightarrow$ 속도 증가율 $\frac{8000}{2060}=3.88 \eqsim 4$</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>이론은 위와 같지만, 실제로는 그 속도까진 도달 못함</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="현실적-파이프라인-구조"><a href="#현실적-파이프라인-구조" class="headerlink" title="현실적 파이프라인 구조"></a>현실적 파이프라인 구조</h3><p>실제 파이프라인 구조가 이론적인 최대 속도를 구현하지 못하는 이유</p>
<ul>
<li>  각 세그먼트들이 부 연산을 수행하는 시간이 서로 다름</li>
<li>  <strong>클럭 사이클</strong>(각 레지스터를 제어함)은 <strong>최대 전파시간을 갖는 세그먼트의 지연시간과 싱크 맞춰야함</strong></li>
</ul>
<h4 id="해결법-병렬적-다중-기능장치"><a href="#해결법-병렬적-다중-기능장치" class="headerlink" title="해결법 : 병렬적 다중 기능장치"></a>해결법 : 병렬적 다중 기능장치</h4><p><code>병렬적인 다중 기능 장치 = 파이프라인 처리 속도</code> 로 가정!</p>
<ul>
<li><p>조건 : 각 P회로는 전체 파이프라인 회로에서와 동일하게 Task를 수행</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%91%EB%A0%AC%EC%A0%81%EC%9D%B8%EB%8B%A4%EC%A4%91%EA%B8%B0%EB%8A%A5%EC%9E%A5%EC%B9%98.png"></p>
</li>
<li><p>주의사항! 이 구조는 순차적 처리가 아님</p>
<ul>
<li>즉, 모든 회로가 동시에 데이터를 입력 받아 네 태스크를 한꺼번에 수행함 (SIMD 구조)</li>
</ul>
</li>
</ul>
<blockquote>
<p>파이프라인 구조 &gt; 순차적 처리 구조</p>
</blockquote>
<h2 id="Pipeline-종류"><a href="#Pipeline-종류" class="headerlink" title="Pipeline 종류"></a>Pipeline 종류</h2><p>파이프 라인 구조가 적용되는 컴퓨터 설계는 크게 두가지가 있음 (이것저것 해본결과 아래 두개가 효과적)</p>
<ul>
<li><p>산술 파이프라인 : 산술 연산을 부 연산들로 나누어 파이프라인의 세그먼트에서 수행</p>
<ul>
<li>왜 필요할까?<ul>
<li> 고속 컴퓨터에서 부동 소수점 연산, 고정 소수점 수의 곱셈 등에 활용</li>
</ul>
<ul>
<li> 파이프라인 승산기(배열 승산기 - 부분 곱 사이의 carry 전파시간의 최소화를 위한 가산기를 보유)</li>
</ul>
</li>
</ul>
</li>
<li><p>명령어 파이프라인 : 명령어 사이클의 fetch, decode, 실행 단계를 중첩시켜 명령어 흐름에 동작</p>
<h3 id="Arithmetic-Pipeline"><a href="#Arithmetic-Pipeline" class="headerlink" title="Arithmetic Pipeline"></a>Arithmetic Pipeline</h3></li>
</ul>
<h4 id="부동-소수점-덧셈과-뺄셈을-위한-파이프라인"><a href="#부동-소수점-덧셈과-뺄셈을-위한-파이프라인" class="headerlink" title="부동 소수점 덧셈과 뺄셈을 위한 파이프라인"></a>부동 소수점 덧셈과 뺄셈을 위한 파이프라인</h4><ul>
<li>입력 : 두 개의 정규화(nomalized)된 부동 소수점(실수) 이진수<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%EC%9D%B4%EC%A7%84%EC%88%98%EC%9E%85%EB%A0%A5.png"></li>
</ul>
<ul>
<li><p>각 세그먼트에서 수행되는 부 연산</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%82%B0%EC%88%A0%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_flowchart.png" alt="산술 파이프라인의 Flow Chart"></p>
<ol>
<li> 지수의 비교 (compare exponents by subtraction)</li>
<li> 가수의 정렬 (Choose exponents, Align mantissas)</li>
<li> 가수의 덧셈/뺄셈 (Add or subtrackt mantissas)</li>
<li> 결과의 정규화 (Adjust exponents, Nomalized result)</li>
</ol>
</li>
</ul>
<blockquote>
<p>총 소요시간 기준으로 (비 파이프라인에 비해) 320/110 = 2.9 배의 효과를 볼 수 있다</p>
</blockquote>
<h4 id="산술-파이프라인의-효율성"><a href="#산술-파이프라인의-효율성" class="headerlink" title="산술 파이프라인의 효율성"></a>산술 파이프라인의 효율성</h4><ul>
<li><p>부동 소수점 파이프라인의 구성 요소</p>
<ul>
<li><p>비교기, 시프터, 가산$\cdot$감산기, 인크리멘터, 디크리멘터 $\rightarrow$ 조합회로</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98_%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Instruction-Pipeline"><a href="#Instruction-Pipeline" class="headerlink" title="Instruction Pipeline"></a>Instruction Pipeline</h3><p>명령어 실행과 파이프라인 구조</p>
<ul>
<li><p>이전 명령어가 다른 세그먼트에서 실행되고 있는 동안 메모리에 연속적으로 저장되어 있는 다음 명령어를 읽어 옴으로써 <strong>fetch와 실행이 중첩되어 동시에 수행</strong>되는 구조</p>
</li>
<li><p>분기가 발생 할 경우(가장 큰 취약점) - 현재 파이프라인은 모두 비워져야 하고, 분기명령 이후 메모리에서 읽어온 명령어는 모두 무시되어야함</p>
<ul>
<li><p>4 세그먼트 명령어 파이프라인의 예 1</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%EB%AA%85%EB%A0%B9%EC%96%B4%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98%EC%98%88_%EB%AA%85%EB%A0%B9%EC%96%B4%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98_%EC%8B%9C%EA%B0%84%EA%B4%80%EA%B3%84.png" alt="4 세그먼트 명령어 파이프라인의 예 - 명령어 파이프라인의 시간관계"></p>
<ol>
<li>FI는 명령어 fetch하는 세그먼트</li>
<li>DA는 명령어를 디코드하고 유효주소를 계산하는 세그먼트</li>
<li>FO는 피연산자를 Fetch 하는 세그먼트</li>
<li>EX는 명령어를 실행하는 세그먼트</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="효율적-명령어-실행을-위한-파이프라인-구조"><a href="#효율적-명령어-실행을-위한-파이프라인-구조" class="headerlink" title="효율적 명령어 실행을 위한 파이프라인 구조"></a>효율적 명령어 실행을 위한 파이프라인 구조</h4><ul>
<li><p>장치를 둘(명령어 fetch 장치, 명령어 실행장치)로 나눔. 즉, 두 세그먼트 파이프라인을 구성하는 컴퓨터를 고려</p>
<ul>
<li>명령어 fetch 장치 $\rightarrow$ FIFO에 의한 Queue로 구성되어 queuing 기법에 의한 메모리 참조에 의해 평균 메모리 접근 시간을 효과적으로 줄여 줌</li>
</ul>
</li>
<li><p>명령어 파이프라인 수행 시 애로사항</p>
<ul>
<li>세그먼트 수행 시간이 서로 다름 (실행되지 않는 세그먼트도 있을 수 있음)<ul>
<li>  예시 : 오퍼랜드에 있는거 대입과 같이, 레지스터 모드 명령의 경우, 유효주소 계산이 불필요하고 수행시간이 완전 달라짐</li>
</ul>
</li>
<li>  두 개 이상의 세그먼트에 의해 동일한 주소 공간이 참조되는 경우</li>
</ul>
</li>
<li><p>4 세그먼트 명령어 파이프라인의 예 2<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%EB%AA%85%EB%A0%B9%EC%96%B4%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9D%98%EC%98%88_%EC%88%9C%EC%84%9C%EB%8F%84.png" alt="4 세그먼트 명령어 파이프라인의 예 - 순서도"></p>
</li>
</ul>
<h2 id="Pipeline-분기-예측"><a href="#Pipeline-분기-예측" class="headerlink" title="Pipeline 분기 예측"></a>Pipeline 분기 예측</h2><ul>
<li>필요성<ul>
<li>다음 실행될 명령어의 분기방향과 분기목적지예측을 통해 명령어를 미리 실행하여 파이프라인 <strong>효율성</strong>을 확보</li>
<li>파이프라인 프로세서에서 제어 해저드로 인한 <strong>Stall 발생 시</strong> 분기예측은 항상 필요<ul>
<li>파이프라인 제어 해저드 <a target="_blank" rel="noopener" href="http://blog.skby.net/%ed%8c%8c%ec%9d%b4%ed%94%84%eb%9d%bc%ec%9d%b8-%ed%95%b4%ec%a0%80%eb%93%9c-%eb%b0%8f-%ed%95%b4%ea%b2%b0%eb%b0%a9%ec%95%88/">참고 : 파이프라인 해저드 및 해결방안</a><br>  : 파이프라인 명령어의 실행 순서를 변경하는 Branch, Jump 등 명령어 분기가 발생하면서 <strong>명령이 실행이 지연, 중지 되는 현상</strong> (<strong>병렬처리 성능 저하</strong> 요소)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>분기 예측 (Branch prediction) 정의</p>
<ul>
<li>파이프라인을 통한 명령 실행 중 조건 분기 명령의 실행이 종료될 때까지 다음 명령을 대기하지 않고 분기를 예측 실행하여 파이프라인 처리 성능 저하를 최소화하는 CPU 실행 기술</li>
<li>다음 실행될 조건문이 어떤 곳으로 분기할 것인지를 확실히 알게 되기 전에 미리 추측하여 실행하여 파이프라인 효율성 확보</li>
</ul>
</li>
<li><p>방법 (2가지) <a target="_blank" rel="noopener" href="http://blog.skby.net/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EB%B6%84%EA%B8%B0%EC%98%88%EC%B8%A1%EA%B3%BC-%EC%98%88%EC%B8%A1%EC%8B%A4%ED%96%89/">참고 : 파이프라인 분기예측과 예측실행</a>  </p>
<ul>
<li>분기방향예측</li>
<li>분기목적지예측</li>
</ul>
</li>
</ul>
<h3 id="Instruction-Pipeline-오작동-요인"><a href="#Instruction-Pipeline-오작동-요인" class="headerlink" title="Instruction Pipeline 오작동 요인"></a>Instruction Pipeline 오작동 요인</h3><ul>
<li>자원 충돌(Resource Conflict) : 두 세그먼트가 동시에 메모리를 접근할 때 발생    $\rightarrow$ <strong>명령어 메모리와 데이터 메모리를 분리함</strong>으로써 대부분 해결</li>
<li>데이터 의존성(Data Dependency) : 충돌은 어떤 명령어가 이전 명령어의 결과에 의존하여 수행되는데 그 값이 아직 준비되지 않은 경우에 발생</li>
<li>분기 곤란(Banch Difficulty) : 분기 명령어 같이 PC의 값을 변경 시키려는 명령어에 의해 발생</li>
</ul>
<h4 id="데이터-의존성-Data-Dependency"><a href="#데이터-의존성-Data-Dependency" class="headerlink" title="데이터 의존성 (Data Dependency)"></a>데이터 의존성 (Data Dependency)</h4><p>데이터나 주소의 충돌은 명령어 파이프라인의 성능을 저하시키는 요인</p>
<ul>
<li>데이터 의존성 : 아직 준비되지 않은 데이터를 기다리는 경우  <ul>
<li>예시 : FO에 의해 피연산자를 fetch하려는데, 아직 EX 세그먼트에 의해 데이터가 만들어지지 않은 경우</li>
</ul>
</li>
<li>주소 의존성 : 마이크로 연산 시 레지스터 간접모드를 사용하는 명령어는 이전 명령어가 주소값을 메모리로 부터 로드하는 명령어라면 곧바로 피연산자를 fetch하지 못하고 기다림<ul>
<li>예시 : 연산 후 뒤에 오는 값이 주소인데, 그 주소안에 또 다른 주소가 들어있을 경우 기다려야함</li>
</ul>
</li>
</ul>
<h5 id="데이터-의존성-해결-방법"><a href="#데이터-의존성-해결-방법" class="headerlink" title="데이터 의존성 해결 방법"></a>데이터 의존성 해결 방법</h5><ul>
<li>Hardware interlock : 어떤 명령어의 피 연산자가 파이프라인에 앞서간 명령어의 목적지와 일치하는지 검사하는 회로  $\rightarrow$ 이러한 상황이 감지되면 피연산자가 준비되지 않은 명령어는 충돌을 피할 수 있을 만큼 충분한 사이클을 두어 지연 시킴</li>
<li>Operand forwarding : 충돌을 감지하는 경우 특별한 통로를 통해 직접 파이프라인 세그먼트에 전달하는 경우</li>
</ul>
<h3 id="분기-명령어-처리"><a href="#분기-명령어-처리" class="headerlink" title="분기 명령어 처리"></a>분기 명령어 처리</h3><p>조건 분기 또는 무조건 분기 $\rightarrow$ (처리 여하에 따라) 파이프라인의 정상적인 프로그램 순서를 바꿈</p>
<p>따라서, 조건 분기 또는 무조건 분기는 파이프라인 시스템에서 컴퓨터의 성능을 저하시키는 주 요인으로 간주됨</p>
<blockquote>
<p>분기 명령어 처리 법</p>
</blockquote>
<ol>
<li><p>순차적으로 처리될 명령어를 분기의 목표가 되는 명령어와 <strong>함께 저장</strong>하는 방법</p>
</li>
<li><p>분기 목표 버퍼(branch target buffer, BTB)의 사용 </p>
<p> : fetch 세그먼트에 속해 있는 associative memory</p>
<p> : <strong>이전에 실행된 분기 명령어</strong>와 <strong>분기 목표 명령어</strong>를 <strong>저장</strong>하여 활용 (loop buffer - 일종의 레지스터) </p>
<p> 즉, 색인레이어의 컨셉</p>
<ul>
<li>associative memory : 주소가 아닌 내용에 의해 검색(참조)이/가 가능한 기억장치</li>
</ul>
</li>
</ol>
<h4 id="분기-예측-branch-prediction"><a href="#분기-예측-branch-prediction" class="headerlink" title="분기 예측(branch prediction)"></a>분기 예측(branch prediction)</h4><ul>
<li><p>실제 다양한 프로그램의 실행결과를 분석한 결과, 참조의 시간적 지역성과 유사하게 일부 명령어들은 반복 수행되며, 반복 실행시에는 규칙성을 가짐</p>
<ul>
<li>마이크로 연산에서 자주쓰이는 명령어는 정해져 있음 (Load, Add 등….)</li>
<li>마찬가지로 분기 명령도 비교적 반복되어 쓰이는 명령들이 정해져 있음</li>
</ul>
</li>
<li><p>이 때, 분기 및 적재 명령어가 참조하는 오퍼랜드도 규칙성을 가지며, 이를 이용할 경우 명령어 fetch 과정에서 신속하게 오퍼랜드의 제공하므로 fetch 가 수월해짐</p>
<ul>
<li>단, 예측실패시 패널티(시간 지연) 발생</li>
</ul>
</li>
</ul>
<h2 id="RISC-Processor"><a href="#RISC-Processor" class="headerlink" title="RISC Processor"></a>RISC Processor</h2><details>
  <summary style="font-Weight : bold; font-size : 11px; color : #CCCCCC;" > MPU - CISC, RISC 복습 </summary>
  <div>  
  MPU(Micro Processor Unit)
  
  - CPU를 LSI(고밀도 집적회로)화 한 일종의 통합장치
  - 분류 (2가지)
    *   CISC (Complex Instruction Set Computer)
        *   반복적이고 동일한 명령을 하드웨어 처리로 함
        *   하드웨어가 빈약해도, 소프트웨어로 처리해줌
    *   RISC (Reduced Instruction Set Computer)
        *   CISC 반대 개념
        *   명령어를 간단히하여 시스템도 간단히
        *   파이프라인과 찰떡 궁합
  - Bit Slice MPU 등 존재
  </div>
</details>

<ul>
<li><p>설계 목표</p>
<ul>
<li>실행 명령어 수는 증가하더라도 작업 처리 시간의 감소가 가능</li>
<li>명령어당 실행 클락 수(CPI)와 클록 주기를 파이프라인 구조를 이용하여 감소 가능<ul>
<li>명령어가 늘어나도, 클락 수를 줄일 수 있음 (파이프라인을 이용해서 클락주기를 최대한으로 줄이기 때문)</li>
<li>즉, RISC는 파이프라인에 접목시키기 아주 좋은 형태</li>
</ul>
</li>
</ul>
</li>
<li><p>구조적 특징</p>
<ul>
<li>명령어의 1 사이클 실행을 위한 파이프라인 구조, 메모리 참조를 위한 온칩 캐시(CPU내 메모리 구현, 명령어 캐쉬, 자료 캐쉬로 구성)</li>
<li>간단한 명령 코드와 주소 지정 모드 및 하드웨어적 제어장치</li>
<li>신속한 오퍼랜드 참조/문맥 전환을 위한 레지스터의 집합 (중첩된 레지스터 윈도우)<ul>
<li>파이프라인도 마찬가지로 중첩된 구조이므로, RISC와 잘맞음</li>
</ul>
</li>
<li>실수 연산을 위한 Co-processor</li>
</ul>
</li>
</ul>
<h3 id="RISC-파이프라인"><a href="#RISC-파이프라인" class="headerlink" title="RISC 파이프라인"></a>RISC 파이프라인</h3><p>명령어 사이클은 세 개의 부연산으로 나뉘어 다음과 같은 세 세그먼트로 구성된다.</p>
<ul>
<li><p>I : 명령어의 fetch</p>
</li>
<li><p>A : ALU의 동작</p>
</li>
<li><p>E : 명령어의 실행</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RISC%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8.png" alt="RISC파이프라인"></p>
</li>
</ul>
<h2 id="파이프라인-CPU-성능-향상을-위해-고려할-사항"><a href="#파이프라인-CPU-성능-향상을-위해-고려할-사항" class="headerlink" title="파이프라인 CPU 성능 향상을 위해 고려할 사항"></a>파이프라인 CPU 성능 향상을 위해 고려할 사항</h2><p>이론 : 명령어 세그먼트의 횟수가 많아질수록 파이프라인의 이론적 최대속도가 증가<br>실제 : 이론을 따라가기 위해선 다음 전제조건이 필요</p>
<ul>
<li>  모든 명령어는 동일한 처리과정(세그먼트의 적용)으로 처리 되어야 함</li>
<li>파이프라인을 구성하는 각 단계의 처리 시간이 일정해야 함<ul>
<li>  실제론 각 세그먼트 수행시간이 다른데, 가장 오래걸리는 애의 싱크에 맞춰야 함</li>
</ul>
</li>
<li>  모든 명령어는 작성된 순서에 따라 순차적으로 실행되어야 함</li>
<li>  사용 명령어들 사이에는 상호 의존성이 없어야 함</li>
<li>명령어들 처리 시 공유 자원의 충돌이 없어야 함<ul>
<li>  명령어 저장공간, 자료 저장공간 분리로 해결</li>
</ul>
</li>
</ul>
<blockquote>
<p>CPU 성능 향상 &lt;= 명령어 파이프라인의 구성을 효과적으로 (분기명령, 데이터 의존성 줄였을 때)</p>
</blockquote>
<h1 id="13-Memory-System"><a href="#13-Memory-System" class="headerlink" title="13. Memory System"></a>13. Memory System</h1><h2 id="메모리-계층"><a href="#메모리-계층" class="headerlink" title="메모리 계층"></a>메모리 계층</h2><p>기억장치 : CPU에 의해 시행될 프로그램이 저장되는 곳</p>
<h3 id="기억장치의-분류"><a href="#기억장치의-분류" class="headerlink" title="기억장치의 분류"></a>기억장치의 분류</h3><ul>
<li><p>주 기억장치(Main memory unit)</p>
<ul>
<li>마더보드에 장착됨<ul>
<li>RAM(Random Access Memory) : 비교적 대용량, 고속의 속도를 지님, 휘발성 성질을 지님</li>
<li>ROM(Read Only Memory) : Booster 라고도 함</li>
</ul>
</li>
</ul>
</li>
<li><p>보조 기억장치(Auxiliary memory unit)</p>
<ul>
<li>USB, SD card 등의 장치</li>
<li>비교적 저속, 대용량의 장치(= 당장 쓰지 않는 장치)</li>
<li>보조 기억장치내의 자료들은 필요시 주 기억장치로 옮겨져서 Loading 됨</li>
</ul>
</li>
<li><p><strong>캐시 메모리(Cache memory, buffer)</strong></p>
<ul>
<li>CPU의 속도와 메모리의 속도 차이를 줄이기 위해 사용하는 고속 Buffer Memory</li>
<li>메모리 계층 구조에서 가장 빠른 소자이며, 처리 속도가 거의 CPU의 속도와 비슷</li>
<li>MMS, CPU에 배치되는 저장장치로 프로그램의 일부 혹은 사용빈도가 높은 데이터를 저장<ul>
<li>주기억장치 접근 시간 &gt; 프로세스 논리회로 $\Rightarrow$ MMS &amp; CPU 배치함<ul>
<li>주파수(frequency) = 클럭펄스 (CPU가 발생시킴, 레지스터를 제어하기 위해)<ul>
<li><strong>1 GHz = 1 ns</strong></li>
</ul>
</li>
</ul>
</li>
<li>현재 진행되고 있는 프로그램의 일부 또는 사용빈도가 높은 임시 데이터 저장 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="컴퓨터-시스템의-메모리-계층"><a href="#컴퓨터-시스템의-메모리-계층" class="headerlink" title="컴퓨터 시스템의 메모리 계층"></a>컴퓨터 시스템의 메모리 계층</h3><p><strong>입출력의 경제성</strong> 때문에, 메모리를 계층별로 나누게 됨</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B3%84%EC%B8%B5.png"></p>
<pre><code>2016년 기준 가격임
</code></pre>
<ul>
<li>cache memory 위치 : CPU, Main memory 사이에 존재!!!!</li>
<li>CPU는 기본적으로 Cache memory로 가서 필요한 데이터를 찾음<ul>
<li>있으면 hit, 없으면 miss 이고 메인메모리로 넘어감</li>
</ul>
</li>
<li>CPU는 Cache memory와 Main memory 까지는 직접 컨트롤하지만, 보조기억장치는 관리 안함<ul>
<li>쟤네 속도가 너무 느려서, 컴퓨터 성능 저하의 원인이 됨 </li>
<li>보조기억장치는 메인메모리로 로딩할 때, I/O Processor 라는 하드웨어 장치를 거침</li>
</ul>
</li>
</ul>
<h2 id="Main-Memory-Unit"><a href="#Main-Memory-Unit" class="headerlink" title="Main Memory Unit"></a>Main Memory Unit</h2><h3 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h3><ul>
<li><p>RAM(Random Access Memory)</p>
<ul>
<li>SRAM(Static RAM)<ul>
<li>  전원이 연결되어 있는 동안만 정보가 유지(Flip-Flop으로 구성)</li>
<li>  사용이 편리하고 읽기/쓰기 시간이 짧음(cache memory)</li>
</ul>
</li>
<li>DRAM(Dynamic RAM)<ul>
<li>  주기적으로 재 충전 해줘야 정보가 유지</li>
<li>  전력 소비가 적고, 하나의 칩으로 대량의 정보 저장 가능</li>
</ul>
</li>
</ul>
</li>
<li><p>ROM(Read Only Memery)</p>
<ul>
<li>  부트스트랩 로더(bootstrap loader)</li>
<li>  전원의 on/off와 무관하게 작동되기 때문에 불변하는 상수의 표 등이 저장</li>
</ul>
</li>
</ul>
<h3 id="RAM의-동작-원리"><a href="#RAM의-동작-원리" class="headerlink" title="RAM의 동작 원리"></a>RAM의 동작 원리</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RAM%EC%9D%98_%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC.png" alt="RAM의 동작 원리"></p>
<ul>
<li><p>MAR (Memory Address Register) : 기억장치 내에 내가 어떤 주소에 접근(Read 또는 Write)할 수 있는지</p>
</li>
<li><p>주소 디코더 : 들어온 정보의 의미가 뭔지 해석해서, 주소를 지정함</p>
</li>
<li><p>MBR (Memory Buffer Register)</p>
</li>
<li><p>CS (Clock Signal), RD (Read), WR (Write)</p>
</li>
</ul>
<h3 id="DDR"><a href="#DDR" class="headerlink" title="DDR"></a>DDR</h3><p>: RAM 규격(SD, DDR)의 일종으로 1997년 삼성에 발표된 새로운 규격을 말함</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98_DDR.png" alt="DDR"></p>
<pre><code>PCI : Peripheral Component Interconnect (Bus 연결, 회사마다 다름)
</code></pre>
<ul>
<li>SDRAM(Synchronous Dynamic Random Access Memory)<ul>
<li>DRAM의 발전된 형태이며, 동기식 DRAM이라고 할 수 있음<ul>
<li>  동기식 DRAM : (제어장치 입력) = (Clock pulse) (Frequency)</li>
<li>  클럭펄스 한 번에 한해 신호가 발생되고 신호에 의해 처리됨</li>
</ul>
</li>
</ul>
</li>
<li>SDR(Single Data Rate)<ul>
<li>  SDRAM 클럭 펄스의 변이(0 ↔ 1) 시, 단 한 차례의 정보 전송만을 허용하는 구조</li>
</ul>
</li>
<li>DDR SDRAM(Double Data Rate SDRAM)<ul>
<li>  클럭 펄스의 상승 및 하강(0 → 1 → 0)에서 데이터를 전송 함으로 더 큰 대역폭을 달성</li>
<li>  클럭 주파수를 증가시키지 않고도 전송 속도를 <strong>두배 향상</strong></li>
<li>  DDR의 전송 속도는 266 ~ 400 MT/s, 제품 : DDR266, DDR400</li>
</ul>
</li>
<li>DDR2 SDRAM(Double Data Rate Two SDRAM)<ul>
<li>  향상된 버스 신호에 의해 DDR2의 free batch buffer는 4 bit</li>
<li>내부 클럭 속도(133 ~ 200 MHz)는 DDR과 같지만, DDR2의 전송 속도는 향상된 I/O 버스 신호로 인해 533 ~ 800 MT/s 에 도달.<ul>
<li>  제품 : DDR2 533, DDR2 800</li>
</ul>
</li>
</ul>
</li>
<li>DDR3 SDRAM<ul>
<li>DDR2 모듈에 비해 40%의 전력 소비 (낮은 작동 전류&amp;전압 제공)<ul>
<li>  1.5V &lt; 1.8V (DDR2) &lt; 2.5V (DDR)</li>
</ul>
</li>
<li>  ASR(Automatic Self-Refresh) 및 SRT(Self-Refresh Temperature) 기능 추가</li>
</ul>
</li>
<li>DDR4 SDRAM<ul>
<li>  낮은 작동 전압(1.2V)과 높은 전송 속도(2133 ~ 3200 MT/s)를 제공</li>
<li>DBI(Data Bus Inversion), CRC(Cyclic Redundancy Check) 및 CA parity 등의 기능 추가<ul>
<li>  신호 무결성 $\uparrow$, 데이터 전송/엑세스 안정성 $\uparrow$</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>동기식 DRAM은 제어장치의 입력이 클럭 펄스 주기와 같은 것을 의미</p>
</blockquote>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98_DDR.png" alt="DDR (ref: Yaroslav Magistr)"></p>
<h2 id="Auxiliary-Memory-Unit"><a href="#Auxiliary-Memory-Unit" class="headerlink" title="Auxiliary Memory Unit"></a>Auxiliary Memory Unit</h2><p>접근 시간 : 메모리 내의 기억장소에 도달하여 그 내용을 얻는데 요구되는 평균 시간 (캐시메모리의 약 1000배 정도)</p>
<p>종류</p>
<ul>
<li>  Seek time : read/write head가 지정된 기억장소에 도달하는데 소요되는 시간</li>
<li>  Transfer time : 추출된 데이터를 장치 내 또는 장치 밖에 필요한 곳으로 전송하는데 요구되는 시간</li>
<li>  Record : 일반적으로 데이터가 기록되는 단위, Seek time을 체크하게 되는 기준 (일정한 길이의 수치 또는 문자 집합)</li>
<li>  Transfer rate : 장치가 레코드의 시작점에 위치한 다음 단위 시간 당(보통 minute 단위) 전송할 수 있는 문자나 워드의 수</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98.png"></p>
<h3 id="SSD-Solid-State-Drive"><a href="#SSD-Solid-State-Drive" class="headerlink" title="SSD(Solid State Drive)"></a>SSD(Solid State Drive)</h3><ul>
<li>  고형 상태 보조 기억장치, 고체 상태와 트랜지스터를 뜻함</li>
<li>플래시 메모리로 구성되어 있어 소음이 대폭 감소했으며, 소모 전력과 발열 수준이 낮음<ul>
<li>  HDD는 자기 디스크, SDD는 플래시 메모리로 구성 (비교한다면, HDD : SSD = 액정디스플레이 : AMOLED디스플레이)</li>
<li>  플래시 메모리는 구동 부(모터)가 없기 때문</li>
</ul>
</li>
<li>  이런식의 회전판이 제거된 컴퓨터를 <strong>제로 스핀</strong> 시스템이라 함</li>
</ul>
<h4 id="SSD의-특징-및-장점"><a href="#SSD의-특징-및-장점" class="headerlink" title="SSD의 특징 및 장점"></a>SSD의 특징 및 장점</h4><p>= 데이터 입/출력 속도</p>
<table>
<thead>
<tr>
<th align="center">HDD - 3.5인치 7200rpm 2~3TB급 제품</th>
<th align="center">SDD - SATA-3 규격 모델</th>
</tr>
</thead>
<tbody><tr>
<td align="center">최대 200MB/s 까지 측정</td>
<td align="center">350<del>400MB/s ~ 500</del>550MB/s</td>
</tr>
</tbody></table>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/SSD.png"></p>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>고전적 모델로 알아두기만 하자 (서버급에선 여전히 사용중?)</p>
<ul>
<li><p>RAID (Redundant Array of Inexpensive (or Independent)Disks)</p>
<ul>
<li>성능의 향상을 위하여 가격이 저렴하고 크기가 작은 여러 개의 하드 디스크들을 묶어 하나의 기억 장치처럼 사용 할 수 있게 하는 방식</li>
<li>다수의 하드 디스크들은 오류 복구에 대한 정책에 따라 여러가지 방식 (레벨 0~6)으로 구분 됨 (상호적인 계층은 아님에 유의)</li>
</ul>
</li>
<li><p>RAID level 0</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RAID_level0.png"></p>
<ul>
<li>가격경쟁력을 위해 여분의 공간을 만들지 않음</li>
<li>Strip : 저장 테크닉, 데이터를 사용가능한 디스크에 기술하는 방식(물리적 블록, 섹터 등)</li>
</ul>
</li>
<li><p>RAID level 1~6</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/RAID_level1_6.png"></p>
<ul>
<li><p>level 1 : 단순복사</p>
</li>
<li><p>level 2</p>
<ul>
<li>문제 발생시 (= 복원 필요시), parity bit에 의해 매치되는 정보를 사용<ul>
<li>이때 parity bit를 hamming code 값 따라 찾을 수 있도록 만들어 놓음<ul>
<li>p1, p2, p3, p4 가 바로 parity bit 값</li>
<li>hamming code : 특정값을 나머지 값에 따라 구분하는 것</li>
</ul>
</li>
</ul>
</li>
<li>원본에 대해 반사디스크를 구성하는 형식</li>
</ul>
</li>
<li><p>level 3</p>
<ul>
<li>level 2 처럼 여러개의 디스크를 두지 않고, 디스크 하나로 표현<ul>
<li>parity bit 역시 압축한 형태로 사용</li>
</ul>
</li>
</ul>
</li>
<li><p>level 4-6</p>
<ul>
<li><p>level 3를 더 축소 한 것</p>
<ul>
<li>level 3 까지는 반사 디스크에서 데이터가 움직이면 다른 데이터가 같이 움직이지만</li>
<li>level 4 부터는 반사 디스크가 독립적으로 움직임 (구동을 따로 가능)<ul>
<li>parity bit 를 0-3 까지, 4-7 까지 식으로 나눠놨음</li>
</ul>
</li>
</ul>
</li>
<li><p>level 5-6</p>
<ul>
<li>데이터 디스크 대각선 방향으로 parity bit를 저장 (그림 왼쪽 아래 노란색 표시부분)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="USB-Universal-Serial-Bus"><a href="#USB-Universal-Serial-Bus" class="headerlink" title="USB(Universal Serial Bus)"></a>USB(Universal Serial Bus)</h3><ul>
<li><p>배경 : 특정 주변 기기들을 좀 더 쉽게 이용하기 위해 만들어진 단자</p>
<ul>
<li>특정 주변 기기들 = 시리얼 포트나 패래럴 포트 등의 데이터 입출력 단자에 연결하여 이용하는 주변 기기들</li>
</ul>
</li>
<li><p>1995년 인텔 최초의 USB 지원 칩셋 430HX 발표</p>
</li>
<li><p>1990년대 말 ~ 2000년대 초부터 보급 시작</p>
</li>
<li><p>현재 주변기기 연결 인터페이스의 독점적인 위치를 점함 (USB-C type으로 바뀌고 있음)</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/USB%ED%91%9C%EC%A4%80%EC%A0%84%EC%95%95%EA%B3%BC%EC%A0%84%EB%A5%98.png"></p>
</li>
</ul>
<!-- ## 효율적 메모리 관리 정책 -->

<h2 id="Associative-Memory-unit"><a href="#Associative-Memory-unit" class="headerlink" title="Associative Memory unit"></a>Associative Memory unit</h2><p>: 내용에 의해 접근하는 메모리 장치</p>
<ul>
<li>  메모리 장치란 자료(data)의 저장(store)과 접근(access)을 용이하게 하기 위해 필요로 하는 장치</li>
<li>  CPU는 필요 자료를 얻기 위해 메모리 장치를 탐색(search)</li>
<li>좀 더 효율적 탐색이 가능한 저장 공간은 어떤 형태로 만들어야 할까?<ul>
<li>   내용 지정 메모리(Content Addresable Memory, CAM)!</li>
</ul>
</li>
</ul>
<blockquote>
<p>이 방식은 <strong>데이터의 내용으로 병렬 탐색</strong>을 하기에 적합하도록 구성됨</p>
</blockquote>
<blockquote>
<p>탐색은 전체 워드 혹은 한 워드 내 일부만을 가지고 실행 가능</p>
</blockquote>
<ul>
<li>특징 : 각 셀이 저장 능력 뿐 아니라 <strong>외부 인자와 내용을 비교하기 위한 논리회로를 갖고 있음</strong>  RAM보다 값이 비싸므로, 꼭 필요할 때 (탐색 시간이 필히 짧아야해 때) 활용 됨</li>
</ul>
<h3 id="Associative-memory의-하드웨어-구성과-메모리"><a href="#Associative-memory의-하드웨어-구성과-메모리" class="headerlink" title="Associative memory의 하드웨어 구성과 메모리"></a>Associative memory의 하드웨어 구성과 메모리</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_memory%EC%9D%98_%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EA%B5%AC%EC%84%B1%EA%B3%BC_%EB%A9%94%EB%AA%A8%EB%A6%AC.png"></p>
<ul>
<li>Array and Logic : 저장공간 + 논리회로</li>
<li>m 개의 워드는 각각 n 개의 bits 로 이루어졌다 가정<ul>
<li>$word_1$, $\cdots$,  $word_i$,  $\cdots$, $word_m$<ul>
<li>$word_i$ = {$C_{i1}$, $\cdots$, $C_{ij}$}, $\cdots$, $C_{in}$}</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Argument register (식별자 역할)</p>
<ul>
<li>찾고자 하는 정보가 들어가고, 그 내용을 한 글자씩 word 를 비교함</li>
</ul>
</li>
<li><p>Key register : mask 제공</p>
<ul>
<li><p>argument register 의 *특정한 영역이나 키를 선택하기 위한 마스크(mask)*를 제공</p>
<ul>
<li>즉, argument register의 특정영역만을 비교하기 위함</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_memory_Key_register%EC%9D%98%EC%97%AD%ED%95%A0.png"></p>
</li>
</ul>
</li>
<li><p>Match register</p>
<ul>
<li>Argument register 에서 비교한 결과, $word_i$ 가 맞으면, 해당라인의 $M_i$ 1로 set 됨</li>
<li>마지막에 $M_1$, $\cdots$, $M_i$, $\cdots$, $M_m$ 까지 체크해서 1로 set 되어있는 부분을 읽어오면 됨</li>
</ul>
</li>
<li><p>Write Process - <strong>tag bit의 추가</strong></p>
<ul>
<li>쓰기를 하려면, 빈 공간이 있거나 쓸모없는 부위를 덮어 씌워야함</li>
<li>이 때, <strong>쓸모없는 부위를 1 또는 2와 같은 값으로 표시</strong>해 두는게 tag bit</li>
</ul>
</li>
</ul>
<h2 id="Cache-Memory"><a href="#Cache-Memory" class="headerlink" title="Cache Memory"></a>Cache Memory</h2><p>컴퓨터의 성능을 좌지우지함</p>
<h3 id="Locality-of-reference"><a href="#Locality-of-reference" class="headerlink" title="Locality of reference"></a>Locality of reference</h3><p>참조의 지역성 : 자주 쓰이는 애들은 일정 지역에 몰려있음</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Locality_of_Reference.png"></p>
<p>출처 : <a target="_blank" rel="noopener" href="https://itwiki.kr/w/%EC%B0%B8%EC%A1%B0_%EC%A7%80%EC%97%AD%EC%84%B1">https://itwiki.kr/w/%EC%B0%B8%EC%A1%B0_%EC%A7%80%EC%97%AD%EC%84%B1</a></p>
<ul>
<li>공간(spatial) 지역성<ul>
<li>특성 클러스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향</li>
<li>참조된 메모리 근처의 메모리를 참조</li>
</ul>
</li>
<li>시간(temporal) 지역성<ul>
<li>최근 사용되었던 기억 장소들이 집중적으로 액세스되는 경향</li>
<li>참조했던 메모리는 빠른 시간에 다시 참조될 확률이 높음</li>
</ul>
</li>
<li>순차(sequential) 지역성 : 공간 지역성에 편입되어 설명되기도 함<ul>
<li>데이터가 순차적으로 액세스되는 경향</li>
<li>프로그램 내의 명령어가 순차적 구성에 기인</li>
</ul>
</li>
</ul>
<hr>
<p>프로그램이 수행되는 동안 메모리 참조는 국한된 영역에서만 이루어지는 경향이 있음</p>
<ul>
<li>  프로그램 루프와 서브 루틴의 빈번한 활용</li>
<li>  순차적 프로그램의 실행</li>
<li>  데이터 메모리 참조에서도 동일한 경향이 있음을 확인</li>
</ul>
<blockquote>
<p>이와 같이 참조의 국한성(locality of reference)을 이용하여 속도가 빠름(CPU 처리속도와 만큼)</p>
</blockquote>
<blockquote>
<p>적은 메모리를 이용하여 (비용절감을 위함) 프로그램을 수행 시키는 것은, <strong>평균 메모리 접근 시간의 단축</strong>과 그에 따른 <strong>전체 프로그램 수행 시간의 절약</strong>을 담보함</p>
</blockquote>
<blockquote>
<p>이러한 기억 공간을 <strong>cache memory</strong></p>
</blockquote>
<h3 id="Cache-memory-동작"><a href="#Cache-memory-동작" class="headerlink" title="Cache memory 동작"></a>Cache memory 동작</h3><p>CPU가 메모리에 접근할 필요가 있을 경우 Cache의 기본동작 순서</p>
<ul>
<li>  Cache 체크</li>
<li>  워드가 Cache에서 발견되면(<strong>hit</strong>) 읽어 들이고 아닐 경우(<strong>miss</strong>) 주 기억 장치에 접근</li>
<li>이 워드를 포함한 블록(1~16워드, 환경에 따라다름)을 Cache로 전송<ul>
<li>  지금 쓴 자료는 조만간 사용할 가능성이 높음</li>
</ul>
</li>
</ul>
<h3 id="Cache-memory-성능"><a href="#Cache-memory-성능" class="headerlink" title="Cache memory 성능"></a>Cache memory 성능</h3><p>hit ratio</p>
<ul>
<li><p>$\frac{힛트 수}{CPU에 의한 메모리 참조 총 수} \approx 0.9$</p>
</li>
<li><p>예시: </p>
<ul>
<li>조건 : cache 접근시간 : 100 ns, 주 기억장치 접근시간 : 1000ns, hit ratio : 0.9</li>
<li>데이터 접근 시간 : 평균 200 ns<ul>
<li>$(데이터 접근 시간) = (cache 접근시간) \times (hit ratio) + (주 기억장치 접근시간) \times (1- (hit ratio)$<blockquote>
<p>즉, 1000ns 걸리던 것이, cache memory를 사용하자 200ns 로 줄어듬!!</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cache-memory-매핑-프로세스"><a href="#Cache-memory-매핑-프로세스" class="headerlink" title="Cache memory 매핑 프로세스"></a>Cache memory 매핑 프로세스</h3><p>현존 최고의 메모리 관리 방법 = cache memory 사용</p>
<ul>
<li><p>cache memory 사용시 성능을 높이려면?</p>
<ol>
<li>hit rate 를 높이자</li>
<li>cache를 얼마나 효율적으로 재구성할 것인지<br>: 어떤 것을 삭제할 것인지 = 새로운 항목을 어떤 기준으로 올릴 것인가 = 제거 정책 (mapping process)</li>
</ol>
</li>
<li><p>Cache Mapping Techniques (cache를 관리하는 프로세스 종류)</p>
<ul>
<li><p>Direct mapping</p>
<ul>
<li>  SRAM 에다가 만듦</li>
<li>  하나의 공간에 하나씩 저장하는게 기본 컨셉(hit rate 와 Locality of reference 보장을 위함)</li>
<li>  메인 메모리를 일정한 크기의 블록으로 나누고 각각의 블록을 캐시의 정해진 위치에 매핑하는 방식 (가장 간단한 방법)</li>
<li>단점 : 동일한 라인 번호의 주소를 매핑할 수 없음<ul>
<li>  같은 인덱스를 가졌지만 다른 tag를 가진 두 개 이상의 워드가 반복 접근할 경우 적중률이 낮아질 수 있음    </li>
</ul>
</li>
</ul>
</li>
<li><p>Associative mapping</p>
<ul>
<li>  Associative memory (CAR : Address 뿐 아니라 contents 로도 찾을(Reference 할) 수 있는 메모리)로 Cache를 만듦</li>
<li>캐시의 태그 필드를 확장하여 캐시의 어떤 라인과도 무관하게 매핑 가능<ul>
<li>  Direct mapping 의 단점 보완</li>
<li>  = 어떤 주소든지 동시에 매핑시킬 수 있어 높은 히트율을 가질 수 있음</li>
</ul>
</li>
<li>  단점 : ?</li>
</ul>
</li>
<li><p>Set-associative mapping</p>
<ul>
<li>  hit rate 가 낮을 경우 보완?</li>
<li>  주어진 공간에 병렬(정책에 따라 다름)로 저장 $\rightarrow$ 병렬처리 가능</li>
</ul>
<p>참고 링크 : <a target="_blank" rel="noopener" href="https://wikidocs.net/65523">캐시 메모리 (Cache Memory) 개념, 기법</a></p>
</li>
</ul>
</li>
</ul>
<!-- 
# 컴퓨터 성능 개선을 위한 메모리 관리
========================= 


## 메모리 관리

컴퓨터 성능 개선을 위한 메모리 관리를 알아보자.

먼저 Cache momory 전송을 위한 매핑 기법 -->


<h2 id="Cache-memory-매핑-프로세스-자세히"><a href="#Cache-memory-매핑-프로세스-자세히" class="headerlink" title="Cache memory 매핑 프로세스 [자세히]"></a>Cache memory 매핑 프로세스 [자세히]</h2><!-- 참고 블로그 : https://m.blog.naver.com/PostView.nhn?blogId=zxwnstn&logNo=221548847548&proxyReferer=https:%2F%2Fwww.google.com%2F -->

<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/the_mapping_process_diagram.png" alt="A diagram of the mapping process"><br>출처 : <a target="_blank" rel="noopener" href="https://www.gatevidyalay.com/cache-mapping-cache-mapping-techniques/">https://www.gatevidyalay.com/cache-mapping-cache-mapping-techniques/</a></p>
<ul>
<li>mapping process<ul>
<li>Main memory 는 block 또는 frames 라 불리는 같은 사이즈의 파티션으로 나뉘어짐</li>
<li>Cache memory 는 lines 로 불리는 block 과 같은 사이즈의 파티션으로 나뉨</li>
<li>cache mapping 에서 main memory 의 block 은 cache로 간단히 복사됨 (이 때, block 은 사실 main memory에서 가져온게 아님)</li>
</ul>
</li>
</ul>
<ul>
<li><p>종류</p>
<ul>
<li>  Direct mapping</li>
<li>  Fully Associative mapping</li>
<li>  K-way Set-associative mapping</li>
</ul>
</li>
<li><p>내용 설명을 위한 조건 가정</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A0%84%EC%86%A1%EA%B8%B0%EB%B3%B8%EB%AA%A8%ED%98%95.png"></p>
<ul>
<li>  주 기억장치 : 12 bit 32K 워드 저장</li>
<li>  캐시 메모리 : 512 word / 제한 시간</li>
<li>  CPU는 main/cache memory 모두 통신 가능</li>
<li>  15 bit 주소를 캐시로 보내 hit 발생 시 캐시로부터 12 bit 데이터 받음</li>
<li>  miss 발생 시 주 기억장치로부터 워드를 읽고 이를 cache로 이동, 저장</li>
</ul>
</li>
</ul>
<h3 id="Direct-mapping"><a href="#Direct-mapping" class="headerlink" title="Direct mapping"></a>Direct mapping</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Direct_Mapping_ex0.png"></p>
<ul>
<li>  RAM에 구현한 cache memory (SRAM 사용)</li>
<li>  15 bit(CPU addres) = 6 bit(Tag field) + 9 bit(Index field)</li>
<li>  Index field-cache 색인 주소로 활용</li>
<li>  Tag field-cache 동일 index로 충돌이 발생 시 활용</li>
</ul>
<blockquote>
<p>동일한 인덱스의 다른 태그를 보유한 두개 이상의 워드가 반복하여 접근 할 경우 히트율이 현저히 떨어질 가능성이 높다 (그러나, Locality of reference에 따라 상당한 만족도를 줄 수 있음)</p>
</blockquote>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Direct_Mapping_ex.png"><br>출처 : <a target="_blank" rel="noopener" href="https://www.gatevidyalay.com/cache-mapping-cache-mapping-techniques/">https://www.gatevidyalay.com/cache-mapping-cache-mapping-techniques/</a></p>
<h4 id="캐시-상태-변화-예시"><a href="#캐시-상태-변화-예시" class="headerlink" title="캐시 상태 변화 예시"></a>캐시 상태 변화 예시</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Direct_Mapping_ex1.png"></p>
<ul>
<li><p>현재 cache 의 저장 상태</p>
<table>
<thead>
<tr>
<th align="center">index</th>
<th align="center">Tag</th>
<th align="center">Data</th>
</tr>
</thead>
<tbody><tr>
<td align="center">000</td>
<td align="center">00</td>
<td align="center">1220</td>
</tr>
</tbody></table>
</li>
<li><p>이 때, 만약 CPU가 02000 번지의 자료를 얻고자 cache에 접근한다면</p>
<ol>
<li><p>index 000 으로 검색</p>
</li>
<li><p>index 000 으로 접근</p>
</li>
<li><p>Tag 02 $\Leftrightarrow$ Tag 00 miss</p>
</li>
<li><p>주 기억 장치로 접근 $’5260’$ 전송</p>
</li>
<li><p>cache 의 index 000 에 최근 access 했던 값으로 교체</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">Tag</th>
<th align="center">Data</th>
</tr>
</thead>
<tbody><tr>
<td align="center">000</td>
<td align="center">00</td>
<td align="center">5260</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ul>
<h3 id="Associative-mapping"><a href="#Associative-mapping" class="headerlink" title="Associative mapping"></a>Associative mapping</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Associative_mapping.png"></p>
<ul>
<li>  가장 빠르고 융통성 있는 cache 구조 (비싼소자니까!)</li>
<li>  CPU의 15 bit 주소는 Argument register (MAR, MBR 역할을 함) 에 놓여짐</li>
<li>associative memory 내 주소와 같은 12 bit 데이터를 읽어서,<ul>
<li>  Hit인 경우 CPU로 보냄</li>
<li>  Miss 인 경우 CPU는 주 기억 장치에서 해당 자료를 찾아 캐시로 옮김</li>
</ul>
</li>
<li>  만약 캐시에 여유 공간이 있다면 그 공간에 주소와 데이터를 저장</li>
<li>  캐시가 꽉 차 있을 경우 기존 캐시의 주소와 데이터 쌍 중 주어진 알고리즘에 의해 해당 주소 데이터 쌍이 새로운 쌍으로 대체 됨</li>
</ul>
<blockquote>
<p>주소 + 주소로 찾은 내용까지 데이터 검색하여 사용</p>
</blockquote>
<h3 id="Set-asociative-mapping"><a href="#Set-asociative-mapping" class="headerlink" title="Set-asociative mapping"></a>Set-asociative mapping</h3><ul>
<li><p>한 인덱스 안에 두개의 태그를 가지는 경우의 cache를 구현 한 예</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Set-asociative_mapping_cache_Ex.png"></p>
</li>
</ul>
<ul>
<li>각 인덱스에 여러개의 Tag와 Data 를 병렬로 가지게 함<ul>
<li>  Cache 의 각 워드는 같지만 동일 인덱스 주소 아래 두 개 이상의 메모리 워드를 저장 할 수 있게 함으로 Direct mapping 의 단점을 보완</li>
</ul>
</li>
<li>  캐시 메모리의 크기 = 512 x (2 x (6 + 12))</li>
<li>  큰 규모의 캐시는 히트율을 높일 수 있으나, 좀 더 정교한 논리 회로가 필요</li>
<li>  기존 데이터의 대체 알고리즘이 복잡해짐</li>
</ul>
<h2 id="Virtual-Memory-vs-Cache-Momory"><a href="#Virtual-Memory-vs-Cache-Momory" class="headerlink" title="Virtual Memory vs Cache Momory"></a>Virtual Memory vs Cache Momory</h2><ul>
<li><p>필요성 : <strong>전체 메모리 시스템의 총 경비를 최소화</strong> 하면서 가능한 메모리로의 <strong>높은 평균 접근 속도</strong>를 위해서 활용되고 있음</p>
</li>
<li><p>비교</p>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">Virtual Memory System</th>
<th align="center">Cache Momory System</th>
</tr>
</thead>
<tbody><tr>
<td align="center">설치 위치</td>
<td align="center">보조기억장치와 주 기억장치 사이에서 데이터 전송을 관리</td>
<td align="center">주기억장치와 CPU 사이에서 정보 교환</td>
</tr>
<tr>
<td align="center">사용 목적</td>
<td align="center">CPU에 의해 현재 사용되고 있지 않은 자료 및 프로그램 보관</td>
<td align="center">가장 사용 빈도가 높은 프로그램 및 데이터를 저장 활용</td>
</tr>
<tr>
<td align="center">활용 방안</td>
<td align="center">페이지를 사용하는 주소 매핑</br>Associative memory 페이지표</br>페이지 교체</td>
<td align="center">Direct mapping</br>Associative mapping</br>Set-associative mapping</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="메모리-관리-시스템"><a href="#메모리-관리-시스템" class="headerlink" title="메모리 관리 시스템"></a>메모리 관리 시스템</h2><ul>
<li><p>배경 : 메모리의 광역화 (가상 메모리 + 캐쉬 메모리)와 멀티 프로그램의 발달 $\rightarrow$ 시스템내 상호 간섭도 $\uparrow$, 시스템 기능 $\downarrow$</p>
</li>
<li><p>역할 : 프로그램과 프로그램사이의 데이터 흐름 제어, 선후 데이터의 활용 제어, 사용 메모리의 양 조절, 다른 프로그램의 흐름에 영향을 끼치지 못하게 하는 제어…</p>
</li>
</ul>
<blockquote>
<p>메모리 관리 시스템은 운영체제(Operating System)의 일부이고,<br>메모리 내의 여러 프로그램을 관리하기 위한 H/W와 S/W절차의 집합체</p>
</blockquote>
<h2 id="메모리-관리-하드웨어의-필요성"><a href="#메모리-관리-하드웨어의-필요성" class="headerlink" title="메모리 관리 하드웨어의 필요성"></a>메모리 관리 하드웨어의 필요성</h2><ol>
<li><p>동적 저장장소 재배치 기능</p>
<ul>
<li><p>동적 저장장소 재배치 : 논리 메모리 참조를 물리 메모리 주소로 변환</p>
<ul>
<li>물리 메모리 주소 변환 예시  : 파이프라인에서 기억공간을 혼용해서 사용시, 데이터 의존 문제가 발생 (양쪽에서 쓰려하거나, 아직 안만들어져서 기다리는 문제) $\rightarrow$ 프로그램 저장공간, 데이터 저장공간의 <strong>분리 사용</strong>으로 문제해결</li>
</ul>
</li>
</ul>
</li>
<li><p>(메모리 내에서) 서로 다른 사용자가 하나의 프로그램을 같이 사용 가능</p>
</li>
<li><p>정보의 보호</p>
<ul>
<li>사용자 간의 허락되지 않은 접근을 방지하고, 사용자가 OS의 기능을 변경하지 못하도록 함</li>
</ul>
</li>
</ol>
<h1 id="14-입출력-구조"><a href="#14-입출력-구조" class="headerlink" title="14. 입출력 구조"></a>14. 입출력 구조</h1><ul>
<li>시스템 BUS 구성 및 제어</li>
</ul>
<h2 id="시스템-버스의-필요성"><a href="#시스템-버스의-필요성" class="headerlink" title="시스템 버스의 필요성"></a>시스템 버스의 필요성</h2><!-- PCI : Peripheral Component Interconnect (Bus 연결, 회사마다 다름) -->

<!-- ### 버스와 메모리 전송 -->

<ul>
<li><p>배경 : 전형적인 디지털 컴퓨터는 많은 레지스터와 레지스터들 사이의 정보 전송을 위한 경로가 필요</p>
</li>
<li><p><strong>Common Bus</strong> 시스템 : 시스템 버스의 사용으로, 각 레지스터들 사이를 연결할 필요가 없어짐</p>
<ul>
<li><p>Bus : 한번에 하나의 전송 만이 이루어지도록 제어 신호를 이용하여 해당 레지스터를 선별</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Common_bus_line.png" alt="Common_bus_line"><br><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Common_bus_lines.png" alt="Common_bus_lines">    </p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>사용 예시</p>
<ul>
<li><p>시스템 버스와 I/O 버스<br>  : 외부 주변 장치 및 통신의 주체로서 정보의 입출력을 관장 (CPU 가 처리함)</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Common_bus_line_and_IO_bus_line.png" alt="시스템 버스와 I/O 버스">    </p>
<ul>
<li><p>Bus Adapter $\rightarrow$ 입출력 버스를 시스템 버스 라인에 연결</p>
</li>
<li><p>I/O controller : 입출력 인터페이스<br>  : $\rightarrow$ 입출력 속도 및 유사한 동작 특성 단위로 입출력 장치들을 제어 관리 하는 장치  </p>
</li>
<li><p>I/O Controller 구성 : SR, Data Register, Command Register, Control Circuit(제어회로), Address Decoder</p>
</li>
<li><p>[참고] 08. CPU 내부구조 - CPU 디자인</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="시스템-버스의-제어"><a href="#시스템-버스의-제어" class="headerlink" title="시스템 버스의 제어"></a>시스템 버스의 제어</h2><h3 id="시스템-버스와-I-O-버스-간-상호-중재-1"><a href="#시스템-버스와-I-O-버스-간-상호-중재-1" class="headerlink" title="시스템 버스와 I/O 버스 간 상호 중재 1"></a>시스템 버스와 I/O 버스 간 상호 중재 1</h3><ul>
<li><p>컴퓨터 시스템에는 각 요소들 사이의 정보 전송을 위한 다양한 단계의 여러 버스가 존재함</p>
<ul>
<li>CPU 내에서도 레지스터와 ALU사이의 정보 전송을 위한 여러 내부 버스 존재</li>
</ul>
<ul>
<li>  메모리 버스 $\rightarrow$ 데이터, 주소, 그리고 읽기/쓰기 정보 전송</li>
<li>  I/O 버스 $\rightarrow$ 입출력 장치로 정보를 주고 받을 때 사용</li>
</ul>
</li>
<li><p>공유 메모리 멀티 프로세서 시스템에서 프로세서는 시스템 버스를 통하여 공유 자원에 대한 접근을 요구함</p>
<ul>
<li>  공유 자원이 사용되고 있지 않을 경우 $\rightarrow$ 바로 사용 승인</li>
<li>  공유 자원이 사용되고 있을 경우 $\rightarrow$ 선점 프로세스의 종료까지 대기 상태 유지 (interlock 제외)</li>
<li>  동시에 버스를 요구하는 경우 $\rightarrow$ 공유자원에 대한 충돌을 해결하기 위한 <strong>중재(arbitration) 동작</strong> 수행</li>
</ul>
</li>
</ul>
<blockquote>
<p>동시에 버스를 요구하는 경우, 공유자원에 대한 충돌을 해결하기 위한 <strong>중재(arbitration) 동작</strong> 을 어떻게 처리 할 것인가?</p>
</blockquote>
<h4 id="IEEE-표준-796-다중-버스-신호"><a href="#IEEE-표준-796-다중-버스-신호" class="headerlink" title="IEEE 표준 796 다중 버스 신호"></a>IEEE 표준 796 다중 버스 신호</h4><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/IEEE%ED%91%9C%EC%A4%80_796%EB%8B%A4%EC%A4%91%EB%B2%84%EC%8A%A4%EC%8B%A0%ED%98%B8.png" alt="IEEE 표준 796 다중 버스 신호">    </p>
<ul>
<li>Data and address - Data line 16개, Adress lines 24개</li>
<li>Data transfer - 데이터 전달, 아래 있는 애들은 명령어임 (Control line 임)<ul>
<li>Transfer acknowledge : 하나의 입출력 프로세스에서 동시사용시, 중재에 필요한 정보<ul>
<li>여기서 acknowledge 는 사용해도 된다는 <strong>승낙/허락 신호</strong>임</li>
</ul>
</li>
<li>Interrupt control : 일단 멈춰, 이거 쓸꺼야 하는 명령<ul>
<li>Intterupt request(8bits = 8 lines), Interrupt acknowledge</li>
</ul>
</li>
<li>Miscellaneous control : 기타 제어</li>
</ul>
</li>
<li>Power and ground - 에너지 전달하는 라인</li>
</ul>
<h3 id="시스템-버스와-I-O-버스-간-상호-중재-2"><a href="#시스템-버스와-I-O-버스-간-상호-중재-2" class="headerlink" title="시스템 버스와 I/O 버스 간 상호 중재 2"></a>시스템 버스와 I/O 버스 간 상호 중재 2</h3><ul>
<li><p>Data line<br>  : 프로세스와 공통 메모리 사이의 데이터 전송 경로 제공(16~32 lines, 양 방향 정보 전송)</p>
<ul>
<li>데이터 전송 모드<ul>
<li>  동기 : source &amp; target 장치 간 공통 clock 구동에 의해 정해진 시분할 동안 데이터 전송</li>
<li>비동기 : (예외상황) 각 장치들을 독립적 클럭으로 동기화, source &amp; target 장치 간 <strong>hand shaking</strong> 제어 신호에 의해 각 데이터를 전송<ul>
<li>  hand shaking : 주로 통신시 주고 받는 것 (sleep 모드 인지 서로 확인하는 느낌)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Adress lines<br>  : 메모리 주소와 입출력 포트 식별에 활용(단 방향 정보 전송)</p>
</li>
<li><p>Control line<br>   : 장치들 간 정보 전송을 제어하는 신호 제공</p>
<ul>
<li><p>  Timing signal : 데이터와 주소 정보의 유효성 체크</p>
</li>
<li><p>  Command line : 수행 할 동작을 지정</p>
</li>
<li><p>전송 신호 : 메모리 읽기와 쓰기 등  </p>
<pre><code>  ex) Momory, I/O 모두를 포함, 주소 라인은 독립된 메모리와 I/O 공간의 지정을 위해 활용
</code></pre>
</li>
<li><p>Transfer acknowledge : 전송의 승낙  </p>
<pre><code>  ex) 전송이 완료되었음을 알림
</code></pre>
</li>
<li><p>인터럽트 요구 : 인터럽트 요구 명령과 승낙 명령으로 구성</p>
<pre><code>  ex) Intterupt request(8bits = 8 lines), Interrupt acknowledge : 8개의 인터럽트 요구 명령, 1개의 승낙 명령
</code></pre>
</li>
<li><p>버스 제어 신호 : 버스 요구 및 버스 승인 등  </p>
<pre><code>  ex) Bus lock $\rightarrow$ 멀티 프로세서 응용에서 검사와 설정이 실행 되는 동안, 다른 프로세서가 버스를 계속 잡고 있지 못하도록 막아줌
</code></pre>
</li>
<li><p>Bus arbitration : 중재 절차를 위한 신호 등으로 사용</p>
<p>$^{***}$ex) “IEEE 표준 796 다중 버스 신호” 그림 참고</p>
</li>
</ul>
</li>
</ul>
<h2 id="시스템-버스의-활용"><a href="#시스템-버스의-활용" class="headerlink" title="시스템 버스의 활용"></a>시스템 버스의 활용</h2><ul>
<li>BUS 는 System Bus, I/O Bus 두가지가 있고<ul>
<li>Address line, Data line, Control line (Command line, …)</li>
</ul>
</li>
<li>Bus 를 중재하는 어댑터가 있음</li>
<li>System Bus 는 CPU를 통해 제어됨<ul>
<li>어떤 I/O Device를 사용할지,</li>
<li>“IEEE 표준 796 다중 버스 신호” 같은 곳에 <strong>명령</strong>들이 세팅이 되어있음</li>
</ul>
</li>
<li>중재(arbirtration) : 하나의 자원을 두가지 이상에서 쓰려고 할 때 필요<ul>
<li>직렬중재와 병렬중재로 방법이 나뉨</li>
</ul>
</li>
</ul>
<h3 id="직렬-중재-절차"><a href="#직렬-중재-절차" class="headerlink" title="직렬 중재 절차"></a>직렬 중재 절차</h3><p>: 우선 순위를 바탕으로 Daisy-chain 연결로 중재하는 방법 제시</p>
<p>(시스템 버스 제어기에서 진행되는 되며, 시스템 버스 제어기는 중재를 위한 논리 회로를 내장한다)</p>
<ul>
<li><p>Daisy chain 이란?</p>
<p>  : 연속적으로 연결되어 있는 하드웨어 장치들의 구성을 지칭함</p>
<ul>
<li><p>예를 들어, 장치 A, B, C를 연결할 때 장치 A와 B를 연결하고, 장치 B와 C를 연속하여 연결하는 방식의 버스 결선 방식</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Daisy_chain.png"><br>출처 : <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Daisy_chain_(electrical_engineering)">https://en.wikipedia.org/wiki/Daisy_chain_(electrical_engineering)</a></p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Daisy_chain1.png"><br>출처 : <a target="_blank" rel="noopener" href="https://kb.supremainc.com/knowledge/doku.php?id=ko:daisy_chain">https://kb.supremainc.com/knowledge/doku.php?id=ko:daisy_chain</a></p>
</li>
</ul>
</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B2%84%EC%8A%A4%EC%A0%9C%EC%96%B4%EA%B8%B0_%EC%A7%81%EB%A0%AC%EC%A4%91%EC%9E%AC.png">    </p>
<ul>
<li><p>사용 권한을 받기 위해선,</p>
<ol>
<li>가장 높은 중재자의 PI는 항상1, PO는 0<ul>
<li>  PI는 항상1 : 버스 신청 시 항상 할당</li>
<li>만약 해당 중재자가 버스의 사용을 원치 않을 경우, 해당 중재자의 PI = 0, PO = 1 이 되어 다음 중재자로 전송됨</li>
</ul>
</li>
<li>Bus busy line 상태 확인<br> : 해당 중재자(PI=1, PO=0 을 할당 받은 경우)는 bus 신청 전 Bus busy line의 상태 확인해야 함<ul>
<li>  비활성 상태 $\rightarrow$ 해당 프로세서는 버스 라인을 할당 받고, Bus busy line을 활성 상태로 변경</li>
<li>활성 상태 $\rightarrow$ 낮은 우선 순위의 프로세서가 버스를 사용하고 있는 것으로 버스 사용을 완료할 때까지 대기 (프로세서는 버스 사용을 완료하면 Bus busy lined을 비활성 상태로 전환시킴)<ul>
<li>  Bus busy line 의 활용 : 사용 중인 버스를 특정 중재자가 할당 받고자 할 경우 활용되는 기법</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<!-- 사용 중 버스를 할당받을 때 -->


<h3 id="병렬-중재-논리"><a href="#병렬-중재-논리" class="headerlink" title="병렬 중재 논리"></a>병렬 중재 논리</h3><p>각 버스 중재자는 **버스 요청 출력 라인(Req)**과 **버스 승낙 입력 라인(Ack)**을 보유</p>
<p>Bus busy line은 Daisy-chain 의 경우와 동일</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%B2%84%EC%8A%A4%EC%A0%9C%EC%96%B4%EA%B8%B0_%EB%B3%91%EB%A0%AC%EC%A4%91%EC%9E%AC.png">    </p>
<ul>
<li><p>우선순위를 가지고 있음</p>
</li>
<li><p>Bus arbiter (버스 중재자) 는 Ack, Req (acknowledge, request) 두가지 요소를 가지고 있음</p>
</li>
<li><p>우선순위 인코더 진리 표</p>
<ul>
<li>IST 가 1 이면 전송, 아니면 전송 안함</li>
</ul>
</li>
<li><p>Bus arbirtration</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/IEEE%ED%91%9C%EC%A4%80_796%EB%8B%A4%EC%A4%91%EB%B2%84%EC%8A%A4%EC%8B%A0%ED%98%B8.png" alt="IEEE 표준 796 다중 버스 신호">    </p>
<ul>
<li><p>BPRN(Bus priority in) &amp; BPRO(Bus priority out)</p>
<p>  버스 우선순위 입력과 버스 우선순위 출력<br>  $\rightarrow$ 버스 중재 회로의 Daisy-chain 연결에 활용  </p>
<ul>
<li>4X2 Priority encoder 와 2X4 Decoder 에 의해 요구됨</li>
</ul>
</li>
<li><p>BUSY(Bus busy, 버스 혼잡 신호)<br>  $\rightarrow$ 버스가 사용 중임을 모든 중재자에게 알리는 open collector 출력</p>
<ul>
<li>활성화되있으면 못쓰게, 비활성화면 쓸 수 있게 함</li>
</ul>
</li>
<li><p>CBRQ(Common bus request, 공통 버스 요구)<br>  $\rightarrow$ open collector 출력, 우선 순위가 낮은 중재자가 현재 버스 사용 중인지 확인(사용중이면 기다려야함)</p>
</li>
<li><p>각각의 acknowledge 와 request 에 BREQ(Bus request) &amp; BPRN(Bus priority in)을 연결하고,<br>  BCLK(Bus clock)은 모든 버스 작업의 동기화에 활용</p>
<ul>
<li>다시말해, BCLK(Bus clock) 은 한 중재자가 버스를 오래 붙잡고 있지 못하도록 하는 역할 (모든 버스 작업을 동기화 시킴)</li>
<li>누가 무엇이 필요한지, 사용 가능한지, ACK, REQ 와 같은 신호에 같이 세팅을 하여 시작함 (세팅-시작-세팅-시작…)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="입출력-주소-지정"><a href="#입출력-주소-지정" class="headerlink" title="입출력 주소 지정"></a>입출력 주소 지정</h2><!-- 중재에서 동기화/비동기화 차이점 공부 -->


<ul>
<li><p>컴퓨터 시스템에는 다양한 입출력 장치 및 통신 포트 등이 연결됨</p>
</li>
<li><p>서로 구분하기 위해 각 입출력장치 또는 통신 포트에 고유한 주소 할당</p>
</li>
<li><p>상태나 데이터의 입출력 용도에 따라 다수의 주소 할당이 가능</p>
<ul>
<li>일반 저장공간에 할당된 주소에 비해 입출력장치의 개수가 작기 때문</li>
</ul>
</li>
<li><p>분류</p>
<ul>
<li><p>Memory mapped I/O : 메모리에 부여된 주소 공간의 일부를 입출력 주소 공간으로 활용</p>
<ul>
<li>  동일한 주소선과 제어선으로 입출력 관리 가능</li>
<li>  시스템은 지정된 주소 값에 의해 데이터 저장 공간과 I/O장치 구분</li>
<li>  모든 CPU에 대해 구현이 가능하나, H/W 적 (주소 값에 따라) 분류 접근 구현이 필요</li>
</ul>
</li>
<li><p>I/O mapped I/O : <strong>독립된 메모리 주소 공간</strong>과 <strong>입출력 주소 공간</strong>을 <strong>구분</strong>하여 할당</p>
<ul>
<li>  메모리와 입출력 주소를 구분하는 제어선 (M/$\overline{IO}$)을 사용</li>
<li>  상호 구분되는 명령어(상호 동일한 주소일 경우)가 필요</li>
<li>  제어 신호를 통해 메모리/입출력 장치에 접근이 가능하도록 H/W 적 구현이 필요</li>
</ul>
<blockquote>
<p>Memory mapped I/O 은 모든 CPU 에서 구현이 가능</p>
</blockquote>
<blockquote>
<p>I/O mapped I/O 은 I/O용 별도의 명령어와 이를 위한 외부 제어선이 있는 CPU에서만 구현이 가능</p>
</blockquote>
<blockquote>
<p>단, PC 에서는 양자 모두 구현이 가능하다고 알려져 있음</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="입출력-버스-할당"><a href="#입출력-버스-할당" class="headerlink" title="입출력 버스 할당"></a>입출력 버스 할당</h2><h3 id="중앙-제어-버스-vs-분산-제어-버스"><a href="#중앙-제어-버스-vs-분산-제어-버스" class="headerlink" title="중앙 제어 버스 vs 분산 제어 버스"></a>중앙 제어 버스 vs 분산 제어 버스</h3><p>병렬중재 절차 vs 직렬중재 절차와 비슷 (앞에선 중재관점이었다면, 여기선 제어관점)</p>
<h4 id="중앙-제어-버스-시스템"><a href="#중앙-제어-버스-시스템" class="headerlink" title="중앙 제어 버스 시스템"></a>중앙 제어 버스 시스템</h4><p>구현 및 관리가 용이 하나 제어기의 이상 발생 시, 버스 중재 및 활용에 결함 발생 가능</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%A4%91%EC%95%99%EC%A0%9C%EC%96%B4%EB%B2%84%EC%8A%A4%EC%8B%9C%EC%8A%A4%ED%85%9C.png">    </p>
<h4 id="분산-제어-버스-시스템"><a href="#분산-제어-버스-시스템" class="headerlink" title="분산 제어 버스 시스템"></a>분산 제어 버스 시스템</h4><p>버스 상의 모든 장치가 제어 기능을 나누어 실행 (단가는 올라가겠지만, 유연성$\uparrow$)</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B6%84%EC%82%B0%EC%A0%9C%EC%96%B4%EB%B2%84%EC%8A%A4%EC%8B%9C%EC%8A%A4%ED%85%9C.png">    </p>
<ul>
<li> I/O 버스는 주로 중앙 제어 버스 시스템을 적용</li>
<li> 시스템 버스는 분산 제어 방식을 선호</li>
</ul>
<h3 id="동적-중재-알고리즘"><a href="#동적-중재-알고리즘" class="headerlink" title="동적 중재 알고리즘"></a>동적 중재 알고리즘</h3><p>: 정적 우선 순위 알고리즘에 대해 시스템이 동작하고 있는 동안 <strong>장치들의 우선 순위를 변경 시킬 필요가 있을 경우</strong> 적용 가능한 알고리즘</p>
<p>ex) 인터럽트는 아니지만, 작업 우선순위 또는 메모리를 공유하여 사용하는 경우가 발생하면서, 순서상으론 뒤에있는 애가 먼저 처리될 필요가 있을 때</p>
<ul>
<li><p>Time slice algorithm (시분할 알고리즘)</p>
<p>  : 연속적으로 주어지는 버스 시간을 고정된 길이의 시간 분할로 나누고 이를 round-robin 방식으로 각 프로세스에 할당, 버스에서의 위치에 관계없이 모든 요소들이 동등한 서비스 받음</p>
</li>
<li><p>Polling 을 이용한 버스 시스템</p>
<p>  : 폴(poll) 라인으로 버스 승인 신호를 대체하여 모든 장치에 연결</p>
<ul>
<li><p>버스제어기는 이 신호를 이용하여 각 장치의 주소를 결정</p>
</li>
<li><p>지정된 순서에 따라 버스를 할당 받음 = 프로그램으로 우선순위변경 가능</p>
</li>
<li><p>[참고] 폴링(polling)이란? </p>
<ul>
<li>하나의 장치(또는 프로그램)가 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식</li>
<li> 버스, 멀티포인트 형태와 같이 여러 개의 장치가 동일 회선을 사용하는 상황에서 주로 사용됨</li>
<li> 서버의 제어 장치(또는 프로그램)는 순차적으로 각 단말 장치(또는 프로그램)에 회선을 사용하기 원하는지를 물어본다.</li>
</ul>
</li>
</ul>
</li>
<li><p>LRU(Least recently used) algorithm</p>
<ul>
<li>가장 오랫동안 버스 서비스를 사용하지 못한 장치에게 우선권 부여<ul>
<li>  일정 사이클 마다 LRU algorithm 에 의해 각 장치의 우선순위가 계속 변경 됨</li>
</ul>
</li>
<li>  모든 프로세스가 버스에 접근할 수 있는 <strong>기회를 동등</strong>하게 부여 받음</li>
</ul>
</li>
<li><p>First-com &amp; First-serve 방식</p>
<ul>
<li>  버스 제어기는 각 프로세스의 버스 요구 도착시간별 저장이 가능한 큐(queue)를 이용해 <strong>도착한 순서대로</strong> 서비스 제공</li>
</ul>
</li>
<li><p>Rotating daisy chain 방식</p>
<ul>
<li>  모든 장치를 연결(closed loof) 하여 차례로 버스 서비스를 제공하는 방식</li>
</ul>
</li>
</ul>
<h2 id="입출력-수행의-분류"><a href="#입출력-수행의-분류" class="headerlink" title="입출력 수행의 분류"></a>입출력 수행의 분류</h2><h3 id="동기-버스에-의한-수행"><a href="#동기-버스에-의한-수행" class="headerlink" title="동기 버스에 의한 수행"></a>동기 버스에 의한 수행</h3><p>버스에 연결된 <strong>모든 장치들에 동일하게 적용</strong>하는 버스 clock이 있고, 주소와 자료 및 다른 제어선들은 버스 clcok을 기준으로 전송됨 (예외 없음)</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8F%99%EA%B8%B0%EB%B2%84%EC%8A%A4%EC%97%90_%EC%9D%98%ED%95%9C_%EC%88%98%ED%96%89.png">    </p>
<ul>
<li>Bus clock(0 $\rightarrow$ 1)<ul>
<li>  필요 장치의 주소 및 제어신호를 버스로 발송</li>
<li>  지정된 장치는 주소 식별 후</li>
</ul>
</li>
<li>Bus clock(1 $\rightarrow$ 0)<ul>
<li>  데이터 전송 시작</li>
</ul>
</li>
</ul>
<blockquote>
<p>버스의 연결된 모든 장치는 클락에 맞춰 입출력이 진행되도록 설계되어야 함</p>
</blockquote>
<h3 id="비동기-버스에-의한-수행"><a href="#비동기-버스에-의한-수행" class="headerlink" title="비동기 버스에 의한 수행"></a>비동기 버스에 의한 수행</h3><p>비동기 = shake hand</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B9%84%EB%8F%99%EA%B8%B0%EB%B2%84%EC%8A%A4%EC%97%90%EC%9D%98%ED%95%9C%EC%88%98%ED%96%89.png">    </p>
<ol start="0">
<li>주소선에 지정된 I/O 장치 주소를 전송</li>
</ol>
<ol>
<li>CPU로부터 I/O 제어기를 통해 해당 장치의 Ready 신호 활성 $\Rightarrow$ I/O 전송 요구 Ready 신호 활성<br> $\Rightarrow$ Ready 신호에 대한 응답으로 Accept 신호 전송</li>
<li>응답/자료 전송 $\Rightarrow$ Data 전송</li>
<li> 작업 종료 신호의 비활성화</li>
</ol>
<blockquote>
<p>유연성은 좋으나, 복잡함 (일일히 찾아가서, 그때그때에 신호에 따라 명령을 줘야함)  </p>
</blockquote>
<blockquote>
<p>단순한 상황에 사용하기 좋음</p>
</blockquote>
<!-- 25\. 입출력 수행과 인터럽트
================= -->

<h2 id="Interrupt에-의한-I-O"><a href="#Interrupt에-의한-I-O" class="headerlink" title="Interrupt에 의한 I/O"></a>Interrupt에 의한 I/O</h2><p>효율적인 시스템 퍼포먼스를 위해 적용하게 됨</p>
<h3 id="입출력-장치와-CPU간-전송-모드-측면"><a href="#입출력-장치와-CPU간-전송-모드-측면" class="headerlink" title="입출력 장치와 CPU간 전송 모드 측면"></a>입출력 장치와 CPU간 전송 모드 측면</h3><p>입출력 전송(I/O transfer) 구조 상 CPU의 interrupt 활용모드</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%EC%9D%98%ED%95%9CIO.png">    </p>
<ul>
<li><p>CPU, I/O device 속도차이가 너무 심해서, 관리해주는 MDA 또는 Interface 존재</p>
<ul>
<li>Interrupt 사용의 경우<ul>
<li>I/O bus를 타고 I/O device 정보가 Data register에 적재(load)</li>
<li>정상적인 정보가 맞는지 I/O valid 로 표시</li>
<li>write 같은 상황에, 데이터에 대한 주소 또는 정확한 정보가 Data accepted로 I/O device로 들어옴</li>
</ul>
</li>
</ul>
</li>
<li><p>Data register에 정보가 load + State register에 F(flag bit) 가 Set 되면 Interrupt 해서 I/O 사용한다고 CPU에 알림 (CPU가 지금하고 있는 일 중지하고 I/O 먼저)</p>
<ul>
<li>내용에 대해 return 값을 Address bus 를 통해 요청하고,</li>
<li>read 인지 write 인지에 대한 정보를 줌</li>
</ul>
</li>
<li><p>이 때, CPU는 현재 수행 중이던 프로그램을 중지하고 I/O 전송을 수행, I/O 전송 후 프로그램으로 복귀</p>
<ol>
<li><p>CPU 인터럽트 신호 수신되면</p>
<ul>
<li><p>PC(re.add) $\rightarrow$ stack </p>
<p>   : Program Counter는 현재 작업하고 있는 정보를 stack에 저장</p>
</li>
<li><p>I/O 전송 서비스 루틴으로 제어 변경</p>
</li>
</ul>
</li>
<li><p>벡터 인터럽트, 비벡터 인터럽트 </p>
<p>: 주소를 전달을 해야하는지, 스칼라 값만을 이용해 처리 해주면 되는 건지 확인</p>
</li>
</ol>
</li>
<li><p>[복습] 10. 마이크로 명령어 - 인터럽트(Intterupt)</p>
</li>
</ul>
<h3 id="I-O-장치와-CPU간-전송에-대한-S-W-적-고찰"><a href="#I-O-장치와-CPU간-전송에-대한-S-W-적-고찰" class="headerlink" title="I/O 장치와 CPU간 전송에 대한 S/W 적 고찰"></a>I/O 장치와 CPU간 전송에 대한 S/W 적 고찰</h3><ul>
<li>컴퓨터는 주변 장치와의 인터페이스를 위한 H/W 못지 않게 S/W 루틴을 가져야 함<ul>
<li>  주변 장치 제어</li>
<li>  프로세서와 주변 장치 사이에 데이터 전송</li>
</ul>
</li>
<li>I/O routine 은 주변 장치의 활성화를 위한 제어 커맨드의 발송, 데이터 전송을 위한 준비 상태(device status) 체크 로직을 보유해야함<ul>
<li>  주변 장치의 활성화 예시 : 인터럽트 걸어서 주변 장치를 CPU로 처리할 수 있게 하는 상황</li>
</ul>
</li>
<li>입출력 소프트웨어는 시스템에 인터럽트 제어를 줄 수 있어야 하며, 이를 실행할 주변장치에 커맨드를 내려야함<ul>
<li>  CPU가 지금 하는 일을 중지하게 할 수 있는 권한이 필요 $\rightarrow$ 인터럽트</li>
<li>  인터럽트 이후, 주변장치를 컨트롤 할 수 있는 (예를들어, I/O device로 자료를 전송)  커맨드 필요</li>
</ul>
</li>
<li>DMA(Direct Memory Access) 전송 시 I/O 소프트웨어는 DMA 채널을 개시할 수 있어야함<ul>
<li>  우선순위를 주고 (daisy chain 처럼 순차가 정해져 있는 애의), 자료 전송 시작했을 때, 채널을 열 수 있어야함</li>
</ul>
</li>
</ul>
<h2 id="우선-순위-인터럽트"><a href="#우선-순위-인터럽트" class="headerlink" title="우선 순위 인터럽트"></a>우선 순위 인터럽트</h2><h3 id="입출력-장치와-CPU간-intterupt-논리"><a href="#입출력-장치와-CPU간-intterupt-논리" class="headerlink" title="입출력 장치와 CPU간 intterupt 논리"></a>입출력 장치와 CPU간 intterupt 논리</h3><ul>
<li><p>CPU와 I/O 장치 사이의 데이터 전송은 CPU에 의해 시작</p>
<ul>
<li><p>각 장치는 통신 준비 여부에 따라 CPU와 통신이 가능</p>
<ul>
<li>  통신 준비 여부 : 제어라인의 상태 or 플래그(flag)에 의해서 확인</li>
</ul>
</li>
<li><p>각 device interface는 플래그가 enable 되어있을 때 비로소 CPU에 인터럽트를 요청</p>
<ul>
<li>  (시스템 전체의 퍼포먼스를 위함)</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%EC%9D%98%ED%95%9CIO.png" alt="[복습] 인터럽트에 의한 IO">    </p>
</li>
</ul>
</li>
<li><p>프로세서가 서비스 루틴으로 분기 주소를 선택하는 방법</p>
<ul>
<li>Vectored interrupt<ul>
<li>  인터럽트를 내는 소스가 프로세서에게 분기에 대한 정보를 제공</li>
</ul>
</li>
<li>Non-vectored interrupt<ul>
<li>  분기 주소는 메모리의 고정 위치에 저장 되어 있음 (하드웨어적 처리, 어느 주소로 가야하고 이거 없이 그냥 쓰면 됨)</li>
</ul>
</li>
</ul>
</li>
<li><p>  수 많은 장치 중 인터럽트를 발생한 장치의 선별해야함</p>
</li>
<li><p>  동시 발생한 다수의 인터럽트의 우선 순위를 결정해야 하는 문제 발생</p>
</li>
<li><p>우선 순위 인터럽트 : 동시 다발적으로 발생한 인터럽트에 대한 서비스 순서를 결정하기 위해, 각 소스에 우선 순위를 부여한 인터럽트 시스템을 이르는 용어</p>
<ul>
<li>  우선 순위 결정은 소프트웨어(일반적으로 OS에 있음), 하드웨어(flag 쓰거나, Non-vecotred interrupt 등) 모두에서 처리</li>
<li>소프트웨어적으로 인터럽트 우선 순위를 결정하는 방법 $\rightarrow$ polling<ul>
<li>  모든 인터럽트를 위한 공통의 서비스 프로그램임 $\rightarrow$ 소요시간이 매우 길 수 있음 $\rightarrow$ H/W 적으로 (flag를 만들거나해서) 해결 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Daisy-chain-우선-순위-인터럽트"><a href="#Daisy-chain-우선-순위-인터럽트" class="headerlink" title="Daisy chain 우선 순위 인터럽트"></a>Daisy chain 우선 순위 인터럽트</h3><p>: 인터럽트를 발생시키는 모든 장치를 직렬로 연결함으로 이루어짐 (순서가 정해져있음)</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Daisy_chain_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.png">    </p>
<ul>
<li>Polling에 의해 Devidce1,2,3 가 우선순위 1,2,3</li>
<li>PI 가 1 일 때, PO는 0</li>
<li>Processor data bus 에 실어서 VAD(vector address) 요청</li>
<li>VAD 요청받은 CPU가 INTA(Intterupt acknowledge, 허락신호)를 줌<ul>
<li>이 때, CPU는 다른 interrupt를 받을 수 없게 비활성화 됨 (현재 interrupt 가 끝날 때 까지 기다려야함)</li>
</ul>
</li>
<li>device1 에 프로세스 진행</li>
<li>끝나면 PI=0, PO=1이 되서 다음 우선순위 device로 넘어감</li>
<li>PI 가 1, PO는 0 … (반복)</li>
</ul>
<p>[복습] 14. 입출력 구조 - 시스템 버스의 활용 - 직렬 중재 절차</p>
<h3 id="병렬-우선-순위-인터럽트"><a href="#병렬-우선-순위-인터럽트" class="headerlink" title="병렬 우선 순위 인터럽트"></a>병렬 우선 순위 인터럽트</h3><p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%B3%91%EB%A0%AC%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.png" alt="병렬 우선 순위 인터럽트">    </p>
<ul>
<li><p>병렬 우선 순위 인터럽트</p>
<p>  : 각 장치의 인터럽트 요청에 따라 각 비트가 개별적으로 세트 될 수 있는 레지스터를 사용</p>
<ul>
<li>Interrupt register : 기본적으로 순위가 나눠져 있음 (위치 순)<ul>
<li>0: Disk, 1: Printer, 2: Reader, 3: Keyboard</li>
</ul>
</li>
<li>Mask register : 인터럽트 요청 상태를 조정할 수 있음 (1일 때, Interrupt register 신호가 인식 됨)</li>
</ul>
</li>
<li><p>우선순위 인코더 진리표</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%EC%9D%B8%EC%BD%94%EB%8D%94%EC%A7%84%EB%A6%AC%ED%91%9C.png"></p>
<p>  $x = I’<em>{0}I</em>{1}$<br>  $y = I’<em>{0}I</em>{1} + I’<em>{0}I’</em>{2}$ </p>
<p>  [복습] 14. 입출력 구조 - 시스템 버스의 활용 - 병렬 중재 논리 - 진리표 (같은 내용)</p>
</li>
<li><p>병렬 우선 순위 인터럽트의 논리 흐름</p>
<ol>
<li><p>우선 순위 인코더는 벡터주소(VAD)의 두 비트(x, y) $\rightarrow$ CPU</p>
</li>
<li><p>마스크 되지 않은 인터럽트 발생시 IST를 set 시킴</p>
<ul>
<li>마스크 되지 않은 인터럽트 = 예상하지 못한 인터럽트</li>
</ul>
<p>$(IST) = I_{0} + I_{1} + I_{2} + I_{3}$  </p>
</li>
<li><p>인터럽트 제어 프로그램에 의해 Value(IEN) 결정     </p>
</li>
<li><p>IST and IEN $\rightarrow$ interrupt to CPU</p>
</li>
<li><p>INTACK from CPU and IST $\rightarrow$ Enable(bus buffer)</p>
<p> : CPU로 부터 Intterupt acknowledge (인터럽트 허락 신호)를 받으면 bus buffer를 enable 시킴</p>
<ul>
<li>번지수(VAD)가 CPU로 넘어가서 interrupt 걸림</li>
</ul>
</li>
</ol>
</li>
<li><p>다시 말해서,</p>
<ul>
<li><p>IEN (Interrupt Enable Register) 상태값 : 인터럽트 사이클</p>
<p> <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%82%AC%EC%9D%B4%ED%81%B4_%E2%80%AAIEN%EC%83%81%ED%83%9C%EA%B0%92.png" alt="인터럽트 사이클(‪IEN 상태값)">    </p>
<ul>
<li><p>SP $\leftarrow$ SP + 1 : 현재 실행되고 있는 상태의 다음 번지 값을 Stack Point 에 저장</p>
</li>
<li><p>M[SP] $\leftarrow$ PC : SP가 저장된 기억공간에, Program Counter 값을 저장 (CPU가 stack에 PC 저장)</p>
</li>
<li><p>INTACK $\leftarrow$ 1 : Intterupt acknowledge 를 1로 set = interrupt 진행</p>
</li>
<li><p>PC $\leftarrow$ VAD : 인터럽트 활성화되었고, 실행 상태 SP 에 저장했으니까 Program Counter 에 번지값(VAD)를 넣음  </p>
</li>
<li><p>IEN $\leftarrow$ 0 : 인터럽트 기능 사용 중지(프로세서가 인터럽트 인지)</p>
</li>
<li><p>G0 to fetch cycle : 실행을 위해서 어떤 정보를 불러와야할까 = fetch cycle (exute됨)</p>
</li>
<li><p>각 수행 사이클이 종류 된 뒤<br> if CPU $\leftarrow$ IEN(‘1’) &amp; IST(‘1’),<br> then do interrupt,<br> else do fetch </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="15-병렬-컴퓨터-구조와-성능-분석"><a href="#15-병렬-컴퓨터-구조와-성능-분석" class="headerlink" title="15. 병렬 컴퓨터 구조와 성능 분석"></a>15. 병렬 컴퓨터 구조와 성능 분석</h1><h2 id="시스템의-병렬-처리"><a href="#시스템의-병렬-처리" class="headerlink" title="시스템의 병렬 처리"></a>시스템의 병렬 처리</h2><p>Serial process system vs Parallel process system</p>
<blockquote>
<p>Parallel process system 로 가야함</p>
</blockquote>
<p>참고자료 : <a target="_blank" rel="noopener" href="https://www.slideserve.com/chars/2407602">병렬 컴퓨터 구조</a></p>
<h3 id="Serial-process-system"><a href="#Serial-process-system" class="headerlink" title="Serial process system"></a>Serial process system</h3><ul>
<li>CPU가 하나 뿐인 시스템</li>
<li>과학, 계산, 영상, 네트워크 등 컴퓨터 처리 전 분야에 걸쳐 더 나은 성능 개선 요구가 끊임없이 제기 되고 있음 (한계 다 다름)</li>
<li>기계적, 논리적 프로세싱으로는 가장 효율적</li>
</ul>
<h3 id="Parallel-process-system"><a href="#Parallel-process-system" class="headerlink" title="Parallel process system"></a>Parallel process system</h3><ul>
<li>동시에 여러 명령 또는 여러 작업을 실행 할 수 있는 시스템</li>
<li>병렬처리 시스템이 가능한 시스템을 병렬 구조라 함</li>
<li>병렬처리 시스템 구현 기술의 일환인 병렬 처리 소프트웨어(병렬 운영체제, 병렬 컴파일러, 메모리 공유 등)이 과거에 비해 현저히 발전하고 있음 (병렬구조개발 여건 제공)</li>
</ul>
<h4 id="다중-장치-amp-파이프라인-구조"><a href="#다중-장치-amp-파이프라인-구조" class="headerlink" title="다중 장치 &amp; 파이프라인 구조"></a>다중 장치 &amp; 파이프라인 구조</h4><p>[복습] 12. Pipeline 과 벡터처리 - 병렬 처리</p>
<ul>
<li>다중 장치 구조<ul>
<li><strong>다수의 CPU</strong>로 동시에 여러 개의 작업을 병렬로 처리 할 수 있는 시스템</li>
<li>공간적 병렬성(spatial parallelism)</li>
<li>[복습] 12. Pipeline 과 벡터처리 - 병렬 처리 - M.J Flynn의 분류 (MIMD)</li>
</ul>
</li>
<li>파이프라인 구조<ul>
<li>다수의 작업을 <strong>각기 다른 실행 단계에서</strong> 병렬로 처리 할 수 있도록 지원되는 구조</li>
<li>시간적 병렬성(temporal parallelism)</li>
<li>[복습] 12. Pipeline 과 벡터처리 -Pipeline 구조와 성능 (꽉꽉 눌러서 일하는 거, 다중으로 설명 못함)</li>
</ul>
</li>
</ul>
<h2 id="멀티프로세서"><a href="#멀티프로세서" class="headerlink" title="멀티프로세서"></a>멀티프로세서</h2><p>: 메모리와 I/O 장치를 공유하는 두 개 이상의 CPU를 갖는 시스템</p>
<ul>
<li><p>멀티 프로세서의 특징</p>
<ul>
<li>MIMD 시스템으로 분류 (다중 명령어 흐름과 다중 데이터 흐름)</li>
<li>하나의 운영체제에 의해 프로세서와 시스템의 다른 요소들 사이의 상호 동작이 제어됨</li>
<li>동일한 문제의 해결을 위해 모든 요소들이 협력(<strong>$\ne$멀티 컴퓨터</strong> : 운영체제가 따로 따로 있음)</li>
<li>사용자가 명시적으로 병렬 실행이 가능한 작업을 선언(프로그램 실행의 병렬성을 구현 할 수 있는 프로그래밍 언어의 제공이 선결 과제)</li>
<li>컴파일러가 자동적으로 프로그램의 병렬성을 감지해 처리 (데이터 의존성을 검사하여 수행 순서나 병렬성을 찾아냄)</li>
</ul>
</li>
<li><p>멀티 프로세서의 동작 원리 </p>
<ul>
<li>다수의 독립적인 작업들이 병렬적으로 처리 될 수 있음</li>
<li>하나의 작업이 여러 부분으로 나뉘어 각각이  병렬적으로 처리 될 수 있음</li>
</ul>
</li>
<li><p>멀티 프로세서의 분류 (OS와 연결됨!)</p>
<ul>
<li>Shared-memory 또는 Tightly coupled multiprocessor (밀착결합 멀티프로세서)<ul>
<li>가장 일반적, 연관있는 작업에 사용, 중재에 민감</li>
<li>시스템의 특징 : 프로세스와 메모리 사이 경로 수에 따라 여러가지 물리적으로 다른 구성을 보임</li>
</ul>
</li>
<li>Distributed memory : 분산메모리<ul>
<li>프로세서마다 따로따로 기능을 가지고 있는 독립된 형태</li>
<li>서로를 네트워킹 하면서 어떤 문제 발생하면 해결</li>
</ul>
</li>
<li>Loosely coupled : 분리된 체제, 한순간에 하나만 적용<ul>
<li>CPU가 프로세서를 옮겨다니면서 봄</li>
<li>시스템의 특징 : 프로세싱 요소들 사이의 전송 경로 수에 따라 여러가지 물리적으로 다른 구성을 보임</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="상호-연결-구조"><a href="#상호-연결-구조" class="headerlink" title="상호 연결 구조"></a>상호 연결 구조</h3><ul>
<li>멀티 프로세서 시스템은 CPU, IOP 그리고 여러 모듈로 분리된 메모리 장치에 의해 구성<ul>
<li>Shared-memory 시스템 : 프로세스와 메모리 사이 경로 수에 따라 여러가지 물리적으로 다른 구성을 보임</li>
<li>Loosely coupled 시스템 : 프로세싱 요소들 사이의 전송 경로 수에 따라 여러가지 물리적으로 다른 구성을 보임</li>
</ul>
</li>
</ul>
<h4 id="시분할-공통-버스"><a href="#시분할-공통-버스" class="headerlink" title="시분할 공통 버스"></a>시분할 공통 버스</h4><ul>
<li><p>단일 공통 버스 시스템</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A8%EC%9D%BC%EA%B3%B5%ED%86%B5%EB%B2%84%EC%8A%A4%EC%8B%9C%EC%8A%A4%ED%85%9C.png" alt="단일 공통 버스 시스템">    </p>
<ul>
<li>주어진 시간에 오직 하나의 프로세서만이 전송을 행 할 수 있음</li>
<li>충돌 발생 가능성이 있으나 버스 제어기에 의해 해결 가능</li>
<li><strong>시스템내의 전체 전송률이 단일 경로의 속도에 제한</strong> 될 수 있음</li>
</ul>
</li>
<li><p>이중 버스 구조 (좀 더 개선된 구조, 좀 더 타이트함)</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EC%9D%B4%EC%A4%91%EB%B2%84%EC%8A%A4%EA%B5%AC%EC%A1%B0.png" alt="이중 버스 구조">    </p>
<ul>
<li>모든 시스템이 동시에 쓸 수 있는 Common Shared Memory, 즉, 공통적인 메모리 공간이 존재</li>
<li>각 프로세서들의 대기시간이 줄어들고, 여러개의 버스 전송이 동시에 진행 가능</li>
<li>(단, 시스템 구축 비용과 복잡도 증가)</li>
<li>각 로컬 버스를 시스템 버스에 연결 (시스템 버스 제어기에 의함)</li>
<li><strong>주어진 시간엔 하나의 프로세서만이 시스템 버스를 사용</strong></li>
</ul>
</li>
</ul>
<h4 id="다중-포트-메모리"><a href="#다중-포트-메모리" class="headerlink" title="다중 포트 메모리"></a>다중 포트 메모리</h4><ul>
<li><p>다중 포트 메모리</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A4%EC%A4%91%ED%8F%AC%ED%8A%B8%EB%A9%94%EB%AA%A8%EB%A6%AC.png" alt="다중 포트 메모리">    </p>
<ul>
<li>CPU 또는 IOP와 각 메모리 모듈이 버스라인을 갖고 있는 시스템</li>
<li>각 모듈은 내부 논리 회로를 가짐<ul>
<li>주어진 시간에 어떤 포트가 메모리에 접근 할 수 있는가를 결정하기 위함<br> = 어떤 포트로 결정될지는 내부 논리 회로에 의해 결정</li>
</ul>
</li>
<li>메모리 접근을 위한 우선 순위는 일반적으로 포트의 위치에 따라 결정<ul>
<li>Polling 의 특징을 가짐</li>
</ul>
</li>
<li>장점 : 프로세스와 메모리 사이의 높은 전송률</li>
<li>단점 : 고가의 메모리 제어 논리 회로와 전선 커넥터</li>
</ul>
</li>
<li><p>크로스바 스위치<br>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%ED%81%AC%EB%A1%9C%EC%8A%A4%EB%B0%94%EC%8A%A4%EC%9C%84%EC%B9%98.png" alt="크로스바 스위치">    </p>
<ul>
<li>Crossbar Switch 구성 : 프로세스 버스와 메모리 모듈 통로 간의 교차점에 위치한 다수의 Crosspoints로 구성</li>
<li>Crosspoints : (그림에서 하얀네모) 프로세서와 메모리 모듈간의 통로를 결정하는 스위치</li>
<li>역할 : 버스에 실린 주소를 확인하여 통로를 열어줌, 주어진 순위에 따라 중재 역할 가능</li>
<li>굉장히 병렬적이지만, 돈이 많이 듬</li>
</ul>
</li>
</ul>
<h4 id="다단-교환망"><a href="#다단-교환망" class="headerlink" title="다단 교환망"></a>다단 교환망</h4><ul>
<li><p>다단망에서 기본 요수는 2입력, 2출력 상호교환 스위치 (연결 구조)</p>
<ul>
<li><p>크로스바 스위치 비슷한데, 입력이 2개</p>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/%EB%8B%A4%EB%8B%A8%EA%B5%90%ED%99%98%EB%A7%9D.png" alt="다단교환망">    </p>
</li>
</ul>
</li>
<li><p>역할 : 2개의 입력 중 하나만을 선택하여 전체 경로를 연결</p>
</li>
<li><p>기능 : 충돌을 중재하는 기능</p>
</li>
<li><p>입력과 출력 단자를 연결할 수 있는 제어 신호 필요</p>
</li>
</ul>
<h4 id="하이퍼큐브-상호연결"><a href="#하이퍼큐브-상호연결" class="headerlink" title="하이퍼큐브 상호연결"></a>하이퍼큐브 상호연결</h4><ul>
<li>$2^n$ 개의 프로세서가 n 차원 이진 큐브로 연결된 느슨히 결합된 시스템을 의미</li>
<li>각 프로세스는 큐브의 노드를 형성하는데 노드에는 CPU 뿐만 아니라 로컬 메모리나 I/O인터페이스도 포함  <!-- ![](/media/컴퓨터구조_files/3차원이진큐브.png)     -->
  <!-- ![](/media/컴퓨터구조_files/3차원이진큐브.gif)     -->
</li>
<li>1-3D Hypercube</li>
</ul>
<p><img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Hypercube.png" alt="1-3D Hypercube">    </p>
<ul>
<li>4D Hypercube  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4-%ED%81%90%EB%B8%8C.gif" alt="두 개의 3D Hypercube 를 결합하여 얻음">      출처 : <a target="_blank" rel="noopener" href="http://www.aistudy.com/math/graph_johnsonbaugh.htm">http://www.aistudy.com/math/graph_johnsonbaugh.htm</a>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/4%EC%B0%A8%EC%9B%90%EC%9D%B4%EC%A7%84%ED%81%90%EB%B8%8C2.png" alt="4D Hypercube">    </li>
</ul>
<h2 id="프로세서-간-중재"><a href="#프로세서-간-중재" class="headerlink" title="프로세서 간 중재"></a>프로세서 간 중재</h2><p>멀티 프로세스를 쓰기 때문에 다음과 같은 비교 분석을 해볼 필요가 있음</p>
<p>참고 : 14. 입출력 구조 - 시스템 버스의 제어</p>
<h3 id="시스템-버스-vs-로컬-버스"><a href="#시스템-버스-vs-로컬-버스" class="headerlink" title="시스템 버스 vs 로컬 버스"></a>시스템 버스 vs 로컬 버스</h3><p>컴퓨터 시스템에는 각 요소들 사이의 정보 전송을 위한 다양한 단계의 여러 버스가 존재하며 CPU 내에서도 레지스터와 ALU 사이의 정보 전송을 위한 여러 내부 버스가 존재한다. </p>
<ul>
<li>  System bus : CPU, IOP(I/O Processor), Memory 와 같은 주요 요소를 연결하는 연결체계</li>
<li>Local bus : 메모리 버스, I/O 버스, 통신 전용 버스<ul>
<li>  메모리 버스 : 데이터$\cdot$주소$\cdot$읽기/쓰기 정보 전송</li>
<li>  I/O 버스 : 입출력 장치로 정보 전송</li>
<li>  통신 전용 버스 : 특정 포트 정보, 해당 프로토콜 정보 등을 송/수신</li>
</ul>
</li>
</ul>
<p>$^{*<strong>}$**중재 프로세스</strong>는 전체 시스템 성능 향상에 지대한 영향을 미침  </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $^{***}$중재 프로세스 : 공유 메모리 멀티 프로세서 시스템에서 각 자원의 효율적 분배와 상호 충돌을 배제할 수 있는 프로세스</p>
<h3 id="메모리-공유-멀티-프로세서를-위한-시스템-버스-구조"><a href="#메모리-공유-멀티-프로세서를-위한-시스템-버스-구조" class="headerlink" title="메모리 공유 멀티 프로세서를 위한 시스템 버스 구조"></a>메모리 공유 멀티 프로세서를 위한 시스템 버스 구조</h3><p>![](/media/컴퓨터구조_files/시스템 버스 구조.png)</p>
<p>Common shared memory : 정보 받아들이고 처리 결과를 피드백</p>
<h3 id="중재-Algorithm"><a href="#중재-Algorithm" class="headerlink" title="중재 Algorithm"></a>중재 Algorithm</h3><ul>
<li>일반적으로 시스템 버스는 100여개의 신호라인으로 구성되고 이 명령라인에 의해 중재 논리가 성립됨 (ex, IEEE standard 796)</li>
<li>직렬(daisy-chain) 중재 절차</li>
<li>병렬 중재 논리</li>
<li>동적 중재 논리</li>
</ul>
<h2 id="프로세서-간-통신과-동기화"><a href="#프로세서-간-통신과-동기화" class="headerlink" title="프로세서 간 통신과 동기화"></a>프로세서 간 통신과 동기화</h2><h3 id="프로세서-간-통신"><a href="#프로세서-간-통신" class="headerlink" title="프로세서 간 통신"></a>프로세서 간 통신</h3><ul>
<li><p>멀티 프로세서 시스템에 있는 다양한 프로세서들은 공통의 입출력 채널을 통하여 서로 통신함</p>
</li>
<li><p>Common shared memory 의 역할 (=IOP에 연결된 자기 디스크 등의 역할)</p>
<ul>
<li>메모리의 일부를 모든 프로세서가 접근할 수 있도록 할당한 공간<ul>
<li>  우편함과 같이, 프로세서들 사이에서 오가는 메시지의 집중지</li>
</ul>
</li>
<li>통신 예시<br>  송신 프로세서 $\rightarrow$<br>  &nbsp; &nbsp; &nbsp; &nbsp; 요구, 메시지, 프로시저 저장 (상태비트 : 수신 프로세서 지정 및 의미 있는 정보의 유무를 공지)<br>  $\leftarrow$ 수신 프로세서(폴링방식에 의해 주기적 점검)</li>
<li>  효율적인 방법 : 인터럽트 신호를 통해, 송신 프로세서 $\rightarrow$ 수신 프로세서</li>
</ul>
</li>
<li><p>멀티 프로세서를 위한 운영체제의 종류</p>
<ul>
<li>Master-slave mode<ul>
<li> master 프로세서(OS기능 수행) $\leftarrow$ slave 프로세서는 필요에 의한 인터럽트 요청</li>
</ul>
</li>
<li>Separate OS<ul>
<li>  모든 프로세서가 자신의 운영체제를 가짐</li>
<li>  loosely coupled system 에 적합</li>
</ul>
</li>
<li>Distributed OS<ul>
<li>부동 운영체제(OS의 특정 기능은 한 순간에 하나의 프로세서에서만 작동)<ul>
<li>  즉, 운영체제가 여러 프로세서에 분산되어있는 형태</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="프로세서-간-동기화"><a href="#프로세서-간-동기화" class="headerlink" title="프로세서 간 동기화"></a>프로세서 간 동기화</h3><ul>
<li><p>멀티 프로세서의 명령어 집합은 함께 <em>동작하는 프로세서와의 통신</em>과 <em>동기화를 구현하는 기본 명령어</em>를 포함</p>
<ul>
<li>공통된 목적을 달성하기위해 프로세서끼리 통신을 하는데, 서로 영향을 주지 않도록 동기화 필요</li>
<li>동기화의 필요성<ul>
<li>처리될 작업들간 정확한 순서를 유지</li>
<li>공용의 기록가능한 변수에 대한 상호배제(mutual exclusive)적 접근 보장<ul>
<li>상호배제(mutual exclusive)는 절대 바뀌어선 안되는 것을 위함</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>대표적인 기법 :  이진 세마포어(semaphore)</p>
<ul>
<li>멀티 프로세서 시스템에서 자원의 동기화를 위해 가장 많이 활용되는 기법은 하드웨어적 접근 방법인 이진 세마포어(semaphore)를 이용하는 방법이다 <ul>
<li>주어진 값을 변경하지 않도록 locking하는 논리</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="캐시의-일관성"><a href="#캐시의-일관성" class="headerlink" title="캐시의 일관성"></a>캐시의 일관성</h2><h3 id="Cache-관련-정책"><a href="#Cache-관련-정책" class="headerlink" title="Cache 관련 정책"></a>Cache 관련 정책</h3><ul>
<li><p>Cache 일관성(cache coherence)</p>
<ul>
<li>공유 메모리 멀티 프로세서 시스템에서도 각 프로세서는 로컬 메모리를 운영</li>
<li>여러 개의 동일한 내용이 주 기억장치나 각 로컬 메모리에 복사본으로 중복되어 저장되는 경우가 발생 가능</li>
<li>따라서, 정확한 메모리 동작을 위해 이 내용들이 모두 동일하게 유지되어야 하는 정책, Cache coherence(일관성) 필요</li>
</ul>
</li>
<li><p>메모리 쓰기 동작 시 메모리 갱신 정책 (두 종류)</p>
<ul>
<li>  Write-through 정책 : 쓰기 동작 발생 시 캐시와 주기억장치 모두 갱신</li>
<li>  Write-back 정책 : 캐시만 갱신하고 다음에 메모리로 전달할 수 있도록 위치를 표시</li>
</ul>
</li>
</ul>
<h3 id="Cache-비-일관성"><a href="#Cache-비-일관성" class="headerlink" title="Cache 비 일관성"></a>Cache 비 일관성</h3><ul>
<li><p>Cache 일관성 문제의 발생 원인</p>
<ul>
<li> 각 프로세스 별로 개별적인 캐시를 가진 멀티 프로세서에서 공통의 기록 가능한 데이터가 필요하기 때문</li>
</ul>
</li>
<li><p>Cache 의 일관성 문제 예시</p>
<p>  <img src="/media/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0_files/Cashe%EC%9D%98%EC%9D%BC%EA%B4%80%EC%84%B1_Ex2.png"></p>
<ol>
<li>with write-through cashe polish<ul>
<li>② store 후 주기억장치도 새 값으로 갱신</li>
<li>$p_1$ 에 의한 cache 와 주기억장치는 일관성 유지</li>
<li>그러나, 나머지 두 cashe에는 비 일관성 초래</li>
</ul>
</li>
<li>with write-back cache polish<ul>
<li>실제 store가 일어나기전, 메모리 갱신이 발생하지 않음</li>
<li>따라서, 주 기억장치와 $p_2$, $p_3$, cache는 일관성 유지</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Cache-coherence-해결책"><a href="#Cache-coherence-해결책" class="headerlink" title="Cache coherence 해결책"></a>Cache coherence 해결책</h3><p>각 프로세서에 개별적인 cache를 허용하지 않고 주기억장치에 공용 cache 메모리를 두는 경우 - 근접성 원리에 위배, 평균 접근 시간을 증가시킴</p>
<ul>
<li>  Cacheable : 비 공유적이고 읽기 전용 데이터에 한해 cache에 저장되도록 하는 방안 (제한성이 따름)</li>
<li>  Snoopy cache controller : 기본적으로 버스에 부착 된 모든 <strong>cache에 대해 버스 감시 기능을 유지</strong>하도록 설계 된 H/W 장치 (시스템적으로 복잡)</li>
</ul>
<h1 id="과제"><a href="#과제" class="headerlink" title="과제"></a>과제</h1>
      
       <hr><span style="font-style: italic;color: gray;"> Thanks for reading my post. </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">Title:</span>컴퓨터 구조</p>
    
    <p><span class="copy-title">Author:</span><a  title="Chaejin Kim">Chaejin Kim</a></p>
    <p><span class="copy-title">Created At:</span>2021-04-12, 10:12:00</p>
    <p><span class="copy-title">Updated At:</span>2021-04-14, 14:25:18</p>
    <span class="copy-title">Url:</span><a class="post-url" href="/2021/04/12/ComputerScience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/" title="컴퓨터 구조">https://chaejin-jen.github.io/2021/04/12/ComputerScience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0/</a>
    <p>
        <span class="copy-title">Copyright:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#39;Attribution-non-commercial-shared in the same way 4.0&#39;</a> Reprint please keep the original link and author.
    </p>
</div>





    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021 Chaejin Kim
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="전체 화면 전환 단축키 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
        /* 渲染*/
        function HTMLDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            temp = null;
            return output;
        }
        if (window.mermaid){
            window.mermaid = null
        }
        $.getScript("//cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js", function () {
            var mermaidOptions = JSON.parse(HTMLDecode("{&#34;theme&#34;:&#34;default&#34;,&#34;startOnLoad&#34;:true,&#34;flowchart&#34;:{&#34;useMaxWidth&#34;:false,&#34;htmlLabels&#34;:true}}"))
            if (window.mermaid) {
                mermaid.initialize(mermaidOptions)
                mermaid.contentLoaded()
            }
        })
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 572px;
    }
    .nav.fullscreen {
        margin-right: -572px;
    }
    .nav-left {
        width: 150px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 542px;
        }
        .nav.fullscreen {
            margin-right: -542px;
        }
        .nav-left {
            width: 150px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 542px;
            margin-right: -542px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #3390FF;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
